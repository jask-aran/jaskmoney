# Jaskmoney v0.4 Spec & Implementation Plan

## Table of Contents

- [Context](#context)
  - [Current State (v0.3)](#current-state-v03)
  - [Target State (v0.4)](#target-state-v04)
  - [Data Migration Policy](#data-migration-policy)
  - [Behavioral Breaking Changes from v0.3](#behavioral-breaking-changes-from-v03)
- [Phase 1: Command System Overhaul (v0.31)](#phase-1-command-system-overhaul-v031)
  - [Command struct changes](#command-struct-changes)
  - [KeyRegistry integration](#keyregistry-integration)
  - [New commands to register](#new-commands-to-register)
  - [App-wide jump mode](#app-wide-jump-mode)
  - [Refactoring approach](#refactoring-approach)
  - [Command shape constraints (v0.4)](#command-shape-constraints-v04)
  - [Files changed](#files-changed)
  - [Tests](#tests)
  - [Acceptance](#acceptance)
- [Phase 2: Filter System Overhaul (v0.32)](#phase-2-filter-system-overhaul-v032)
  - [Filter expression language](#filter-expression-language)
  - [AST representation](#ast-representation)
  - [Integration with existing filter pipeline](#integration-with-existing-filter-pipeline)
  - [Strict filter builder surfaces](#strict-filter-builder-surfaces)
  - [Parser edge-case contract](#parser-edge-case-contract-must-be-covered)
  - [Saved filters](#saved-filters)
  - [New model fields](#new-model-fields)
  - [Saved filter commands](#saved-filter-commands)
  - [UI changes](#ui-changes)
  - [Commands](#commands)
  - [Files changed](#files-changed-1)
  - [Tests](#tests-1)
  - [Acceptance](#acceptance-1)
- [Phase 3: Rules Engine v2 (v0.33)](#phase-3-rules-engine-v2-v033)
  - [Schema changes (part of v4 → v5 migration)](#schema-changes-part-of-v4--v5-migration)
  - [Go types](#go-types)
  - [Rule application semantics](#rule-application-semantics)
  - [Dry-run command](#dry-run-command)
  - [Settings UI](#settings-ui)
  - [Model changes](#model-changes)
  - [Commands](#commands-1)
  - [DB functions](#db-functions)
  - [Import integration](#import-integration)
  - [Files changed](#files-changed-2)
  - [Tests](#tests-2)
  - [Acceptance](#acceptance-2)
- [Phase 4: Import Preview Integration (v0.34)](#phase-4-import-preview-integration-v034)
  - [Combined import preview modal](#combined-import-preview-modal)
  - [Post-rules preview](#post-rules-preview)
  - [Model changes](#model-changes-1)
  - [Flow change](#flow-change)
  - [Commands](#commands-2)
  - [Files changed](#files-changed-3)
  - [Tests](#tests-3)
  - [Acceptance](#acceptance-3)
- [Phase 5: Budgeting System (v0.35)](#phase-5-budgeting-system-v035)
  - [Schema additions (part of v5 migration)](#schema-additions-part-of-v5-migration)
  - [Go types](#go-types-1)
  - [Budget calculation](#budget-calculation)
  - [Tab structure](#tab-structure)
  - [Budget tab views](#budget-tab-views)
  - [Credit offset flow](#credit-offset-flow)
  - [Credit offset integrity rules](#credit-offset-integrity-rules)
  - [Model changes](#model-changes-2)
  - [Commands](#commands-3)
  - [DB functions](#db-functions-1)
  - [Files changed](#files-changed-4)
  - [Tests](#tests-4)
  - [Acceptance](#acceptance-4)
- [Phase 6: Dashboard v2 (v0.36+)](#phase-6-dashboard-v2-v036)
  - [Dashboard visual structure](#dashboard-visual-structure)
  - [Widget primitive](#widget-primitive)
  - [Canonical 4-pane layout (v0.4)](#canonical-4-pane-layout-v04)
  - [Pane mode definitions (domain-first)](#pane-mode-definitions-domain-first)
  - [Custom mode slots](#custom-mode-slots)
  - [Fixed layout](#fixed-layout)
  - [Focus model](#focus-model)
  - [Model changes](#model-changes-3)
  - [Drill-down with return context](#drill-down-with-return-context)
  - [Analytics scope](#analytics-scope)
  - [Commands](#commands-4)
  - [Files changed](#files-changed-5)
  - [Tests](#tests-5)
  - [Acceptance](#acceptance-5)
- [Phase Summary & Dependencies](#phase-summary--dependencies)
- [Release Train, Tag Granularity, and Stability Gates](#release-train-tag-granularity-and-stability-gates)
- [Schema v5 Migration Plan](#schema-v5-migration-plan)
- [File Organization](#file-organization)
  - [New files](#new-files)
  - [Modified files](#modified-files)
  - [Estimated scope](#estimated-scope)
- [Config Compatibility](#config-compatibility)
- [Verification](#verification)

---

## Context

v0.3 delivered accounts, tags, bulk selection, fuzzy pickers, a command palette/colon system, dashboard timeframe chips, and a keybinding registry (~19,500 LOC across 35 files). v0.4 is a major release that overhauls three foundational systems — commands, filtering, and rules — and adds budgeting and a dashboard v2 with focusable widget panes. The goal is to transform jaskmoney from a categorization-focused tracker into a full budgeting and analytics platform.

### Current State (v0.3)

- 3-tab TUI: Manager (accounts + transactions), Dashboard, Settings
- Schema v4: categories, category_rules, tags, tag_rules, transaction_tags, accounts, account_selection, transactions, imports
- Command palette (Ctrl+K) + colon mode (:) with 11 commands
- Keybinding registry with scoped lookups
- Fuzzy picker powering category picker, tag picker, command palette
- Bulk selection with shift-range highlighting
- Dashboard: timeframe chips, summary cards, spending tracker (braille chart), category breakdown
- Filter: text search (`/`), category filter (`f`), account filter (Manager scope)
- Import: file picker → dupe scan → dupe modal (A/S/C) → ingest + rule application

### Target State (v0.4)

- Commands as first-class action primitives for user-visible actions; universal primitives and cursor/input plumbing remain direct handlers
- Unified filter expression language powering search, rules, and advanced budget targets
- Rules v2: ordered, enable/disable, multi-field matching via filter expressions, set category + tags
- Import preview: combined dupe summary modal with optional full-view toggle
- 4-tab TUI: Dashboard, **Budget**, Manager, Settings
- Budget system: category budgets (recurring + overrides), advanced filter-based targets, credit offset linking
- App-wide jump mode (`v`) for spatial navigation across all tabs
- Dashboard v2: summary header strip + 4 curated panes with domain-first modes, custom mode slots from config, and drill-down to Manager with return context

### Data Migration Policy

- **All v0.3 data is preserved** (transactions, categories, tags, accounts, imports)
- **Rules v1 is a fresh start**: `category_rules` and `tag_rules` tables are dropped and replaced by `rules_v2`; users rebuild rules using the new system
- Schema version advances from 4 to 5

### Behavioral Breaking Changes from v0.3

- Tab order and number-key mapping changes from `Manager/Dashboard/Settings` (`1`/`2`/`3`) to `Dashboard/Budget/Manager/Settings` (`1`/`2`/`3`/`4`).
- Default landing tab changes from Manager to Dashboard.
- Category filter shortcut (`f`) is removed in favor of unified filter input (`/` with `cat:...` predicates).
- Navigation gains app-wide jump mode (`v`) replacing direct section-focus keys (`nav:focus-accounts`, `nav:focus-transactions`).
- Rules v1 data is intentionally dropped (fresh start for rules v2).

Required regression smoke checklist after rollout:
- Existing users can still navigate to prior core workflows (transactions table, settings import) with remapped keys.
- `v` enters jump mode and shows correct targets for the active tab.
- First launch after migration opens on Dashboard and shows expected account scope label.
- Old v0.3 DB opens without data loss in transactions/categories/tags/accounts/imports.
- Rules lists are empty after migration and rule creation flow works end-to-end.

---

## Phase 1: Command System Overhaul (v0.31)

**Goal:** Make commands the single source of user-visible actions while keeping universal primitives and cursor/input plumbing as direct handlers.

### Command struct changes

```go
type Command struct {
    ID          string
    Label       string
    Description string
    Category    string          // "Navigation", "Actions", "Filter", "Budget", etc.
    Scopes      []string        // scopes where this command is available
    Enabled     func(m model) (bool, string)
    Execute     func(m model) (model, tea.Cmd, error)
}
```

New fields:
- `Scopes []string` — declares which scopes the command is valid in (replaces implicit checks in `Enabled`). Empty = global.

### KeyRegistry integration

`Binding` gains a `CommandID` field:

```go
type Binding struct {
    Action    Action
    CommandID string   // links to Command.ID; empty for legacy/internal-only actions
    Keys      []string
    Help      string
    Scopes    []string
}
```

**Key dispatch flow change:**

Currently: `keyMsg` → scope lookup → `Action` → hand-coded switch in `updateXxx`.

New: `keyMsg` → scope lookup → `Binding.CommandID` → `CommandRegistry.Execute(id, m)` → return `(model, tea.Cmd)`.

For actions that are purely UI-internal (cursor movement, text input), the `CommandID` is empty and the existing switch dispatch is preserved. The principle: **anything that would appear in the command palette is a command; cursor/input plumbing is not**.

> **Architecture alignment:** The dispatch chain, scope hierarchy, key reuse safety rules, and conflict testing contract are defined in `specs/architecture.md` §3.4. All new scopes and bindings added in v0.4 phases must comply with the scope map (§3.4.10) and pass the key conflict testing invariants (§3.4.11). The `keybindings.toml` override format remains action-level flat maps (§3.4.7) — do not introduce per-scope TOML overrides.

Universal primitives also stay direct handlers and are intentionally not command-routed:
- `confirm` (`enter`)
- `cancel` (`esc`)
- `up` / `down` / `left` / `right`
- `delete`
- `quit`

### New commands to register

All existing keybinding-triggered actions that are user-visible become commands:

| ID | Label | Scopes |
|---|---|---|
| `nav:next-tab` | Next Tab | global |
| `nav:prev-tab` | Previous Tab | global |
| `nav:dashboard` | Go to Dashboard | global |
| `nav:manager` | Go to Manager | global |
| `nav:budget` | Go to Budget | global (registered now, disabled until Phase 5) |
| `nav:settings` | Go to Settings | global |
| `jump:activate` | Jump Mode | global |
| `jump:cancel` | Cancel Jump | jump_overlay |
| `txn:sort` | Cycle Sort Column | transactions |
| `txn:sort-dir` | Toggle Sort Direction | transactions |
| `txn:select` | Toggle Selection | transactions |
| `txn:clear-selection` | Clear Selection | transactions |
| `txn:quick-category` | Quick Categorize | transactions |
| `txn:quick-tag` | Quick Tag | transactions, manager |
| `txn:detail` | Open Detail | transactions |
| `txn:jump-top` | Jump to Top | transactions |
| `txn:jump-bottom` | Jump to Bottom | transactions |
| `filter:open` | Open Filter | transactions (registered now, wired in Phase 2) |
| `filter:clear` | Clear All Filters | transactions |
| `import:start` | Import CSV | settings |
| `rules:apply` | Apply All Rules | settings, global |
| `rules:dry-run` | Dry-Run Rules | settings, global (registered now, wired in Phase 3) |
| `settings:clear-db` | Clear Database | settings |
| `settings:nuke-account` | Nuke Account | settings |
| `dash:timeframe` | Focus Timeframe | dashboard |
| `dash:mode-next` | Next Widget Mode | dashboard_focused (registered now, wired in Phase 6) |
| `dash:mode-prev` | Previous Widget Mode | dashboard_focused (registered now, wired in Phase 6) |
| `dash:drill-down` | Drill Down | dashboard_focused (registered now, wired in Phase 6) |
| `palette:open` | Command Palette | global |
| `cmd:open` | Command Mode | global |

`txn:search` is removed in v0.4 spec language. `filter:open` is the canonical command ID for `/` filter input.

### App-wide jump mode

**Activation:** `v` enters jump mode globally. An overlay appears with labeled badges at each focusable section in the current tab. Pressing a target key focuses that section and dismisses the overlay. `Esc` cancels jump mode and restores the previously focused widget (or unfocused state).

This replaces the v0.3 `nav:focus-accounts` / `nav:focus-transactions` commands with a spatial, discoverable navigation model inspired by Bagels (`~/bagels-ref/src/bagels/components/jumper.py`).

**Per-tab jump targets and default focus:**

| Tab | Targets | Default focus (ESC returns to) |
|---|---|---|
| Dashboard | `n` Net/Cashflow, `c` Composition, `b` Compare Bars, `h` Budget Health | Unfocused (no pane selected) |
| Manager | `a` Accounts, `t` Transactions | Transactions (default section) |
| Budget | `t` Budget Table, `p` Planner | Budget Table |
| Settings | `r` Rules, `i` Imports, `d` Database, `w` Dashboard Views | Stay (no default reset) |

Target keys can overlap across tabs because only targets for the active tab are shown. Dashboard and Budget pane targets are registered in their respective phases (Phase 5 / Phase 6) but the infrastructure ships here.

**Focus lifecycle:**
1. `v` -> jump overlay appears with per-tab targets
2. Press target key -> focus moves to that section, overlay dismisses
3. Section-specific interactions available while focused (e.g. mode cycling on dashboard, inline edit on budget)
4. `Esc` -> focus returns to tab's default (or stays, for Settings)
5. `Esc` from default/unfocused state -> no-op

**Jump overlay visual:**
- Each target shows a floating badge at its top-left corner: `[n]`, `[c]`, `[b]`, `[h]`
- Badges use accent background on muted foreground
- Status bar reads: "Jump: press key to focus. ESC cancel."
- Focused sections get an accent-colored border; unfocused sections use the default muted border

**Model fields:**

```go
// Jump mode (global)
jumpModeActive    bool
jumpPreviousFocus int  // restore target on ESC from jump overlay; -1 = unfocused

// Per-tab focus
focusedSection    int  // -1 = unfocused; meaning is tab-specific
```

**Commands:**

| ID | Label | Scopes |
|---|---|---|
| `jump:activate` | Jump Mode | global |
| `jump:cancel` | Cancel Jump | jump_overlay |

### Refactoring approach

1. Add `CommandID` to `Binding` struct
2. Update `NewKeyRegistry` to set `CommandID` on all action-mapped bindings
3. Add `ExecuteByID(id string, m model) (model, tea.Cmd, error)` to `CommandRegistry`
4. In each `updateXxx` handler, replace action-switch cases with command execution for user-visible actions
5. Keep cursor/input/modal plumbing as direct action switches (no command overhead)
6. Implement jump mode infrastructure: `v` key binding, overlay rendering, per-tab target registration, focus lifecycle

### Command shape constraints (v0.4)

- Commands are **parameterless** in v0.4 (no argument parser yet).
- Registry metadata and IDs should remain future-ready for argument-bearing commands and workflows in v0.5+.

### Files changed

- `keys.go` — `Binding` gains `CommandID`; new `scopeJumpOverlay` scope; `v` binding for `jump:activate`
- `commands.go` — expanded registry, `ExecuteByID`, scope-aware availability; jump commands
- `update.go` — jump mode dispatch (overlay intercept before tab-specific handlers)
- `update_dashboard.go`, `update_transactions.go`, `update_manager.go`, `update_settings.go` — dispatch via command execution for user-visible actions
- `render.go` — `renderJumpOverlay` (badge positioning + status bar)

### Tests

- `commands_test.go` — all commands registered, `ExecuteByID` dispatches correctly, scope filtering works
- `keys_test.go` — every binding with a `CommandID` resolves to a registered command
- `keys_test.go` — global shadow audit, scope reachability, tab/jump key non-shadow (per `architecture.md` §3.4.11)
- `update_mode_test.go` — verify key presses still produce correct state changes (regression)
- `update_mode_test.go` — jump mode: `v` activates overlay, target key focuses section, ESC cancels and restores previous focus
- `update_mode_test.go` — per-tab default focus: ESC from focused section returns to tab default (Manager -> transactions, Dashboard -> unfocused, Settings -> stays)

### Acceptance

- [ ] All user-visible keybinding actions route through command registry
- [ ] Command palette shows all available commands for current scope
- [ ] Universal primitives (`confirm`, `cancel`, arrows/`hjkl`, delete, quit) remain direct handlers
- [ ] Cursor movement, text input, and modal plumbing remain as direct action handlers
- [ ] `v` activates jump mode; per-tab target keys shown as floating badges
- [ ] Jump target selection focuses the correct section; ESC cancels and restores previous focus
- [ ] Per-tab ESC behavior: Dashboard unfocuses, Manager returns to transactions, Settings stays
- [ ] Jump mode infrastructure supports deferred target registration (Dashboard/Budget targets added in later phases)
- [ ] Key conflict tests pass: global shadow audit, scope reachability, action-command consistency (`architecture.md` §3.4.11)
- [ ] `footerBindings()` correctly reflects active scope for all model states including jump mode and focused sections
- [ ] All existing tests pass; no behavior change for end users

---

## Phase 2: Filter System Overhaul (v0.32)

**Goal:** Replace the ad-hoc search + category filter + account filter with a unified filter expression language. The same language powers interactive search, rules (Phase 3), and advanced budget targets (Phase 5).
The v0.4 language is intentionally a Lucene-inspired subset: compact field predicates + boolean composition now, with a clear syntax-compatible path to add more Lucene-style capabilities in later versions.

### Filter expression language

**Principles:**
- Plain text typed after `/` works exactly as before (searches description)
- Power users can add field predicates and boolean operators
- Uppercase `AND`, `OR`, `NOT` are operators; lowercase versions are search text
- Must be fast to type in a single line
- Syntax is a deliberate subset baseline (not full Lucene), chosen to keep v0.4 approachable while preserving forward compatibility for future expansion

**Grammar:**

```
expr     = or_expr
or_expr  = and_expr ( 'OR' and_expr )*
and_expr = unary ( ('AND' unary) | unary )*  // adjacent unary terms imply AND
unary    = 'NOT' unary | term
term     = '(' expr ')' | field_pred | text_search

field_pred  = field ':' value
text_search = word+                      // implicit desc:contains

field = 'desc' | 'cat' | 'tag' | 'acc'
      | 'amt'  | 'type' | 'note' | 'date'

value = comparison | number_range | date_range | date_value | quoted_string | word+
comparison  = ('<' | '>' | '<=' | '>=' | '=') number
number_range = number '..' number
number      = [+-]? ( [0-9]+ ('.' [0-9]+)? | '.' [0-9]+ )
date_range  = date_value '..' date_value
date_value  = iso_day | iso_month | yy_month
iso_day     = YYYY '-' MM '-' DD
iso_month   = YYYY '-' MM
yy_month    = YY '-' MM              // maps to 20YY-MM (e.g. 26-03 => 2026-03)
quoted_string = '"' ( '\\"' | '\\\\' | [^"] )* '"'
```

**Operator precedence:** `(` `)` > `NOT` > `AND` > `OR` (standard).

**Lexical rules:**
- `word` = run of non-whitespace characters excluding reserved delimiters/operators (`(`, `)`, `:`, `"`)
- Whitespace delimits tokens; one or more spaces are equivalent
- Adjacent terms/predicates imply `AND` (e.g. `cat:Food amt:>50`)
- Uppercase `AND`/`OR`/`NOT` are operators; lowercase forms are plain text
- `number` supports signed integer/decimal forms (e.g. `-10`, `25`, `25.50`, `0.5`, `.5`)

**Field predicates:**

| Field | Shorthand | Match behavior | Examples |
|---|---|---|---|
| `desc` | (default) | Contains, case-insensitive | `coffee`, `desc:"coffee shop"` |
| `cat` | `cat:` | Exact category name, case-insensitive | `cat:Food`, `cat:"Dining & Drinks"` |
| `tag` | `tag:` | Has tag with name, case-insensitive | `tag:Groceries`, `tag:IGNORE` |
| `acc` | `acc:` | Account name, case-insensitive | `acc:"ANZ Savings"` |
| `amt` | `amt:` | Inclusive signed comparison/range | `amt:>50`, `amt:-100..-10`, `amt:=25.50` |
| `type` | `type:` | Transaction type | `type:debit`, `type:credit` |
| `note` | `note:` | Notes contains, case-insensitive | `note:refund` |
| `date` | `date:` | Exact day (`YYYY-MM-DD`), whole-month shorthand (`YYYY-MM` or `YY-MM`), or inclusive range | `date:2025-03-15`, `date:2025-03`, `date:26-03`, `date:2025-01..2025-06` |

**Type inference for `type:` field:** `type:debit` matches `amount < 0`; `type:credit` matches `amount > 0`.

**Examples:**

```
coffee                              → desc contains "coffee"
coffee AND tea                      → desc contains "coffee" AND desc contains "tea"
coffee tea                          → desc contains "coffee" AND desc contains "tea" (implicit AND)
cat:Food                            → category is "Food"
cat:Food AND amt:>50                → category Food AND amount > 50
cat:Food amt:>50                    → category Food AND amount > 50 (implicit AND)
NOT cat:Food                        → category is NOT Food
cat:Food OR cat:Transport           → category is Food or Transport
(cat:Food OR cat:Transport) AND amt:>50  → grouped OR branch, then amount constraint
tag:Groceries AND type:debit        → has tag Groceries AND is a debit
desc:"coffee shop" AND cat:Food     → description contains "coffee shop" AND category Food
```

### AST representation

**New file: `filter.go`**

```go
type filterNodeKind int
const (
    filterNodeText filterNodeKind = iota
    filterNodeField
    filterNodeAnd
    filterNodeOr
    filterNodeNot
)

type filterNode struct {
    kind     filterNodeKind
    // Text/Field
    field    string      // "" for text search, "desc"/"cat"/etc. for field
    op       string      // "contains", "=", ">", "<", ">=", "<=", ".."
    value    string      // the raw value string
    valueLo  string      // for range: low bound
    valueHi  string      // for range: high bound
    // Boolean
    children []*filterNode // And/Or: 2+ children; Not: 1 child
}

func parseFilter(input string) (*filterNode, error)
func evalFilter(node *filterNode, t transaction, tags []tag) bool
func filterExprString(node *filterNode) string  // serialize back to text
```

`parseFilter` returns `nil` for empty input (matches everything).

Date parse semantics:
- `date:YYYY-MM-DD` is exact-day match
- `date:YYYY-MM` is full-month match (first day through last day of month)
- `date:YY-MM` is allowed and maps to `20YY-MM` with the same full-month behavior
- `date:start..end` is inclusive on both ends; each endpoint may be day or month shorthand

Parse policy is caller-owned:
- `parseFilterStrict(input)` is strict and returns errors for invalid token/shape or strict mixed-precedence ambiguity.
- `parseFilter(input)` parses the same grammar and may return parse errors; it does not perform fallback internally.
- Interactive `/` input remains **permissive** because the transaction filter input path catches parse errors and falls back to a plain-text `desc contains` node built from the raw input.
- Persisted and mutation-driving contexts are **strict**: no fallback. Invalid expressions are blocked with actionable errors.

```go
func parseFilter(input string) (*filterNode, error)         // permissive caller policy
func parseFilterStrict(input string) (*filterNode, error)   // error on invalid token/shape or strict mixed-precedence ambiguity
```

Strict contexts in v0.4:
- Rules v2 editor (Phase 3)
- Spending target editor (Phase 5)
- Saved filter creation/update (only valid filters can be persisted)
- Dashboard custom view creation/update + config load validation (Phase 6)

**Strict complexity policy (v0.4):**
- Parentheses are optional in permissive `/` input.
- In strict contexts, expressions that mix `AND` and `OR` at the same precedence layer must include explicit grouping parentheses.
- Example strict-invalid: `cat:Food OR cat:Transport AND amt:>50`
- Example strict-valid: `(cat:Food OR cat:Transport) AND amt:>50`
- Strict parse errors include an actionable fix hint (grouped rewrite suggestion).

**Extension path (post-v0.4):**
- Treat this grammar as the stable core and extend with additional Lucene-like features only as needed (e.g. wildcard/prefix terms, fuzzy matching, proximity, boosts, unary `+`/`-` required/prohibited terms).
- Maintain backward compatibility for existing saved/rule/target expressions; new features must be additive and strict-parse validated.

### Integration with existing filter pipeline

Replace `filteredRows` signature:

```go
func filteredRows(rows []transaction, filter *filterNode, txnTags map[int][]tag, sortCol int, sortAsc bool) []transaction
```

The old `searchQuery string`, `filterCats map[int]bool`, `filterAccounts map[int]bool` parameters are replaced by a single `*filterNode`.

```go
// Transactions table: user input + account scope
func (m model) buildTransactionFilter() *filterNode

// Dashboard defaults: timeframe + account scope only (no transaction/saved filter state)
func (m model) buildDashboardScopeFilter() *filterNode

// Custom mode filter: returns the strict-parsed filter for a custom pane mode (nil for curated modes with no expression)
func (m model) buildCustomModeFilter(paneID, modeName string) *filterNode
```

`buildTransactionFilter()` composes:
1. User search/filter input (parsed from the `/` input line)
2. Account scope from `m.filterAccounts` (if set, injected as quoted/escaped account predicates: `acc:"Name 1" OR acc:"Name 2"`)

`buildDashboardScopeFilter()` composes:
1. Dashboard timeframe range
2. Account scope from `m.filterAccounts`

Dashboard default widgets **must not** inherit transaction filter input or active saved-filter state.

Composition contract:
- Internal filter composition is AST-first (`filterNodeAnd` / `filterNodeOr`), never raw string concatenation.
- Any persisted expression text is produced from AST serialization and must round-trip through strict parse.

### Strict filter builder surfaces

Rules, spending targets, and dashboard custom views use a strict builder surface. The builder supports grouped logic via structured ALL/ANY rules and emits precedence-safe expressions in the same v0.4 filter language (including parentheses when needed). Builder output is validated with `parseFilterStrict`, and save is blocked on invalid input.

Strict contexts must never fallback to plain-text matching. They always show parse errors inline and block persistence until resolved.
Persisted strict expressions are canonicalized on save/load round-trip: uppercase boolean operators plus minimal parentheses needed to preserve AST semantics.

### Parser edge-case contract (must be covered)

| Case | Input | Expected |
|---|---|---|
| Operator case-sensitivity | `coffee and tea` | Treated as plain text search terms (no boolean op) |
| Implicit AND (text) | `coffee tea` | Parsed as `coffee AND tea` |
| Implicit AND (predicates) | `cat:Food amt:>50` | Parsed as `cat:Food AND amt:>50` |
| Unary precedence | `NOT cat:Food AND tag:Work` | Parsed as `(NOT cat:Food) AND tag:Work` |
| Parenthesized grouping | `(cat:Food OR cat:Transport) AND amt:>50` | OR branch grouped before AND |
| Missing grouping in strict mode | `cat:Food OR cat:Transport AND amt:>50` | Strict parse error with grouped rewrite suggestion |
| Quoted values | `desc:"coffee shop"` | Phrase match on exact token string (case-insensitive) |
| Quoted account injection | `acc:"ANZ Savings"` | Exact account-name match after unescape |
| Single day date | `date:2025-03-15` | Matches only transactions on 2025-03-15 |
| Month shorthand date | `date:2025-03` | Expands to full month (2025-03-01..2025-03-31) |
| Two-digit month shorthand | `date:26-03` | Expands to full month (2026-03-01..2026-03-31) |
| Date range month endpoints | `date:2025-01..2025-03` | Inclusive range 2025-01-01..2025-03-31 |
| Invalid token (strict) | `cat:` | Parse error; save blocked in strict contexts |
| Invalid token (permissive `/`) | `cat:` | Fallback to plain text search for `cat:` |

### Saved filters

**Config file: `~/.config/jaskmoney/formats.toml`** (extended)

```toml
[[saved_filter]]
name = "Groceries this month"
expr = "cat:Groceries AND date:2025-01..2025-01"

[[saved_filter]]
name = "Large debits"
expr = "type:debit AND amt:<-100"
```

Saved filters are loaded alongside CSV formats in `config.go`.
At load time, each `saved_filter.expr` is strict-parsed. Invalid entries are skipped with an actionable warning while app startup continues.

```go
type savedFilter struct {
    Name string `toml:"name"`
    Expr string `toml:"expr"`
}
```

```go
// Custom dashboard mode: appears as an additional mode slot in the pane's
// mode cycle list (after all curated built-in modes). Inherits the chart
// primitive from the pane but filters data through `expr`.
type customPaneMode struct {
    Pane     string `toml:"pane"`      // pane ID, e.g. "net_cashflow"
    Name     string `toml:"name"`      // display label, e.g. "Renovation Spend"
    Expr     string `toml:"expr"`      // strict filter expression
    ViewType string `toml:"view_type"` // optional: "line"|"area"|"bar"|"pie"|"table"; defaults to pane's primary chart type
}
```

Custom pane modes are stored in `[[dashboard_view]]` blocks in `formats.toml` and appear alongside built-in modes in the `[`/`]` cycle. They are validated at load time:
- `expr` must strict-parse with `parseFilterStrict`
- `pane` must match a known pane ID
- `view_type` (if provided) must be one of `line|area|bar|pie|table`

Invalid entries are rejected individually with actionable startup warnings; startup continues and other valid entries still load.

### New model fields

```go
// Filter state
filterInput      string            // raw text in the / input line
filterExpr       *filterNode       // parsed filter (nil = show all)
savedFilters     []savedFilter
customPaneModes  []customPaneMode  // loaded from config; appended to pane mode lists in Phase 6
```

Remove: `filterCategories map[int]bool` (now expressed as filter predicates). Keep `filterAccounts` on the model for Manager scope (composed into filter at build time).

### Saved filter commands

Each saved filter is registered as a command at startup:

| ID | Label | Category |
|---|---|---|
| `filter:saved:0` | Apply: "Groceries this month" | Filters |
| `filter:saved:1` | Apply: "Large debits" | Filters |

Executing a saved filter command sets `filterInput` to the saved expression and re-parses.

### UI changes

- `/` opens filter input (same key as current search)
- Input line shows in footer with live-parsed indicator: green dot = valid, red dot = parse error
- Active filter shown as a compact pill in the transaction table header: `[cat:Food AND amt:>50]`
- `Esc` clears filter input and resets to no filter
- `f` shortcut removed (was category filter); replaced by typing `cat:Name` in filter input

### Commands

| ID | Label | Scopes |
|---|---|---|
| `filter:open` | Open Filter | transactions |
| `filter:clear` | Clear All Filters | transactions |
| `filter:save` | Save Current Filter | transactions |
| `filter:load` | Load Saved Filter | transactions |

### Files changed

- **New:** `filter.go` — AST, parser, evaluator, serializer
- `app.go` — new model fields, `buildTransactionFilter()`, `buildDashboardScopeFilter()`, updated `filteredRows` signature
- `config.go` — `savedFilter` + `customPaneMode` types, load/save, strict validation at load (invalid saved filters skipped with warning; invalid custom modes rejected)
- `update_transactions.go` — new filter input mode replacing search + category filter
- `render.go` — filter pill in header, input indicator
- `commands.go` — filter commands + dynamic saved filter commands
- `keys.go` — remove `actionFilterCategory`, update `actionSearch` to `filter:open`

### Tests

- `filter_test.go` — parser: plain text, field predicates, implicit AND adjacency, parentheses grouping, AND/OR/NOT, ranges, quoted strings, error fallback to text search. Evaluator: all field types, boolean combinations, edge cases (nil category, nil account, empty tags).
- `config_test.go` — saved filter load/save round-trip; invalid saved filters skipped with warning; custom pane mode load with strict validation (invalid expr rejected)
- `app_test.go` / `update_mode_test.go` — filter input opens, parses, filters rows, Esc clears, saved filter apply
- `model_test.go` — rules/targets/saved-filter editors reject invalid expressions (strict mode)
- `filter_test.go` — strict parser never falls back to text for invalid expressions; strict mixed `AND`/`OR` without grouping is rejected with actionable hint; serializer emits canonical uppercase ops + minimal required parentheses

### Acceptance

- [ ] `/` opens filter input; plain text works identically to current search
- [ ] Field predicates filter correctly: `cat:`, `tag:`, `acc:`, `amt:`, `type:`, `note:`, `date:`
- [ ] Parentheses grouping parses/evaluates correctly (including nested groups)
- [ ] Adjacent terms/predicates imply `AND` (fast typing path)
- [ ] `AND`, `OR`, `NOT` (uppercase) combine predicates; lowercase treated as text
- [ ] Active filter shown as pill in table header
- [ ] Saved filters persist in config and appear as commands in palette
- [ ] Invalid saved filters in config are skipped at startup with actionable warnings (startup continues)
- [ ] `/` remains permissive on parse errors; rules/targets/saved-filter persistence is strict
- [ ] Strict contexts never fallback to text matching; invalid expressions are blocked with actionable errors
- [ ] Strict contexts reject mixed `AND`/`OR` without explicit grouping parentheses, with actionable rewrite hints
- [ ] `f` shortcut removed; category filtering via `cat:Name` in filter input
- [ ] Account scope from Manager still works (composed into filter)
- [ ] Dashboard defaults use timeframe + account scope only; transaction/saved filter state does not alter default dashboard metrics
- [ ] Custom pane modes load from `[[dashboard_view]]` config; invalid expressions rejected at load time with errors
- [ ] Persisted strict expressions round-trip through canonical serialization (uppercase ops + minimal required parentheses)
- [ ] All existing search behavior preserved (backward compatible)
- [ ] Filter remains responsive while typing (`/` parse + apply <100ms p95 on 10k transactions in harnessed tests)

---

## Phase 3: Rules Engine v2 (v0.33)

**Goal:** Replace v1 category_rules + tag_rules with a unified rules system. Rules use filter expressions as matchers, can set category and/or add/remove tags, support manual ordering and enable/disable, and offer dry-run preview.

### Schema changes (part of v4 → v5 migration)

```sql
-- Drop v1 rules (fresh start; users rebuild)
DROP TABLE IF EXISTS category_rules;
DROP TABLE IF EXISTS tag_rules;

CREATE TABLE rules_v2 (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    name            TEXT NOT NULL,
    filter_expr     TEXT NOT NULL,
    set_category_id INTEGER REFERENCES categories(id) ON DELETE SET NULL,
    add_tag_ids     TEXT NOT NULL DEFAULT '[]',    -- JSON array of tag IDs
    remove_tag_ids  TEXT NOT NULL DEFAULT '[]',    -- JSON array of tag IDs
    sort_order      INTEGER NOT NULL DEFAULT 0,
    enabled         INTEGER NOT NULL DEFAULT 1,
    created_at      TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_rules_v2_sort ON rules_v2(sort_order);
```

**Design notes:**
- `filter_expr` stores the serialized filter expression (same language as Phase 2)
- `set_category_id` is nullable: if NULL, the rule does not change category
- `add_tag_ids` / `remove_tag_ids` are JSON arrays of tag IDs (Go `[]int` serialized)
- `sort_order` determines manual ordering; lower = evaluated first
- `enabled = 0` means the rule is skipped everywhere (apply + dry-run) but shown in Settings list as dimmed

### Go types

```go
type ruleV2 struct {
    id            int
    name          string
    filterExpr    string       // raw expression text
    parsedFilter  *filterNode  // parsed at load time
    setCategoryID *int
    addTagIDs     []int
    removeTagIDs  []int
    sortOrder     int
    enabled       bool
}
```

### Rule application semantics

**All matching rules apply in list order (sort_order ascending):**

1. Iterate rules in order
2. For each enabled rule, evaluate `parsedFilter` against the transaction
3. If matched:
   - If `set_category_id != nil`, set the transaction's category (last writer wins)
   - If `add_tag_ids` is non-empty, add those tags (accumulative)
   - If `remove_tag_ids` is non-empty, remove those tags (accumulative)
4. After all rules, write final category + tags to DB

`rules:apply` executes inside one DB transaction for the full target set. If any write/validation fails, the full apply run rolls back (no partial category/tag updates).

Tag conflict policy:
- Rule effects are applied strictly in `sort_order`.
- If the same tag is both added and removed across matched rules, the final tag state is determined by the last matching operation in order.

**Target set and scope (explicit):**
- Rule matching semantics remain broad: rules can match categorized and uncategorized transactions.
- `rules:apply` resolves scope from `m.filterAccounts` regardless of active tab: non-empty map = scoped run; empty map = all transactions.
- `rules:dry-run` uses the same target set as `rules:apply`.
- Import-time rule application targets **newly imported rows only** for that import operation.

### Dry-run command

Command `rules:dry-run` evaluates all enabled rules against the current `rules:apply` target set (respecting current account scope) without writing. Output is a modal showing:

```
Dry-Run Results
═══════════════

Rule 1: "Grocery stores" (enabled)
  Filter: desc:countdown OR desc:woolworths OR desc:coles
  Matches: 47 transactions
  Actions: → Groceries, +tag:Weekly
  Samples:
    2025-01-15  -$42.50  COUNTDOWN METRO    (currently: Uncategorised)
    2025-01-18  -$87.20  WOOLWORTHS 1234    (currently: Uncategorised)
    2025-01-20  -$23.10  COLES EXPRESS      (currently: Food → Groceries)

Rule 2: "Ignore transfers" (enabled)
  Filter: cat:Transfers
  Matches: 12 transactions
  Actions: +tag:IGNORE
  Samples:
    2025-01-10  -$500.00  TRANSFER TO SAV   (currently: Transfers)
    ...

Summary: 59 transactions would be modified
         23 category changes, 59 tag changes
```

Sample rows capped at 3 per rule. Modal is scrollable.
Dry-run/apply surfaces must show the effective account scope label (`All Accounts` or `N selected accounts`) so scope-sensitive runs are explicit.

### Settings UI

Rules section in Settings is overhauled:

**List view:**
```
Rules
─────
  1. ✓ Grocery stores     desc:countdown OR desc:woolworths → Groceries +Weekly
  2. ✓ Ignore transfers   cat:Transfers → +IGNORE
  3. ✗ Old rent rule      desc:rent AND amt:<-1000 → Bills (disabled)
```

- Checkmark/cross shows enabled state
- Dimmed rendering for disabled rules

**Interactions:**
- `a` — add new rule (opens rule editor)
- `Enter` — edit rule
- `Del` — delete rule (with confirm)
- `e` — toggle enable/disable
- `K` / `J` (shift+k/j) — move rule up/down in order
- `A` — apply all rules
- `D` — dry-run

**Rule editor modal:**

Multi-step inline editor:
1. **Name** — text input
2. **Filter expression** — strict builder/input (live parse indicator from Phase 2; save blocked on invalid expression)
3. **Set category** — optional category picker (fuzzy, or skip with Enter for "no category change")
4. **Add tags** — optional tag picker (multi-select, or skip)
5. **Remove tags** — optional tag picker (multi-select, or skip)
6. **Enabled** — toggle (default: yes)

Navigation: `Tab`/`Shift+Tab` between fields. `Enter` on last field saves. `Esc` cancels.

### Model changes

```go
// Replace old fields
rules    []ruleV2       // was: []categoryRule
// Remove:
// tagRules []tagRule    // absorbed into rules_v2

// Rule editor state
ruleEditorOpen    bool
ruleEditorStep    int      // 0=name, 1=filter, 2=category, 3=addTags, 4=removeTags, 5=enabled
ruleEditorID      int      // 0 = new, >0 = editing
ruleEditorName    string
ruleEditorFilter  string
ruleEditorCatID   *int
ruleEditorAddTags []int
ruleEditorRemTags []int
ruleEditorEnabled bool

// Dry-run state
dryRunOpen    bool
dryRunResults []dryRunRuleResult
dryRunSummary dryRunSummary
dryRunScroll  int
```

```go
type dryRunRuleResult struct {
    rule       ruleV2
    matchCount int
    catChanges int
    tagChanges int
    samples    []dryRunSample // max 3
}

type dryRunSample struct {
    txn         transaction
    currentCat  string
    newCat      string
    addedTags   []string
    removedTags []string
}

type dryRunSummary struct {
    totalModified  int
    totalCatChange int
    totalTagChange int
}
```

### Commands

| ID | Label | Scopes |
|---|---|---|
| `rules:apply` | Apply All Rules | settings, global |
| `rules:dry-run` | Dry-Run Rules | settings, global |

### DB functions

```go
func loadRulesV2(db *sql.DB) ([]ruleV2, error)
func insertRuleV2(db *sql.DB, r ruleV2) (int, error)
func updateRuleV2(db *sql.DB, r ruleV2) error
func deleteRuleV2(db *sql.DB, id int) error
func reorderRuleV2(db *sql.DB, id, newSortOrder int) error
func toggleRuleV2Enabled(db *sql.DB, id int, enabled bool) error
func applyRulesV2ToScope(db *sql.DB, rules []ruleV2, txnTags map[int][]tag, accountFilter map[int]bool) (catChanges, tagChanges int, err error)
func applyRulesV2ToTxnIDs(db *sql.DB, rules []ruleV2, txnTags map[int][]tag, txnIDs []int) (catChanges, tagChanges int, err error)
func dryRunRulesV2(db *sql.DB, rules []ruleV2, rows []transaction, txnTags map[int][]tag) ([]dryRunRuleResult, dryRunSummary)
```

### Import integration

`ingestCmd` now calls `applyRulesV2ToTxnIDs` instead of the old `applyCategoryRules` + `applyTagRules`. Rules are loaded fresh at import time and run only against newly imported row IDs.

### Files changed

- `db.go` — migration v4→v5 (drop old rules, create rules_v2), new CRUD functions
- `ingest.go` — replace old rule application with `applyRulesV2ToScope` / `applyRulesV2ToTxnIDs`
- `app.go` — new model fields for rules state
- `update_settings.go` — rule editor, enable/disable toggle, reorder, dry-run modal
- `render.go` — rule list rendering, rule editor modal, dry-run results modal
- `commands.go` — `rules:apply`, `rules:dry-run`
- `filter.go` — used by rules for matching (no changes, just consumed)

> **Keybinding note:** The rule editor and dry-run modal are modal scopes (`architecture.md` §3.4.2). The rules list view extends `scopeSettingsActiveRules` with new actions (`a` add, `Enter` edit, `Del` delete, `e` toggle, `K`/`J` reorder, `A` apply, `D` dry-run). Uppercase `K`/`J`/`A`/`D` coexist with lowercase `k`/`j`/`a`/`d` in the same scope because case is preserved for single-letter keys in the registry (see key normalization in `keys.go`). Verify these don't shadow global bindings via the shadow audit test.

### Tests

- `db_test.go` — rules_v2 CRUD, ordering, enable/disable, migration preserves other data
- `filter_test.go` — (from Phase 2, reused) filter expressions evaluate correctly against transactions
- `ingest_test.go` — import applies rules_v2 correctly, category + tag actions both fire, imported rows only are touched
- `model_test.go` — rule editor flow, dry-run modal, reorder, toggle enable
- `model_test.go` / `update_settings_test.go` — `rules:apply` and `rules:dry-run` respect current account scope

### Acceptance

- [ ] Rules v1 tables dropped on migration; rules_v2 created
- [ ] All other v0.3 data (transactions, categories, tags, accounts) preserved
- [ ] Rule editor supports: name, filter expression, set category, add/remove tags, enabled toggle
- [ ] Rules apply in manual order; all matching rules fire
- [ ] Last category setter wins; tags accumulate
- [ ] Disabled rules skipped in apply and dry-run
- [ ] `rules:apply` and `rules:dry-run` always resolve scope from `m.filterAccounts`; import applies rules only to newly imported rows
- [ ] Given the same scope and rule set, `rules:dry-run` and `rules:apply` target identical transaction sets
- [ ] Rules Apply and Dry-Run surfaces show effective scope (`All Accounts` or `N selected accounts`)
- [ ] Dry-run shows per-rule counts + up to 3 sample rows + summary totals
- [ ] `K`/`J` reorders rules in Settings
- [ ] Import applies rules_v2 (replaces old rule application)

---

## Phase 4: Import Preview Integration (v0.34)

**Goal:** Replace the minimal dupe modal with a combined preview + decision modal that shows duplicate context before the user chooses.

### Combined import preview modal

When `scanDupesCmd` completes, instead of the current minimal dupe modal, open a combined preview modal:

**Default view (compact):**

```
Import Preview: ANZ-2025-01.csv
═════════════════════════════════

Summary
  Total rows in file:  142
  New transactions:    128
  Duplicates found:     14

Duplicate Rows (14)
───────────────────
  #   Date         Amount    Description
  1   2025-01-05   -$42.50   COUNTDOWN METRO SYDNEY
  2   2025-01-05   -$12.30   UBER *EATS
  3   2025-01-08   -$87.20   WOOLWORTHS 1234
  ...
  (showing 14 of 14 duplicates)

─────────────────────────────────
  [a] Import All (142 rows)    [s] Skip Dupes (128 rows)    [c] Cancel
  [f] Full View
```

- Scrollable duplicate list (display capped to first 100 rows with `+N more not shown` if over 100)
- Navigation: `j`/`k` scrolls the duplicate list
- `a` — import all (force dupes)
- `s` — import skipping dupes
- `c` / `Esc` — cancel
- `f` — toggle to full view

**Full view:**

```
Import Full View: ANZ-2025-01.csv
══════════════════════════════════

  #   Date         Amount    Description            Status     Category (post-rules)
  1   2025-01-03   -$42.50   COUNTDOWN METRO        New        → Groceries
  2   2025-01-03   +$500.00  SALARY DEPOSIT         New        → Income
  3   2025-01-05   -$42.50   COUNTDOWN METRO        DUPE       → Groceries
  4   2025-01-05   -$12.30   UBER *EATS             DUPE       → Dining & Drinks
  ...

  [r] Raw View    [p] Post-Rules View    [Esc] Back to Summary
```

- Full view shows status for displayed rows ("New" / "DUPE")
- `r` — show raw CSV values (no rules applied)
- `p` — show post-rules view (category/tag assignments that would be applied)
- `Esc` — return to compact/summary view
- Scrollable, display capped to first 100 rows with `+N more not shown` indicator

Display policy:
- Preview rendering is capped to the first 100 rows in both compact and full views.
- Scrolling operates within the displayed slice.
- Import decisions (`a`/`s`) always apply to the full parsed file, not only displayed rows.

### Post-rules preview

To show post-rules results, the preview runs a **simulated** rule application:
1. Parse all rows from CSV
2. For each row, create a temporary `transaction` struct
3. Evaluate all enabled rules_v2 against each temporary transaction
4. Display the resulting category and tags in the preview

This is read-only — no DB writes during preview.
Import preview is modal-exclusive while open: rule editing/actions are unavailable until the preview is closed, so preview and confirm always use the same active rule set.

### Model changes

```go
// Import preview state
importPreviewOpen    bool
importPreviewFile    string
importPreviewRows    []importPreviewRow
importPreviewScroll  int
importPreviewTotal   int
importPreviewNewCount int
importPreviewDupeCount int
importPreviewFullView bool       // false = compact (dupes only), true = full view
importPreviewPostRules bool      // false = raw, true = post-rules applied
```

```go
type importPreviewRow struct {
    index       int
    dateRaw     string
    dateISO     string
    amount      float64
    description string
    isDupe      bool
    // Post-rules preview (populated lazily)
    previewCat  string
    previewTags []string
}
```

### Flow change

Old: `scanDupesCmd` → `dupeScanMsg` → open dupe modal (3 lines of info)
New: `scanDupesCmd` → `importPreviewMsg` → open preview modal (full row data)

The `scanDupesCmd` is enhanced to return parsed rows with dupe flags instead of just counts:

```go
type importPreviewMsg struct {
    file     string
    rows     []importPreviewRow
    total    int
    newCount int
    dupeCount int
    err      error
}
```

### Commands

| ID | Label | Scopes |
|---|---|---|
| `import:all` | Import All | import_preview |
| `import:skip-dupes` | Import Skip Dupes | import_preview |
| `import:cancel` | Cancel Import | import_preview |
| `import:full-view` | Toggle Full View | import_preview |
| `import:toggle-rules` | Toggle Rules Preview | import_preview |

### Files changed

- `ingest.go` — enhanced `scanDupesCmd` to return parsed rows with dupe flags; add simulated rule preview function
- `app.go` — new model fields for import preview state
- `update_settings.go` — handle import preview modal (replaces old dupe modal handler)
- `render.go` — `renderImportPreview` (compact + full view rendering)
- `commands.go` — import preview commands
- `keys.go` — new scope `scopeImportPreview` with bindings

> **Keybinding note:** `scopeImportPreview` is a modal scope (see `architecture.md` §3.4.2). It fully blocks all non-modal key handling. Keys `a`/`s`/`c`/`f`/`r`/`p` are safe to bind here without conflicting with any tab or global binding. The dispatch chain in `update.go` must check `importPreviewOpen` before tab-level handlers (insert at the same precedence level as the current `importDupeModal`).

### Tests

- `ingest_test.go` — enhanced scan returns correct rows with dupe flags, post-rules preview correctness, preview/import parity on persisted outcomes for imported rows
- `update_settings_test.go` — while `importPreviewOpen`, rules editor/actions are blocked by modal precedence
- `model_test.go` — preview modal open/close, compact/full view toggle, raw/post-rules toggle, decision execution
- `render_test.go` — preview rendering capped at 100 rows, dupe highlighting

### Acceptance

- [ ] Import flow shows combined preview modal instead of minimal dupe modal
- [ ] Compact view shows summary + scrollable duplicate list
- [ ] `a`/`s`/`c` decisions work as before
- [ ] `f` toggles full view showing all rows with New/DUPE status
- [ ] Full view supports `r`/`p` toggle between raw and post-rules
- [ ] Post-rules preview shows what rules would assign without writing to DB
- [ ] While preview is open, rule edits are blocked; imported rows therefore match post-rules preview outcomes at confirm time
- [ ] Row display capped at 100 with "+N more" indicator
- [ ] Esc from full view returns to compact; Esc from compact cancels import

---

## Phase 5: Budgeting System (v0.35)

**Goal:** Add a Budget tab with monthly category budgets, advanced filter-based spending targets, quarterly/annual periods, and a credit-offset system for refund tracking.

### Schema additions (part of v5 migration)

```sql
-- Primary category budgets (recurring monthly with per-month overrides)
CREATE TABLE category_budgets (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    category_id INTEGER NOT NULL UNIQUE REFERENCES categories(id) ON DELETE CASCADE,
    amount      REAL NOT NULL DEFAULT 0,
    created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE category_budget_overrides (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    budget_id   INTEGER NOT NULL REFERENCES category_budgets(id) ON DELETE CASCADE,
    month_key   TEXT NOT NULL,          -- 'YYYY-MM' e.g. '2025-03'
    amount      REAL NOT NULL,
    UNIQUE(budget_id, month_key)
);

-- Advanced spending targets (filter-based, any period)
CREATE TABLE spending_targets (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    name        TEXT NOT NULL,
    filter_expr TEXT NOT NULL,           -- filter expression (Phase 2 language)
    amount      REAL NOT NULL DEFAULT 0,
    period_type TEXT NOT NULL DEFAULT 'monthly'
                CHECK(period_type IN ('monthly','quarterly','annual')),
    created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE spending_target_overrides (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    target_id   INTEGER NOT NULL REFERENCES spending_targets(id) ON DELETE CASCADE,
    period_key  TEXT NOT NULL,           -- 'YYYY-MM', 'YYYY-Q1', 'YYYY'
    amount      REAL NOT NULL,
    UNIQUE(target_id, period_key)
);

-- Credit offset linking (refund tracking)
CREATE TABLE credit_offsets (
    id             INTEGER PRIMARY KEY AUTOINCREMENT,
    credit_txn_id  INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    debit_txn_id   INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    amount         REAL NOT NULL CHECK(amount > 0),  -- positive: how much of the credit offsets the debit
    created_at     TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK(credit_txn_id != debit_txn_id),
    UNIQUE(credit_txn_id, debit_txn_id)
);
```

### Go types

```go
type categoryBudget struct {
    id         int
    categoryID int
    amount     float64 // recurring monthly default
}

type budgetOverride struct {
    id       int
    budgetID int
    monthKey string  // "2025-03"
    amount   float64
}

type spendingTarget struct {
    id          int
    name        string
    filterExpr  string
    parsedFilter *filterNode
    amount      float64
    periodType  string // "monthly", "quarterly", "annual"
}

type targetOverride struct {
    id        int
    targetID  int
    periodKey string // "2025-03", "2025-Q1", "2025"
    amount    float64
}

type creditOffset struct {
    id          int
    creditTxnID int
    debitTxnID  int
    amount      float64
}

// Computed for display
type budgetLine struct {
    categoryID   int
    categoryName string
    categoryColor string
    budgeted     float64
    spent        float64  // absolute value of debits (positive)
    offsets      float64  // credit offsets reducing spent
    netSpent     float64  // spent - offsets
    remaining    float64  // budgeted - netSpent
    overBudget   bool     // remaining < 0
}

type targetLine struct {
    targetID   int
    name       string
    budgeted   float64
    spent      float64
    offsets    float64
    netSpent   float64
    remaining  float64
    overBudget bool
    periodType string
    periodKey  string
}
```

### Budget calculation

**Category budgets:**

For a given month (`YYYY-MM`):
1. Get effective amount: check `category_budget_overrides` for month; fall back to `category_budgets.amount`
2. Calculate spent: `SUM(ABS(amount)) WHERE amount < 0 AND category_id = ? AND date_iso LIKE 'YYYY-MM%'`
3. Calculate offsets: `SUM(co.amount) FROM credit_offsets co JOIN transactions t ON co.debit_txn_id = t.id WHERE t.category_id = ? AND t.date_iso LIKE 'YYYY-MM%'`
4. Net spent = spent - offsets
5. Remaining = budgeted - net spent
6. Over budget = remaining < 0

**Account scope toggle:**
- Model field `budgetScopeGlobal bool` (default: true = all accounts)
- When false, budget calculations filter by `m.filterAccounts`
- Toggle in Budget tab header
- Budget header must always show the effective scope label (`All Accounts` or `N selected accounts`)

**Category budget row lifecycle:**
- Migration seeds zero rows for existing categories.
- Creating a new category in-app must auto-create `category_budgets(category_id, amount=0)` to preserve the "one budget row per category" invariant.

**Spending targets:**

For a given period:
1. Get period date range from `periodKey` + `periodType`
2. Get effective amount (override or default)
3. Filter all transactions through `parsedFilter` AND date range
4. Sum debits, apply offsets, calculate remaining

Target filter expressions are validated strictly (same strict policy as rules editor). Invalid expressions cannot be saved.

### Tab structure

Add Budget tab. Current order is Manager=0, Dashboard=1, Settings=2. New order inserts Budget and reorders to put Dashboard first:

```go
const (
    tabDashboard = 0
    tabBudget    = 1
    tabManager   = 2
    tabSettings  = 3
    tabCount     = 4
)

var tabNames = []string{"Dashboard", "Budget", "Manager", "Settings"}
```

Number keys updated: `1` = Dashboard, `2` = Budget, `3` = Manager, `4` = Settings.

**Migration note:** This reorders tabs from the v0.3 layout (Manager, Dashboard, Settings). Dashboard moves to position 0 as the default landing tab. The `activeTab` default changes from `tabManager` to `tabDashboard`. Global keybindings `1`/`2`/`3` are remapped and `4` is added.

### Budget tab views

The Budget tab has two views toggled with `w` (switch view):

**Table view (default):**

```
Budget - January 2025                           [All Accounts ▾]  [< Jan >]
═══════════════════════════════════════════════════════════════════

Category Budgets
─────────────────────────────────────────────────────────────────
  Category          Budgeted    Spent    Offsets   Remaining
  ────────          ────────    ─────    ───────   ─────────
  ● Groceries        $500.00   $423.50    $30.00    $106.50
  ● Dining            $200.00   $245.80     $0.00    -$45.80  OVER
  ● Transport         $150.00    $98.20     $0.00     $51.80
  ● Bills             $400.00   $387.00     $0.00     $13.00
  ● Entertainment     $100.00    $67.50     $0.00     $32.50
  ● Shopping          $200.00   $312.40    $50.00    -$62.40  OVER
  ● Health             $50.00    $25.00     $0.00     $25.00
  ────────          ────────    ─────    ───────   ─────────
  Total             $1600.00  $1559.40    $80.00    $120.60

Spending Targets
─────────────────────────────────────────────────────────────────
  Target                  Period      Budgeted    Spent    Remaining
  ──────                  ──────      ────────    ─────    ─────────
  Coffee habit            Monthly      $60.00    $48.50      $11.50
  Annual subscriptions    Annual     $1200.00   $450.00     $750.00
```

Compact analytics strip (always visible at bottom of Budget tab):
1. **Budget adherence %** — percent of categories currently not over budget
2. **Over-budget count** — number of categories with `remaining < 0`
3. **Variance sparkline** — month-by-month aggregate budget variance trend

**Interactions (table view):**
- `j`/`k` — navigate rows
- `Enter` — edit budget amount for focused row (inline edit)
- `o` — add month override for focused row
- `a` — add new spending target
- `d` — delete spending target (category budgets can't be deleted, only zeroed)
- `h`/`l` or `<`/`>` — previous/next month
- `g` — toggle account scope (global vs filtered)
- `w` — switch to planner view

**Planner view:**

```
Budget Planner - 2025                           [All Accounts ▾]
═══════════════════════════════════════════════════════════════════

Category        Jan     Feb     Mar     Apr     May     Jun
────────        ───     ───     ───     ───     ───     ───
Groceries       500     500     500     500     500     500
  spent        (423)   (510)   (390)
  remaining      77     -10     110
Dining          200     200     250*    200     200     200
  spent        (245)   (180)   (210)
  remaining     -45      20      40

* = override (differs from recurring default)
```

**Interactions (planner view):**
- `j`/`k` — navigate categories
- `h`/`l` — navigate months
- `Enter` — edit cell (override amount for that month)
- `r` — reset override (revert to recurring default)
- `w` — switch to table view

### Credit offset flow

Accessed from transaction detail modal or via command:

1. Open detail on a **credit** transaction (amount > 0)
2. Press `o` — "Link Offset"
3. Opens a picker showing **debit** transactions (filtered to same account, similar date range ±30 days)
4. Select a debit transaction
5. Enter offset amount (default: `min(remaining unlinked credit, remaining unlinked debit)`)
6. Saved to `credit_offsets`

### Credit offset integrity rules

`insertCreditOffset` must validate inside one DB transaction:
1. `credit_txn_id` points to a credit transaction (`amount > 0`)
2. `debit_txn_id` points to a debit transaction (`amount < 0`)
3. Both transactions are on the same account
4. New total linked for credit transaction does not exceed available credit amount
5. New total linked for debit transaction does not exceed `ABS(debit amount)`

If any check fails, no writes occur and a descriptive error is returned.

Offset indicator shown in transaction detail:
```
Amount: +$30.00
  └─ Offsets: $30.00 → COUNTDOWN METRO (2025-01-15, -$42.50)
```

### Model changes

```go
// Budget tab state
budgetMonth        string   // "YYYY-MM" currently viewed
budgetYear         int      // for planner view
budgetView         int      // 0 = table, 1 = planner
budgetCursor       int      // row cursor
budgetPlannerCol   int      // month column cursor in planner
budgetScopeGlobal  bool     // true = all accounts
budgetEditing      bool     // inline edit active
budgetEditValue    string   // edit buffer
budgetTargetEditing bool
budgetTargetStep   int      // 0=name, 1=filter, 2=amount, 3=period

// Budget data
categoryBudgets    []categoryBudget
budgetOverrides    map[int][]budgetOverride  // budget_id -> overrides
spendingTargets    []spendingTarget
targetOverrides    map[int][]targetOverride   // target_id -> overrides
creditOffsets      map[int][]creditOffset     // debit_txn_id -> offsets
budgetLines        []budgetLine              // computed for display
targetLines        []targetLine              // computed for display
budgetAdherencePct float64                   // computed KPI for analytics strip
budgetOverCount    int                       // computed KPI for analytics strip
budgetVarSparkline []float64                 // monthly variance series for sparkline

// Credit offset flow
offsetLinking      bool
offsetCreditTxnID  int
offsetDebitPicker  *pickerState
offsetAmount       string
```

### Commands

| ID | Label | Scopes |
|---|---|---|
| `nav:budget` | Go to Budget | global |
| `budget:prev-month` | Previous Month | budget |
| `budget:next-month` | Next Month | budget |
| `budget:toggle-scope` | Toggle Account Scope | budget |
| `budget:toggle-view` | Toggle Table/Planner | budget |
| `budget:edit` | Edit Budget Amount | budget |
| `budget:add-target` | Add Spending Target | budget |
| `budget:delete-target` | Delete Spending Target | budget |
| `txn:link-offset` | Link Credit Offset | detail_modal |

### DB functions

```go
func loadCategoryBudgets(db *sql.DB) ([]categoryBudget, error)
func upsertCategoryBudget(db *sql.DB, categoryID int, amount float64) error
func loadBudgetOverrides(db *sql.DB) (map[int][]budgetOverride, error)
func upsertBudgetOverride(db *sql.DB, budgetID int, monthKey string, amount float64) error
func deleteBudgetOverride(db *sql.DB, budgetID int, monthKey string) error
func loadSpendingTargets(db *sql.DB) ([]spendingTarget, error)
func insertSpendingTarget(db *sql.DB, t spendingTarget) (int, error)
func updateSpendingTarget(db *sql.DB, t spendingTarget) error
func deleteSpendingTarget(db *sql.DB, id int) error
func loadTargetOverrides(db *sql.DB) (map[int][]targetOverride, error)
func upsertTargetOverride(db *sql.DB, targetID int, periodKey string, amount float64) error
func loadCreditOffsets(db *sql.DB) (map[int][]creditOffset, error)
func insertCreditOffset(db *sql.DB, creditTxnID, debitTxnID int, amount float64) error // validated + transactional
func deleteCreditOffset(db *sql.DB, id int) error
func computeBudgetLines(db *sql.DB, budgets []categoryBudget, overrides map[int][]budgetOverride, offsets map[int][]creditOffset, month string, accountFilter map[int]bool, scopeGlobal bool) ([]budgetLine, error)
func computeTargetLines(db *sql.DB, targets []spendingTarget, overrides map[int][]targetOverride, offsets map[int][]creditOffset, txnTags map[int][]tag, accountFilter map[int]bool, scopeGlobal bool) ([]targetLine, error)
```

### Files changed

- **New:** `budget.go` — budget computation logic, period helpers
- **New:** `update_budget.go` — Budget tab key handlers (table view, planner view, inline edit)
- `db.go` — schema v5 with budget tables + credit_offsets, CRUD functions, migration
- `app.go` — new model fields, tab restructure (4 tabs), `Init` loads budget data
- `render.go` — `renderBudgetTable`, `renderBudgetPlanner`, budget tab footer
- `update_detail.go` — credit offset linking flow
- `commands.go` — budget commands
- `keys.go` — new scopes (`scopeBudgetTable`, `scopeBudgetPlanner`, `scopeOffsetPicker`); register Budget tab jump targets (`t` table, `p` planner) with Phase 1 jump infrastructure

> **Keybinding note:** Budget introduces 3-5 new scopes (see `architecture.md` §3.4.10 scope map). `scopeBudgetTable` and `scopeBudgetPlanner` are mutually exclusive tab sub-states (toggled by `w`). `scopeOffsetPicker` and `scopeBudgetTargetEditor` are modal scopes. Keys `j`/`k`/`h`/`l`/`a`/`d`/`o`/`g`/`w`/`Enter`/`Esc` are reused here safely because budget scopes are tab-exclusive with all other tab scopes. `v` is reserved for global jump mode and must not be bound in budget tab scopes. Verify with the global shadow audit test (`architecture.md` §3.4.11).

### Tests

- `db_test.go` — budget CRUD, override upsert/delete, credit offset CRUD, migration from v4
- `budget_test.go` — `computeBudgetLines` correctness (debits only, offset reduction, override priority, multi-month), `computeTargetLines` with filter expressions, quarterly/annual period key resolution
- `model_test.go` — budget tab navigation, inline edit, view toggle, month navigation, scope toggle
- `render_test.go` — budget analytics strip renders adherence card, over-budget count, and variance sparkline
- `update_detail_test.go` — credit offset linking flow
- `db_test.go` / `update_detail_test.go` — credit offset validation failures (wrong sign, cross-account, over-allocation) roll back with no partial writes

### Acceptance

- [ ] Budget tab accessible as 2nd tab (keyboard `2`)
- [ ] Category budgets: one per category, recurring monthly amount with per-month overrides
- [ ] Spending targets: filter-based, supports monthly/quarterly/annual periods
- [ ] Spending target expressions are strict-valid before save
- [ ] Budget calculation: debits only, credit offsets reduce net spent
- [ ] Variance: Remaining = Budgeted - Net Spent; negative = over budget
- [ ] Table view: inline editing, month navigation, spending target CRUD
- [ ] Planner view: multi-month grid with override markers
- [ ] Budget tab shows compact analytics strip: adherence %, over-budget count, variance sparkline
- [ ] Account scope toggle (global vs Manager filter)
- [ ] Budget header shows effective scope (`All Accounts` or `N selected accounts`)
- [ ] Credit offset linking from transaction detail modal
- [ ] Credit offsets enforce sign/account/allocation constraints; invalid attempts perform no writes
- [ ] Zero-seeded defaults for all categories
- [ ] New category creation auto-creates zeroed `category_budgets` row
- [ ] Budget tab registers jump targets (`t` table, `p` planner) with app-wide jump mode; ESC returns to budget table (default)

---

## Phase 6: Dashboard v2 (v0.36+)

**Goal:** Ship a curated 4-pane analytics dashboard with a summary header strip, domain-first pane modes with custom mode slots, drill-down to Manager with return context, and integration with the app-wide jump mode from Phase 1.

### Dashboard visual structure

The dashboard renders top-to-bottom:

1. **Timeframe controls** — chip selector + date range label (carried forward from v0.3)
2. **Summary header strip** — non-focusable KPI row (carried forward from v0.3 Overview)
3. **4-pane analytics grid** — focusable widget panes

The summary header strip is not a widget pane. It is always visible, scoped to dashboard timeframe + account selection, and renders using the same `buildDashboardScopeFilter()` from Phase 2. It preserves the v0.3 KPIs: Balance, Debits, Credits, Transaction count, Uncategorised count + amount.

### Widget primitive

**New file: `widget.go`**

```go
type widgetKind int
const (
    widgetNetCashflow widgetKind = iota
    widgetComposition
    widgetCompareBars
    widgetBudgetHealth
)

type widgetMode struct {
    id        string
    label     string
    viewType  string  // "line" | "area" | "bar" | "pie" | "table"
    filterExpr string // non-empty for custom modes; empty for curated defaults
    custom    bool    // true if loaded from config (custom slot)
}

type widget struct {
    kind       widgetKind
    title      string
    jumpKey    string       // shown in jump overlay (e.g. "n", "c", "b", "h")
    modes      []widgetMode // curated built-in modes + custom modes appended
    activeMode int
    scroll     int
}

func newDashboardWidgets(customModes []customPaneMode) []widget // v0.4 returns 4 panes
```

`newDashboardWidgets` builds the 4 panes with their curated modes, then appends any matching `customPaneMode` entries from config as additional mode slots. Custom modes inherit the pane's primary chart type if `ViewType` is empty.

Extensibility contract:
- `widgetKind` and renderer dispatch are open-ended for future pane additions.
- Domain-first ownership stays stable even if future modes use new chart primitives.

### Canonical 4-pane layout (v0.4)

1. **Net/Cashflow** (`widgetNetCashflow`, jump key: `n`)
2. **Composition** (`widgetComposition`, jump key: `c`)
3. **Compare Bars** (`widgetCompareBars`, jump key: `b`)
4. **Budget Health** (`widgetBudgetHealth`, jump key: `h`)

### Pane mode definitions (domain-first)

Each pane has curated built-in modes. Users cycle through all modes (curated + custom) with `[`/`]`. Timeframe selection is the primary dashboard control; mode cycling is the secondary control for switching analytical perspectives within a pane. There is no dynamic filter input on the dashboard.

**1. Net/Cashflow**
- `net_worth` (line/area): total balance over time (all active accounts)
- `spending` (line/area): debit spend over time (evolution of v0.3 Spending Tracker)
- `burn_runway` (line): burn rate/runway trend
- `savings_rate` (line): savings-rate trend
- *(custom modes appended from config)*

**2. Composition**
- `category_share` (mekko/pie style): category spending composition (evolution of v0.3 Spending by Category)
- `needs_wants_savings` (stacked composition)
- `top_merchants` (bar/pie hybrid)
- `recurring_share` (composition of recurring vs non-recurring)
- *(custom modes appended from config)*

**3. Compare Bars**
- `budget_vs_actual` (bar/column)
- `income_vs_expense` (bar/column)
- `month_over_month` (bar)
- *(custom modes appended from config)*

**4. Budget Health**
- `status` (progress/table): per-category budget utilization
- `variance_trend` (line/bar)
- `over_budget_hotspots` (ranked bar/list)
- *(custom modes appended from config)*

Descriptive labels like "mekko/pie style" and "bar/pie hybrid" are UX descriptions, not new `view_type` values. Each curated mode must map to one canonical renderer type in `viewType` (`line|area|bar|pie|table`) and that mapping must be covered in widget tests.

### Custom mode slots

Custom pane modes (from `[[dashboard_view]]` in `formats.toml`, defined in Phase 2) appear as additional entries in the pane's mode cycle list after all curated built-in modes. They filter data through AST composition of scope and custom expression (`AND` node combining `buildDashboardScopeFilter()` + `buildCustomModeFilter(pane, mode)`), not by string concatenation.

Custom modes show their configured `name` in the mode label (e.g. "Renovation Spend"). Built-in modes show their canonical label (e.g. "Net Worth", "Spending").

Config surface for creating/editing custom modes: `Settings > Dashboard Views` (strict builder UI, same strict validation as rules and spending targets).

### Fixed layout

```
┌─────────────────────────────────────────────────────────────────┐
│  [This Month] [Last Month] [1M] ...    Jan 2025 - Jan 2025     │  timeframe
├─────────────────────────────────────────────────────────────────┤
│  Balance  $616.12   Debits  $87.80   Credits  $703.92   ...    │  summary strip
├───────────────────────────┬─────────────────────────────────────┤
│  Net/Cashflow [n]         │  Composition [c]                    │
│  ▸ Spending               │  ▸ Category Share                   │
│  (braille line chart)     │  (horizontal bar chart)             │
├───────────────────────────┼─────────────────────────────────────┤
│  Compare Bars [b]         │  Budget Health [h]                  │
│  ▸ Income vs Expense      │  ▸ Status                           │
│  (grouped bar chart)      │  (progress bars/table)              │
└───────────────────────────┴─────────────────────────────────────┘
```

2-column, 2-row grid with equal 50:50 column widths. Each pane renders at half the available terminal width. Pane renderers handle their own internal layout within the allocated width.

**Narrow terminal fallback:** When `termWidth < 80`, the 2x2 grid degrades to a 1-column, 4-row vertical stack. Panes render at full width. The dashboard becomes vertically scrollable. Jump mode keys remain the same.

### Focus model

Dashboard focus is a specialization of the app-wide jump mode (Phase 1). The dashboard registers its 4 pane jump targets (`n`/`c`/`b`/`h`) with the global jump infrastructure.

**Dashboard-specific states:**
1. **Unfocused** (default) — all 4 panes visible, none focused, summary strip and timeframe interactive
2. **Focused** — one pane has accent border, mode cycling + scroll + drill-down available

**Focused interactions:**
- `[` / `]` — previous/next mode (cycles through curated + custom modes)
- `j` / `k` — scroll within pane content
- `Enter` — drill-down to Manager
- `Esc` — unfocus (returns to unfocused state per Phase 1 dashboard default)

Entering focus via jump mode (`v` then pane key) or re-entering via `v` again. There is no dashboard-specific focus key; the global `v` is the only entry point.

### Model changes

```go
// Dashboard widget state (Phase 6 additions to global model)
dashWidgets       []widget

// Drill-down return context
drillReturn       *drillReturnState // nil = no return context active
```

Dashboard focus state is managed via the global `focusedSection` field (Phase 1). Dashboard-specific: `focusedSection` values 0-3 map to the 4 panes; -1 = unfocused.

```go
type drillReturnState struct {
    returnTab     int  // tab to return to (tabDashboard)
    focusedWidget int  // which pane was focused (-1 if unfocused)
    activeMode    int  // mode index within the focused pane
    scroll        int  // scroll position within the focused pane
    prevFilterInput string      // Manager filter input before drill
    prevFilterExpr  *filterNode // Manager parsed filter before drill
}
```

### Drill-down with return context

When a user presses `Enter` on a focused pane item:
1. Determine item expression (e.g. `cat:Groceries`, `tag:Recurring`)
2. Compose with active timeframe range (`date:start..end`)
3. Save current dashboard state to `drillReturn`: tab, focused widget, active mode, scroll, and prior Manager filter state (`filterInput`/`filterExpr`)
4. **Replace** `m.filterInput`/`m.filterExpr` with composed expression
5. Switch to Manager tab (transactions view)

**Return behavior:**
- While `drillReturn` is set, ESC from the Manager filter view returns to the dashboard and restores the saved state (focused pane, mode, scroll position)
- On drill-return ESC, restore prior Manager filter state exactly, then clear `drillReturn`
- The filter pill in Manager shows a visual indicator prefix (e.g. `[Dashboard >]`) to signal this is a drill-down context
- Navigating away from Manager by any other means (tab switch, `v` jump, etc.) clears `drillReturn`
- When `drillReturn` is nil (normal Manager usage), ESC from filter clears the filter and stays on Manager, as today

### Analytics scope

Default pane data always uses:
1. Dashboard timeframe (from `buildDashboardScopeFilter()`)
2. Account scope from Manager (`filterAccounts`)

Default dashboard panes do **not** inherit transaction search input or saved-filter state.

When a mode has a filter expression (custom mode):
1. Parse expression via strict parser (already validated at config load)
2. Compose via AST as `AND(buildDashboardScopeFilter(), customModeFilter)`

The summary header strip uses the same `buildDashboardScopeFilter()` as the panes for its KPI calculations.

### Commands

Dashboard focus commands are registered in Phase 6, complementing the Phase 1 jump mode infrastructure:

| ID | Label | Scopes |
|---|---|---|
| `dash:mode-next` | Next Widget Mode | dashboard_focused |
| `dash:mode-prev` | Previous Widget Mode | dashboard_focused |
| `dash:drill-down` | Drill Down | dashboard_focused |

Note: `dash:focus-mode` and `dash:unfocus` are replaced by the global `jump:activate` and `jump:cancel` from Phase 1. Dashboard pane targets are registered with the jump infrastructure in this phase.

### Files changed

- **New:** `widget.go` — 4-pane domain-first widget definitions, mode metadata, custom mode appending from config
- `app.go` — dashboard scope builder usage, widget state updates, `drillReturnState` type + field, summary header strip rendering
- `update_dashboard.go` — focused pane interactions (mode cycling, scroll, drill-down), drill-return context management; jump mode targets registered with Phase 1 infrastructure
- `update_transactions.go` — drill-return ESC handling (return to dashboard when `drillReturn` is set)
- `update_settings.go` — Dashboard Views config editor (strict builder for custom pane modes)
- `render.go` — 2x2 dashboard grid renderer, per-domain mode renderers, summary header strip, narrow terminal fallback, drill-return prefix in filter pill
- `commands.go` — dashboard mode/drill commands
- `keys.go` — `scopeDashboardFocused` scope with mode cycling + drill-down bindings; dashboard pane jump targets registered with global jump infrastructure
- `config.go` — `customPaneMode` load/save + validation (type defined in Phase 2; dashboard-specific loading logic here)

> **Keybinding note:** `scopeDashboardFocused` is a new tab sub-state (see `architecture.md` §3.4.10). It is mutually exclusive with `scopeDashboard` (unfocused), `scopeDashboardTimeframe`, and `scopeDashboardCustomInput`. Keys `[`/`]`/`j`/`k`/`Enter`/`Esc` are bound here. `[`/`]` are unique to this scope (mode cycling); `j`/`k` shadow the global `down`/`up` — this is intentional per the shadow policy (§3.4.4) since they mean "scroll within pane" which is semantically compatible with cursor movement. `footerBindings()` must switch to `scopeDashboardFocused` bindings when `focusedSection >= 0` on the dashboard tab.

### Tests

- `widget_test.go` — pane initialization, mode bounds, custom mode appending, extensibility invariants
- `widget_test.go` — custom mode with empty `ViewType` inherits pane's primary chart type
- `render_test.go` — 2x2 layout dimensions at various terminal widths; narrow fallback triggers below 80 cols; focus state rendering (accent border)
- `render_test.go` — summary header strip renders all KPIs scoped to timeframe + accounts
- `update_dashboard_test.go` — focus via jump mode, mode cycling wraps around (curated + custom), scroll within pane, ESC unfocuses
- `update_dashboard_test.go` — drill-down composes correct expression with timeframe bounds, switches to Manager, sets `drillReturn`
- `update_dashboard_test.go` — drill-return: ESC in Manager returns to dashboard with restored pane/mode/scroll; tab-switch clears `drillReturn`
- `dashboard_test.go` — default scope uses timeframe+accounts only (not transaction/saved filters)
- `dashboard_test.go` — custom mode filter composes via AST-equivalent of `dashboard_scope AND custom_expr` (no string-concat precedence bugs)
- `config_test.go` — custom pane mode entries strict-validate and load from formats.toml; invalid expr entries rejected

### Acceptance

- [ ] Dashboard renders summary header strip (non-focusable) + 4 curated panes in a 2x2 grid
- [ ] Summary header strip shows Balance, Debits, Credits, Txn count, Uncat count scoped to timeframe + accounts
- [ ] Timeframe chips and Manager account selection scope all default pane metrics and summary strip
- [ ] Default pane metrics are unaffected by transaction filter input/saved filter state
- [ ] `v` (global jump mode) with keys `n`/`c`/`b`/`h` focuses dashboard panes
- [ ] Focused pane supports `[`/`]` mode cycling (curated + custom modes) and `j`/`k` scrolling
- [ ] Custom modes from config appear after curated modes in the cycle; their labels show the configured name
- [ ] Drill-down (`Enter`) composes filter expression with timeframe, switches to Manager, sets return context
- [ ] ESC from drill-down Manager view returns to dashboard with restored pane/mode/scroll state
- [ ] Tab-switch or other navigation away from Manager clears drill-return context
- [ ] Manager filter pill shows `[Dashboard >]` prefix during drill-down context
- [ ] Custom mode filters compose via AST-equivalent `dashboard_scope AND custom_expr` semantics
- [ ] Narrow terminal (< 80 cols): panes stack vertically in 1-column layout
- [ ] Architecture supports adding panes/modes without redesigning renderer dispatch

---

## Phase Summary & Dependencies

```
Phase 1: Command System Overhaul + Jump Mode (v0.31)
    │
    ├── Phase 2: Filter System (v0.32)
    │       │
    │       ├── Phase 3: Rules Engine v2 (v0.33)   [needs Phase 2 filter language]
    │       │       │
    │       │       └── Phase 4: Import Preview (v0.34)  [needs Phase 3 rules for post-rules preview]
    │       │
    │       └── Phase 5: Budgeting System (v0.35)   [needs Phase 2 for target filters]
    │               │
    │               └── Phase 6: Dashboard v2 (v0.36+)  [needs Phase 1 jump mode + Phase 2 + Phase 5]
    │
    └── (Phase 2 also needs Phase 1 for command-based filter actions)
```

**Critical path:** Phase 1 → Phase 2 → Phase 3 → Phase 4 (serial).
**Parallel after Phase 2:** Phase 3 and Phase 5 can proceed in parallel once Phase 2 lands. Checkpoint tags may interleave across these streams only when dependency gates are satisfied and each checkpoint remains user-stable.
**Phase 6 requires:** Phase 1 (jump mode infrastructure for pane focus), Phase 2 (filter infra + strict parser + custom mode types), and Phase 5 (budget data for Budget Health pane).
**Phase 1 ships jump mode infrastructure** with Manager + Settings targets. Dashboard and Budget targets are registered in Phase 6 and Phase 5 respectively.
**Migration timing:** schema v5 migration ships with the first checkpoint that includes Phase 3 or Phase 5 DB changes (preferred: v0.33.x). Budget tables may exist before Budget UI is enabled; checkpoint notes must state this explicitly.

---

## Release Train, Tag Granularity, and Stability Gates

v0.4 scope is intentionally ambitious and is not reduced. Delivery is decomposed into smaller stable checkpoints.

**Version model:**
- Phase labels (`v0.31`, `v0.32`, `v0.33`, `v0.34`, `v0.35`, `v0.36+`) are **phase anchors**, not the only shippable tags.
- Stable checkpoint tags use patch suffixes: `v0.31.x`, `v0.32.x`, `v0.33.x`, `v0.34.x`, `v0.35.x`, `v0.36.x`, `v0.37.x`, `v0.38.x` as needed.
- `v0.39` is reserved for stringent user testing and hardening before final acceptance.
- `v0.4` is the final acceptance release.

**Checkpoint intent:**
- Checkpoints are additive and must not reduce phase ambition or remove planned v0.4 outcomes.
- Each checkpoint must be validatable and relatively bug-free for existing users, even if not feature-complete for final v0.4.
- DB-affecting checkpoints must include migration/idempotency notes in release notes.

**Suggested checkpoint allocation (guidance):**
- `v0.31.x`: command routing foundation, jump infrastructure, scope conflict tests.
- `v0.32.x`: filter parser/evaluator, strict/permissive behavior, saved filters/config validation.
- `v0.33.x`: rules_v2 schema + CRUD + dry-run/apply + editor stabilization.
- `v0.34.x`: import preview + post-rules parity.
- `v0.35.x`: budgeting schema, compute paths, offset integrity, budget views.
- `v0.36.x`–`v0.38.x`: dashboard widget/mode system, drill-return lifecycle, layout polish.
- `v0.39`: UAT, regression closure, performance tuning, release docs.

---

## Schema v5 Migration Plan

Migration from schema v4 to v5 in a single `migrateFromV4ToV5(db)`:

```sql
-- 1. Drop v1 rules (fresh start)
DROP TABLE IF EXISTS category_rules;
DROP TABLE IF EXISTS tag_rules;

-- 2. Create rules_v2
CREATE TABLE rules_v2 ( ... );  -- as specified in Phase 3

-- 3. Create budget tables
CREATE TABLE category_budgets ( ... );       -- Phase 5
CREATE TABLE category_budget_overrides ( ... );
CREATE TABLE spending_targets ( ... );
CREATE TABLE spending_target_overrides ( ... );
CREATE TABLE credit_offsets ( ... CHECK(amount > 0) ... CHECK(credit_txn_id != debit_txn_id) ... );

-- 4. Seed zero budgets for existing categories
INSERT INTO category_budgets (category_id, amount)
SELECT c.id, 0
FROM categories c
WHERE NOT EXISTS (
    SELECT 1 FROM category_budgets b WHERE b.category_id = c.id
);

-- 5. Create indexes
CREATE INDEX IF NOT EXISTS idx_rules_v2_sort ON rules_v2(sort_order);
CREATE INDEX IF NOT EXISTS idx_category_budgets_cat ON category_budgets(category_id);
CREATE INDEX IF NOT EXISTS idx_credit_offsets_debit ON credit_offsets(debit_txn_id);
CREATE INDEX IF NOT EXISTS idx_credit_offsets_credit ON credit_offsets(credit_txn_id);

-- 6. Update schema version
UPDATE schema_meta SET version = 5;
```

**Preserved data:** transactions, categories, tags, transaction_tags, accounts, account_selection, imports.
**Dropped data:** category_rules, tag_rules (fresh start for rules v2).
**Behavioral guarantee:** migration must be idempotent and safe if run on partially-upgraded/dev DBs.

Operational safeguards:
- Each create/drop/index statement uses defensive `IF EXISTS`/`IF NOT EXISTS` forms where possible.
- Seed steps are conflict-safe and retry-safe (missing rows inserted, existing rows preserved).
- Migration runs in a transaction; any failure rolls back all schema/data changes.
- `schema_meta.version = 5` is written only after all preceding steps succeed.
- Migration function tolerates partially-upgraded dev DBs (missing old tables, already-created new tables, partially-created indexes).

Migration test matrix:
- Fresh database bootstrap to v5.
- Existing v4 production-shaped DB migration to v5.
- Partially-upgraded DB fixture migration retry to v5 (idempotency path).

---

## File Organization

### New files

| File | Responsibility |
|---|---|
| `filter.go` | Filter expression AST, parser, evaluator, serializer |
| `budget.go` | Budget computation logic, period helpers, budget line calculation |
| `widget.go` | Dashboard widget types, mode definitions, constructors |
| `update_budget.go` | Budget tab key handlers (table view + planner view) |

### Modified files

| File | Changes |
|---|---|
| `app.go` | New model fields (filter, rules, budget, widget state); 4-tab structure; `buildTransactionFilter()` + `buildDashboardScopeFilter()` |
| `commands.go` | Expanded registry (~30+ commands); `ExecuteByID`; scope-aware lookup |
| `keys.go` | `Binding.CommandID`; new scopes for budget, import preview, dashboard focus |
| `db.go` | Schema v5; rules_v2 CRUD; budget CRUD; credit offset CRUD; migration |
| `ingest.go` | Enhanced `scanDupesCmd` (returns rows); `applyRulesV2ToScope`/`applyRulesV2ToTxnIDs`; simulated rule preview |
| `config.go` | `savedFilter` + `customPaneMode` types; load/save/validate; strict expression validation at load |
| `render.go` | Filter pill; rule list/editor/dry-run; import preview; budget views; dashboard grid |
| `update.go` | Command-based dispatch for user-visible actions; jump mode overlay dispatch |
| `update_transactions.go` | Filter input mode; remove category filter shortcut |
| `update_settings.go` | Rules v2 editor; enable/disable; reorder |
| `update_detail.go` | Credit offset linking |
| `update_dashboard.go` | Pane focus interactions; mode cycling; drill-down with return context |
| `update_manager.go` | Minor: command routing |

### Estimated scope

~4,000–5,000 new/modified lines of application code, ~2,000–3,000 lines of tests.

## Config Compatibility

Saved filters remain in `~/.config/jaskmoney/formats.toml` in v0.4.

Example mixed config:

```toml
[[format]]
name = "ANZ"
date_format = "2006-01-02"
date_col = 1
amount_col = 2
description_col = 3

[[saved_filter]]
name = "Groceries this month"
expr = "cat:Groceries AND date:2025-01..2025-01"

[[dashboard_view]]
pane = "net_cashflow"
name = "Renovation Spend"
expr = "tag:Renovation"
```

Compatibility rules:
- Missing `saved_filter` blocks are valid and load as an empty saved-filter list.
- Missing `dashboard_view` blocks are valid and load curated default pane modes.
- Existing format-only configs remain fully compatible.
- Invalid saved filter expressions are rejected in strict save flows and reported with actionable errors.
- Invalid `saved_filter.expr` values found at startup are skipped with warnings (app continues).
- Invalid `dashboard_view.expr` values are rejected by strict parse validation.
- Invalid `dashboard_view.pane` or `dashboard_view.view_type` values are rejected per-entry with actionable warnings (app continues with remaining valid entries).

---

## Verification

For each stable checkpoint tag (e.g. `v0.31.x`):
1. `go build .` succeeds
2. `go vet ./...` clean
3. `go test ./...` all pass
4. Phase-relevant focused tests for changed subsystem pass
5. If DB-affecting: migration idempotency/retry checks pass for that checkpoint
6. Manual smoke test of checkpoint feature set passes
7. Publish checkpoint notes including known limitations and compatibility notes

For hardening release `v0.39`:
- `go test -tags flowheavy ./...` passes
- End-to-end v0.4 flow scenario passes
- Migration matrix passes (fresh bootstrap, v4 upgrade, partial-upgrade retry)
- Performance targets pass for interactive flows (especially filter typing/render responsiveness target from Phase 2)
- UAT feedback issues triaged and release blockers closed

Final `v0.4`:
- Full end-to-end test: create filter expression → save filter → create rule using filter → dry-run → apply rules → import with preview → set budget → view budget table + analytics strip → planner view → configure custom pane mode in Settings → dashboard focus via jump mode → mode cycling through curated + custom → drill-down to Manager → ESC returns to dashboard with restored state → verify prior Manager filter state restored
- All 6 phases complete with tests passing
- Transactional safety checks pass (invalid credit offsets and invalid strict expressions do not produce partial writes)
- `go run . -validate` still works (non-TUI path)
