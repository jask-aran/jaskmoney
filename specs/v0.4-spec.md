# Jaskmoney v0.4 Spec & Implementation Plan

## Table of Contents

- [Context](#context)
  - [Current State (v0.3)](#current-state-v03)
  - [Target State (v0.4)](#target-state-v04)
  - [Data Migration Policy](#data-migration-policy)
  - [Behavioral Breaking Changes from v0.3](#behavioral-breaking-changes-from-v03)
- [Phase 1: Command System Overhaul (v0.31)](#phase-1-command-system-overhaul-v031)
  - [Command struct changes](#command-struct-changes)
  - [KeyRegistry integration](#keyregistry-integration)
  - [New commands to register](#new-commands-to-register)
  - [App-wide jump mode](#app-wide-jump-mode)
  - [Refactoring approach](#refactoring-approach)
  - [Command shape constraints (v0.4)](#command-shape-constraints-v04)
  - [Files changed](#files-changed)
  - [Tests](#tests)
  - [Acceptance](#acceptance)
- [Phase 2: Filter System Overhaul (v0.32)](#phase-2-filter-system-overhaul-v032)
  - [Filter expression language](#filter-expression-language)
  - [AST representation](#ast-representation)
  - [Integration with existing filter pipeline](#integration-with-existing-filter-pipeline)
  - [Strict filter builder surfaces](#strict-filter-builder-surfaces)
  - [Parser edge-case contract](#parser-edge-case-contract-must-be-covered)
  - [Saved filters](#saved-filters)
  - [New model fields](#new-model-fields)
  - [Saved filter commands](#saved-filter-commands)
  - [UI changes](#ui-changes)
  - [Commands](#commands)
  - [Files changed](#files-changed-1)
  - [Tests](#tests-1)
  - [Acceptance](#acceptance-1)
- [Phase 3: Rules Engine v2 (v0.33)](#phase-3-rules-engine-v2-v033)
  - [Schema changes (part of v4 → v5 migration)](#schema-changes-part-of-v4--v5-migration)
  - [Go types](#go-types)
  - [Rule application semantics](#rule-application-semantics)
  - [Dry-run command](#dry-run-command)
  - [Settings UI](#settings-ui)
  - [Model changes](#model-changes)
  - [Commands](#commands-1)
  - [DB functions](#db-functions)
  - [Import integration](#import-integration)
  - [Files changed](#files-changed-2)
  - [Tests](#tests-2)
  - [Acceptance](#acceptance-2)
- [Phase 4: Import Preview Integration (v0.34)](#phase-4-import-preview-integration-v034)
  - [Combined import preview modal](#combined-import-preview-modal)
  - [Post-rules preview](#post-rules-preview)
  - [Model changes](#model-changes-1)
  - [Flow change](#flow-change)
  - [Commands](#commands-2)
  - [Files changed](#files-changed-3)
  - [Tests](#tests-3)
  - [Acceptance](#acceptance-3)
- [Phase 5: Budgeting System (v0.35)](#phase-5-budgeting-system-v035)
  - [Schema Data Baseline (Runtime v6)](#schema-data-baseline-runtime-v6)
  - [Go types](#go-types-1)
  - [Budget calculation](#budget-calculation)
  - [Tab structure](#tab-structure)
  - [Budget tab views](#budget-tab-views)
  - [Offset flow (current)](#offset-flow-current)
  - [Offset integrity rules](#offset-integrity-rules)
  - [Model changes](#model-changes-2)
  - [Commands](#commands-3)
  - [DB functions](#db-functions-1)
  - [Files changed](#files-changed-4)
  - [Tests](#tests-4)
  - [Acceptance](#acceptance-4)
  - [Acceptance Notes (v0.35)](#acceptance-notes-v035)
- [Phase 6: Dashboard v2 (v0.36+)](#phase-6-dashboard-v2-v036)
  - [Dashboard visual structure](#dashboard-visual-structure)
  - [Widget primitive](#widget-primitive)
  - [Canonical 4-pane layout (v0.4)](#canonical-4-pane-layout-v04)
  - [Pane mode definitions (domain-first)](#pane-mode-definitions-domain-first)
  - [Custom mode slots](#custom-mode-slots)
  - [Fixed layout](#fixed-layout)
  - [Focus model](#focus-model)
  - [Model changes](#model-changes-3)
  - [Drill-down with return context](#drill-down-with-return-context)
  - [Analytics scope](#analytics-scope)
  - [Commands](#commands-4)
  - [Files changed](#files-changed-5)
  - [Tests](#tests-5)
  - [Acceptance](#acceptance-5)
- [Phase 7: Interaction Contract Layer (v0.39 hardening)](#phase-7-interaction-contract-layer-v039-hardening)
  - [Interaction intent types](#interaction-intent-types)
  - [Contract type](#contract-type)
  - [Context kinds](#context-kinds)
  - [Contract resolver](#contract-resolver)
  - [Footer rendering migration](#footer-rendering-migration)
  - [Confirm vs Save vs Apply semantics](#confirm-vs-save-vs-apply-semantics)
  - [Model changes](#model-changes-4)
  - [Files changed](#files-changed-6)
  - [Tests](#tests-6)
  - [Acceptance](#acceptance-6)
- [Phase Summary & Dependencies](#phase-summary--dependencies)
- [Release Train, Tag Granularity, and Stability Gates](#release-train-tag-granularity-and-stability-gates)
- [Schema v5 Migration Plan](#schema-v5-migration-plan)
- [File Organization](#file-organization)
  - [New files](#new-files)
  - [Modified files](#modified-files)
  - [Estimated scope](#estimated-scope)
- [Config Compatibility](#config-compatibility)
- [Verification](#verification)

---

## Context

v0.3 delivered accounts, tags, bulk selection, fuzzy pickers, a command palette/colon system, dashboard timeframe chips, and a keybinding registry (~19,500 LOC across 35 files). v0.4 is a major release that overhauls three foundational systems — commands, filtering, and rules — and adds budgeting and a dashboard v2 with focusable widget panes. The goal is to transform jaskmoney from a categorization-focused tracker into a full budgeting and analytics platform.

### Current State (v0.3)

- 3-tab TUI: Manager (accounts + transactions), Dashboard, Settings
- Schema v4: categories, category_rules, tags, tag_rules, transaction_tags, accounts, account_selection, transactions, imports
- Command palette (Ctrl+K) + colon mode (:) with 11 commands
- Keybinding registry with scoped lookups
- Fuzzy picker powering category picker, tag picker, command palette
- Bulk selection with shift-range highlighting
- Dashboard: timeframe chips, summary cards, spending tracker (braille chart), category breakdown
- Filter: text search (`/`), category filter (`f`), account filter (Manager scope)
- Import: file picker → dupe scan → dupe modal (A/S/C) → ingest + rule application

### Target State (v0.4)

- Commands as first-class action primitives for user-visible actions; universal primitives and cursor/input plumbing remain direct handlers
- Unified filter expression language powering search, rules, and advanced budget targets
- Rules v2: ordered, enable/disable, multi-field matching via filter expressions, set category + tags
- Import preview: combined dupe summary modal with optional full-view toggle
- 4-tab TUI: Dashboard, **Budget**, Manager, Settings
- Budget system: category budgets (recurring + overrides), advanced filter-based targets, transaction-allocation-aware spend
- App-wide jump mode (`v`) for spatial navigation across all tabs
- Dashboard v2: summary header strip + 4 curated panes with domain-first modes, custom mode slots from config, and drill-down to Manager with return context

### Data Migration Policy

- **All v0.3 data is preserved** (transactions, categories, tags, accounts, imports)
- **Rules v1 is a fresh start**: `category_rules` and `tag_rules` tables are dropped and replaced by `rules_v2`; users rebuild rules using the new system
- Schema version advances from 4 to 7

### Implementation Delta (February 19, 2026)

- Legacy offset flows (`credit_offsets`, `manual_offsets`, `txn:quick-offset`) were removed in implementation.
- Transaction allocations are now the canonical adjustment model:
  - parent transaction keeps unallocated remainder
  - child allocation rows carry their own category/tags/note
  - Manager table renders child rows indented under parent rows
- Budget and target math now consume allocation-aware effective spend (no offset-table reads).

### Behavioral Breaking Changes from v0.3

- Tab order and number-key mapping changes from `Manager/Dashboard/Settings` (`1`/`2`/`3`) to `Dashboard/Budget/Manager/Settings` (`1`/`2`/`3`/`4`).
- Default landing tab changes from Manager to Dashboard.
- Category filter shortcut (`f`) is removed in favor of unified filter input (`/` with `cat:...` predicates).
- Navigation gains app-wide jump mode (`v`) replacing direct section-focus keys (`nav:focus-accounts`, `nav:focus-transactions`).
- Rules v1 data is intentionally dropped (fresh start for rules v2).

Required regression smoke checklist after rollout:
- Existing users can still navigate to prior core workflows (transactions table, settings import) with remapped keys.
- `v` enters jump mode and shows correct targets for the active tab.
- First launch after migration opens on Dashboard and shows expected account scope label.
- Old v0.3 DB opens without data loss in transactions/categories/tags/accounts/imports.
- Rules lists are empty after migration and rule creation flow works end-to-end.

---

## Phase 1: Command System Overhaul (v0.31)

**Goal:** Make commands the single source of user-visible actions while keeping universal primitives and cursor/input plumbing as direct handlers.

### Command struct changes

```go
type Command struct {
    ID          string
    Label       string
    Description string
    Category    string          // "Navigation", "Actions", "Filter", "Budget", etc.
    Scopes      []string        // scopes where this command is available
    Enabled     func(m model) (bool, string)
    Execute     func(m model) (model, tea.Cmd, error)
}
```

New fields:
- `Scopes []string` — declares which scopes the command is valid in (replaces implicit checks in `Enabled`). Empty = global.

### KeyRegistry integration

`Binding` gains a `CommandID` field:

```go
type Binding struct {
    Action    Action
    CommandID string   // links to Command.ID; empty for legacy/internal-only actions
    Keys      []string
    Help      string
    Scopes    []string
}
```

**Key dispatch flow change:**

Currently: `keyMsg` → scope lookup → `Action` → hand-coded switch in `updateXxx`.

New: `keyMsg` → scope lookup → `Binding.CommandID` → `CommandRegistry.Execute(id, m)` → return `(model, tea.Cmd)`.

For actions that are purely UI-internal (cursor movement, text input), the `CommandID` is empty and the existing switch dispatch is preserved. The principle: **anything that would appear in the command palette is a command; cursor/input plumbing is not**.

> **Architecture alignment:** The dispatch chain, scope hierarchy, key reuse safety rules, and conflict testing contract are enforced in code (`dispatch.go`, `keys.go`, `keys_test.go`). All new scopes and bindings added in v0.4 phases must comply with the scope map and pass key conflict testing invariants. The `keybindings.toml` override format remains action-level flat maps; do not introduce per-scope TOML overrides.

Universal primitives also stay direct handlers and are intentionally not command-routed:
- `confirm` (`enter`)
- `cancel` (`esc`)
- `up` / `down` / `left` / `right`
- `delete`
- `quit`

### New commands to register

All existing keybinding-triggered actions that are user-visible become commands:

| ID | Label | Scopes |
|---|---|---|
| `nav:next-tab` | Next Tab | global |
| `nav:prev-tab` | Previous Tab | global |
| `nav:dashboard` | Go to Dashboard | global |
| `nav:manager` | Go to Manager | global |
| `nav:budget` | Go to Budget | global (registered now, disabled until Phase 5) |
| `nav:settings` | Go to Settings | global |
| `jump:activate` | Jump Mode | global |
| `jump:cancel` | Cancel Jump | jump_overlay |
| `txn:sort` | Cycle Sort Column | transactions |
| `txn:sort-dir` | Toggle Sort Direction | transactions |
| `txn:select` | Toggle Selection | transactions |
| `txn:clear-selection` | Clear Selection | transactions |
| `txn:quick-category` | Quick Categorize | transactions |
| `txn:quick-tag` | Quick Tag | transactions, manager |
| `txn:detail` | Open Detail | transactions |
| `txn:jump-top` | Jump to Top | transactions |
| `txn:jump-bottom` | Jump to Bottom | transactions |
| `filter:open` | Open Filter | transactions (registered now, wired in Phase 2) |
| `filter:clear` | Clear All Filters | transactions |
| `import:start` | Import CSV | settings |
| `rules:apply` | Apply All Rules | settings, global |
| `rules:dry-run` | Dry-Run Rules | settings, global (registered now, wired in Phase 3) |
| `settings:clear-db` | Clear Database | settings |
| `settings:nuke-account` | Nuke Account | settings (**deprecated in v0.32 follow-up; replaced by Manager `del` account-action modal**) |
| `dash:timeframe` | Focus Timeframe | dashboard |
| `dash:mode-next` | Next Widget Mode | dashboard_focused (registered now, wired in Phase 6) |
| `dash:mode-prev` | Previous Widget Mode | dashboard_focused (registered now, wired in Phase 6) |
| `dash:drill-down` | Drill Down | dashboard_focused (registered now, wired in Phase 6) |
| `palette:open` | Command Palette | global |
| `cmd:open` | Command Mode | global |

`txn:search` is removed in v0.4 spec language. `filter:open` is the canonical command ID for `/` filter input.

### App-wide jump mode

**Activation:** `v` enters jump mode globally. An overlay appears with labeled badges at each focusable section in the current tab. Pressing a target key focuses and activates that section and dismisses the overlay. `Esc` cancels jump mode and restores the previously focused widget (or unfocused state).

This replaces the v0.3 `nav:focus-accounts` / `nav:focus-transactions` commands with a spatial, discoverable navigation model inspired by Bagels (`~/bagels-ref/src/bagels/components/jumper.py`).

**Per-tab jump targets and default focus:**

| Tab | Targets | Default focus (ESC returns to) |
|---|---|---|
| Dashboard | `n` Net/Cashflow, `c` Composition, `b` Compare Bars, `h` Budget Health | Unfocused (no pane selected) |
| Manager | `a` Accounts, `t` Transactions | Transactions (default section) |
| Budget | `t` Budget Table, `p` Planner | Budget Table |
| Settings | `c` Categories, `t` Tags, `r` Rules, `f` Filters, `d` Database, `w` Dashboard Views | Stay (no default reset) |

Target keys can overlap across tabs because only targets for the active tab are shown. Dashboard and Budget pane targets are registered in their respective phases (Phase 5 / Phase 6) but the infrastructure ships here.

**Focus lifecycle:**
1. `v` -> jump overlay appears with per-tab targets
2. Press target key -> focus + activation move to that section, overlay dismisses
3. Section-specific interactions available while focused (e.g. mode cycling on dashboard, inline edit on budget)
4. `Esc` -> focus returns to tab's default (or stays, for Settings)
5. `Esc` from default/unfocused state -> no-op

Jump target registration uses a two-axis landing contract (`Section` and
`Activate`) so future tabs can opt into focus-only or focus+activate behavior
per target without changing overlay dispatch.

**Jump overlay visual:**
- Each target shows a floating badge at its top-left corner: `[n]`, `[c]`, `[b]`, `[h]`
- Badges use accent background on muted foreground
- Status bar reads: "Jump: press key to focus. ESC cancel."
- Focused sections get an accent-colored border; unfocused sections use the default muted border

**Model fields:**

```go
// Jump mode (global)
jumpModeActive    bool
jumpPreviousFocus int  // restore target on ESC from jump overlay; -1 = unfocused

// Per-tab focus
focusedSection    int  // -1 = unfocused; meaning is tab-specific
```

**Commands:**

| ID | Label | Scopes |
|---|---|---|
| `jump:activate` | Jump Mode | global |
| `jump:cancel` | Cancel Jump | jump_overlay |

### Refactoring approach

1. Add `CommandID` to `Binding` struct
2. Update `NewKeyRegistry` to set `CommandID` on all action-mapped bindings
3. Add `ExecuteByID(id string, m model) (model, tea.Cmd, error)` to `CommandRegistry`
4. In each `updateXxx` handler, replace action-switch cases with command execution for user-visible actions
5. Keep cursor/input/modal plumbing as direct action switches (no command overhead)
6. Implement jump mode infrastructure: `v` key binding, overlay rendering, per-tab target registration, focus lifecycle

### Command shape constraints (v0.4)

- Commands are **parameterless** in v0.4 (no argument parser yet).
- Registry metadata and IDs should remain future-ready for argument-bearing commands and workflows in v0.5+.

### Files changed

- `keys.go` — `Binding` gains `CommandID`; new `scopeJumpOverlay` scope; `v` binding for `jump:activate`
- `commands.go` — expanded registry, `ExecuteByID`, scope-aware availability; jump commands
- `update.go` — jump mode dispatch (overlay intercept before tab-specific handlers)
- `update_dashboard.go`, `update_transactions.go`, `update_manager.go`, `update_settings.go` — dispatch via command execution for user-visible actions
- `render.go` — `renderJumpOverlay` (badge positioning + status bar)

### Tests

- `commands_test.go` — all commands registered, `ExecuteByID` dispatches correctly, scope filtering works
- `keys_test.go` — every binding with a `CommandID` resolves to a registered command
- `keys_test.go` — global shadow audit, scope reachability, tab/jump key non-shadow
- `update_mode_test.go` — verify key presses still produce correct state changes (regression)
- `update_mode_test.go` — jump mode: `v` activates overlay, target key focuses section, ESC cancels and restores previous focus
- `update_mode_test.go` — per-tab default focus: ESC from focused section returns to tab default (Manager -> transactions, Dashboard -> unfocused, Settings -> stays)

### Acceptance

- [x] All user-visible keybinding actions route through command registry
- [x] Command palette shows all available commands for current scope
- [x] Universal primitives (`confirm`, `cancel`, arrows/`hjkl`, delete, quit) remain direct handlers
- [x] Cursor movement, text input, and modal plumbing remain as direct action handlers
- [x] `v` activates jump mode; per-tab target keys shown as floating badges
- [x] Jump target selection focuses and activates the correct section; ESC cancels and restores previous focus
- [x] Per-tab ESC behavior: Dashboard unfocuses, Manager returns to transactions, Settings stays
- [x] Jump mode infrastructure supports deferred target registration (Dashboard/Budget targets added in later phases)
- [x] Key conflict tests pass: global shadow audit, scope reachability, action-command consistency
- [x] `footerBindings()` correctly reflects active scope for all model states including jump mode and focused sections
- [x] All existing tests pass; no behavior change for end users

#### Acceptance Notes (v0.35)
- **Accepted in `v0.31.1` on February 12, 2026.**
- Command system overhaul is considered complete for v0.31 scope: command routing, scope-aware registry execution, jump mode infrastructure, and command UI (palette + command mode) behavior are validated in tests.
- Post-Phase-1 polish included command UI rendering hardening:
  - command palette modal width expansion and per-command visual spacing
  - colon popup width unbound to viewport-safe available width
  - wrapped command descriptions rendered with explicit continuation lines
- Text-input safety was tightened for command/picker text fields so printable keys (including `j`/`k`) are literal-first while non-printable navigation remains available.
- Transaction table row-state styling regression was fixed before acceptance; cursor, selected, and highlighted states are now visually distinct again, with regression tests covering state-color separation.

---

## Phase 2: Filter System Overhaul (v0.32)

**Goal:** Replace the ad-hoc search + category filter + account filter with a unified filter expression language. The same language powers interactive search, rules (Phase 3), and advanced budget targets (Phase 5).
The v0.4 language is intentionally a Lucene-inspired subset: compact field predicates + boolean composition now, with a clear syntax-compatible path to add more Lucene-style capabilities in later versions.

### Filter expression language

**Principles:**
- Plain text typed after `/` prioritizes typing speed and low-friction querying; explicit field scoping is optional for simple queries
- Power users can add field predicates and boolean operators
- Uppercase `AND`, `OR`, `NOT` are operators; lowercase versions are search text
- Must be fast to type in a single line
- Syntax is a deliberate subset baseline (not full Lucene), chosen to keep v0.4 approachable while preserving forward compatibility for future expansion

**Grammar:**

```
expr     = or_expr
or_expr  = and_expr ( 'OR' and_expr )*
and_expr = unary ( ('AND' unary) | unary )*  // adjacent unary terms imply AND
unary    = 'NOT' unary | term
term     = '(' expr ')' | field_pred | text_search

field_pred  = field ':' value
text_search = word+                      // implicit desc:contains

field = 'desc' | 'cat' | 'tag' | 'acc'
      | 'amt'  | 'type' | 'note' | 'date'

value = comparison | number_range | date_range | date_value | quoted_string | word+
comparison  = ('<' | '>' | '<=' | '>=' | '=') number
number_range = number '..' number
number      = [+-]? ( [0-9]+ ('.' [0-9]+)? | '.' [0-9]+ )
date_range  = date_value '..' date_value
date_value  = iso_day | iso_month | yy_month
iso_day     = YYYY '-' MM '-' DD
iso_month   = YYYY '-' MM
yy_month    = YY '-' MM              // maps to 20YY-MM (e.g. 26-03 => 2026-03)
quoted_string = '"' ( '\\"' | '\\\\' | [^"] )* '"'
```

**Operator precedence:** `(` `)` > `NOT` > `AND` > `OR` (standard).

**Lexical rules:**
- `word` = run of non-whitespace characters excluding reserved delimiters/operators (`(`, `)`, `:`, `"`)
- Whitespace delimits tokens; one or more spaces are equivalent
- Adjacent terms/predicates imply `AND` (e.g. `cat:Food amt:>50`)
- Uppercase `AND`/`OR`/`NOT` are operators; lowercase forms are plain text
- `number` supports signed integer/decimal forms (e.g. `-10`, `25`, `25.50`, `0.5`, `.5`)

**Field predicates:**

| Field | Shorthand | Match behavior | Examples |
|---|---|---|---|
| `desc` | (default) | Contains, case-insensitive | `coffee`, `desc:"coffee shop"` |
| `cat` | `cat:` | Exact category name, case-insensitive | `cat:Food`, `cat:"Dining & Drinks"` |
| `tag` | `tag:` | Has tag with name, case-insensitive | `tag:Groceries`, `tag:IGNORE` |
| `acc` | `acc:` | Account name, case-insensitive | `acc:"ANZ Savings"` |
| `amt` | `amt:` | Inclusive signed comparison/range | `amt:>50`, `amt:-100..-10`, `amt:=25.50` |
| `type` | `type:` | Transaction type | `type:debit`, `type:credit` |
| `note` | `note:` | Notes contains, case-insensitive | `note:refund` |
| `date` | `date:` | Exact day (`YYYY-MM-DD`), whole-month shorthand (`YYYY-MM` or `YY-MM`), or inclusive range | `date:2025-03-15`, `date:2025-03`, `date:26-03`, `date:2025-01..2025-06` |

**Type inference for `type:` field:** `type:debit` matches `amount < 0`; `type:credit` matches `amount > 0`.

**Examples:**

```
coffee                              → desc contains "coffee"
coffee AND tea                      → desc contains "coffee" AND desc contains "tea"
coffee tea                          → desc contains "coffee" AND desc contains "tea" (implicit AND)
cat:Food                            → category is "Food"
cat:Food AND amt:>50                → category Food AND amount > 50
cat:Food amt:>50                    → category Food AND amount > 50 (implicit AND)
NOT cat:Food                        → category is NOT Food
cat:Food OR cat:Transport           → category is Food or Transport
(cat:Food OR cat:Transport) AND amt:>50  → grouped OR branch, then amount constraint
tag:Groceries AND type:debit        → has tag Groceries AND is a debit
desc:"coffee shop" AND cat:Food     → description contains "coffee shop" AND category Food
```

### AST representation

**New file: `filter.go`**

```go
type filterNodeKind int
const (
    filterNodeText filterNodeKind = iota
    filterNodeField
    filterNodeAnd
    filterNodeOr
    filterNodeNot
)

type filterNode struct {
    kind     filterNodeKind
    // Text/Field
    field    string      // "" for text search, "desc"/"cat"/etc. for field
    op       string      // "contains", "=", ">", "<", ">=", "<=", ".."
    value    string      // the raw value string
    valueLo  string      // for range: low bound
    valueHi  string      // for range: high bound
    // Boolean
    children []*filterNode // And/Or: 2+ children; Not: 1 child
}

func parseFilter(input string) (*filterNode, error)
func evalFilter(node *filterNode, t transaction, tags []tag) bool
func filterExprString(node *filterNode) string  // serialize back to text
```

`parseFilter` returns `nil` for empty input (matches everything).

Date parse semantics:
- `date:YYYY-MM-DD` is exact-day match
- `date:YYYY-MM` is full-month match (first day through last day of month)
- `date:YY-MM` is allowed and maps to `20YY-MM` with the same full-month behavior
- `date:start..end` is inclusive on both ends; each endpoint may be day or month shorthand

Parse policy is caller-owned:
- `parseFilterStrict(input)` is strict and returns errors for invalid token/shape or strict mixed-precedence ambiguity.
- `parseFilter(input)` parses the same grammar and may return parse errors; it does not perform fallback internally.
- Interactive `/` input remains **permissive** because the transaction filter input path catches parse errors and falls back to plain-text metadata search while keeping live parse feedback visible (green/red indicator).
- Persisted and mutation-driving contexts are **strict**: no fallback. Invalid expressions are blocked with actionable errors.

```go
func parseFilter(input string) (*filterNode, error)         // permissive caller policy
func parseFilterStrict(input string) (*filterNode, error)   // error on invalid token/shape or strict mixed-precedence ambiguity
```

Strict contexts in v0.4:
- Rules v2 editor (Phase 3)
- Spending target editor (Phase 5)
- Saved filter creation/update (only valid filters can be persisted)
- Dashboard custom view creation/update + config load validation (Phase 6)

**Strict complexity policy (v0.4):**
- Parentheses are optional in permissive `/` input.
- In strict contexts, expressions that mix `AND` and `OR` at the same precedence layer must include explicit grouping parentheses.
- Example strict-invalid: `cat:Food OR cat:Transport AND amt:>50`
- Example strict-valid: `(cat:Food OR cat:Transport) AND amt:>50`
- Strict parse errors include an actionable fix hint (grouped rewrite suggestion).

**Extension path (post-v0.4):**
- Treat this grammar as the stable core and extend with additional Lucene-like features only as needed (e.g. wildcard/prefix terms, fuzzy matching, proximity, boosts, unary `+`/`-` required/prohibited terms).
- Maintain backward compatibility for existing saved/rule/target expressions; new features must be additive and strict-parse validated.

### Integration with existing filter pipeline

Replace `filteredRows` signature:

```go
func filteredRows(rows []transaction, filter *filterNode, txnTags map[int][]tag, sortCol int, sortAsc bool) []transaction
```

The old `searchQuery string`, `filterCats map[int]bool`, `filterAccounts map[int]bool` parameters are replaced by a single `*filterNode`.

```go
// Transactions table: user input + account scope
func (m model) buildTransactionFilter() *filterNode

// Dashboard defaults: timeframe + account scope only (no transaction/saved filter state)
func (m model) buildDashboardScopeFilter() *filterNode

// Custom mode filter: returns the strict-parsed filter for a custom pane mode (nil for curated modes with no expression)
func (m model) buildCustomModeFilter(paneID, modeName string) *filterNode
```

`buildTransactionFilter()` composes:
1. User search/filter input (parsed from the `/` input line)
2. Account scope from `m.filterAccounts` (if set, injected as quoted/escaped account predicates: `acc:"Name 1" OR acc:"Name 2"`)

`buildDashboardScopeFilter()` composes:
1. Dashboard timeframe range
2. Account scope from `m.filterAccounts`

Dashboard default widgets **must not** inherit transaction filter input or active saved-filter state.

Composition contract:
- Internal filter composition is AST-first (`filterNodeAnd` / `filterNodeOr`), never raw string concatenation.
- Any persisted expression text is produced from AST serialization and must round-trip through strict parse.

### Strict filter builder surfaces

Rules, spending targets, and dashboard custom views use a strict builder surface. The builder supports grouped logic via structured ALL/ANY rules and emits precedence-safe expressions in the same v0.4 filter language (including parentheses when needed). Builder output is validated with `parseFilterStrict`, and save is blocked on invalid input.

Strict contexts must never fallback to plain-text matching. They always show parse errors inline and block persistence until resolved.
Persisted strict expressions are canonicalized on save/load round-trip: uppercase boolean operators plus minimal parentheses needed to preserve AST semantics.

### Parser edge-case contract (must be covered)

| Case | Input | Expected |
|---|---|---|
| Operator case-sensitivity | `coffee and tea` | Treated as plain text search terms (no boolean op) |
| Implicit AND (text) | `coffee tea` | Parsed as `coffee AND tea` |
| Implicit AND (predicates) | `cat:Food amt:>50` | Parsed as `cat:Food AND amt:>50` |
| Unary precedence | `NOT cat:Food AND tag:Work` | Parsed as `(NOT cat:Food) AND tag:Work` |
| Parenthesized grouping | `(cat:Food OR cat:Transport) AND amt:>50` | OR branch grouped before AND |
| Missing grouping in strict mode | `cat:Food OR cat:Transport AND amt:>50` | Strict parse error with grouped rewrite suggestion |
| Quoted values | `desc:"coffee shop"` | Phrase match on exact token string (case-insensitive) |
| Quoted account injection | `acc:"ANZ Savings"` | Exact account-name match after unescape |
| Single day date | `date:2025-03-15` | Matches only transactions on 2025-03-15 |
| Month shorthand date | `date:2025-03` | Expands to full month (2025-03-01..2025-03-31) |
| Two-digit month shorthand | `date:26-03` | Expands to full month (2026-03-01..2026-03-31) |
| Date range month endpoints | `date:2025-01..2025-03` | Inclusive range 2025-01-01..2025-03-31 |
| Invalid token (strict) | `cat:` | Parse error; save blocked in strict contexts |
| Invalid token (permissive `/`) | `cat:` | Fallback to permissive plain-text metadata search for `cat:` with parse feedback indicator |

### Saved filters

**Config file: `~/.config/jaskmoney/config.toml`**

```toml
[[saved_filter]]
id = "groceries_this_month"
name = "Groceries this month"
expr = "cat:Groceries AND date:2025-01..2025-01"

[[saved_filter]]
id = "large_debits"
name = "Large debits"
expr = "type:debit AND amt:<-100"
```

Saved filters are loaded alongside CSV formats in `config.go`.
At load time, each `saved_filter.expr` is strict-parsed. Invalid entries are skipped with an actionable warning while app startup continues.

```go
type savedFilter struct {
    ID   string `toml:"id"`   // stable slug key, used by apply commands
    Name string `toml:"name"`
    Expr string `toml:"expr"`
}
```

```go
// Custom dashboard mode: appears as an additional mode slot in the pane's
// mode cycle list (after all curated built-in modes). Inherits the chart
// primitive from the pane but filters data through `expr`.
type customPaneMode struct {
    Pane     string `toml:"pane"`      // pane ID, e.g. "net_cashflow"
    Name     string `toml:"name"`      // display label, e.g. "Renovation Spend"
    Expr     string `toml:"expr"`      // strict filter expression
    ViewType string `toml:"view_type"` // optional: "line"|"area"|"bar"|"pie"|"table"; defaults to pane's primary chart type
}
```

Custom pane modes are stored in `[[dashboard_view]]` blocks in `config.toml` and appear alongside built-in modes in the `[`/`]` cycle. They are validated at load time:
- `expr` must strict-parse with `parseFilterStrict`
- `pane` must match a known pane ID
- `view_type` (if provided) must be one of `line|area|bar|pie|table`

Invalid entries are rejected individually with actionable startup warnings; startup continues and other valid entries still load.

### New model fields

```go
// Filter state
filterInput      string            // raw text in the / input line
filterExpr       *filterNode       // parsed filter (nil = show all)
savedFilters     []savedFilter
customPaneModes  []customPaneMode  // loaded from config; appended to pane mode lists in Phase 6
```

Remove: `filterCategories map[int]bool` (now expressed as filter predicates). Keep `filterAccounts` on the model for Manager scope (composed into filter at build time).

### Saved filter commands

Command exposure is tiered to avoid palette flooding:

| ID | Label | Category |
|---|---|---|
| `filter:apply` | Apply Saved Filter | Filter |
| `filter:apply:<id>` | (hidden dynamic command target) | Filter |

`filter:apply` opens a searchable picker. Hidden `filter:apply:<id>` targets are executable (for command routing / future keybinding extensions) but are not shown in palette search results.

### UI changes

- `/` opens filter input (same key as current search)
- Input line shows in footer with live-parsed indicator: green dot = valid, red dot = parse error
- Active filter shown as a compact pill in the transaction table header: `[cat:Food AND amt:>50]`
- `Esc` clears filter input and resets to no filter
- `f` shortcut removed (was category filter); replaced by typing `cat:Name` in filter input
- `ctrl+l` opens the Apply Saved Filter picker (no implicit “load most recent” behavior)
- Saved-filter CRUDL is available in **Settings → Filters** with add/edit/delete list management

### Commands

| ID | Label | Scopes |
|---|---|---|
| `filter:open` | Open Filter | transactions, manager |
| `filter:clear` | Clear All Filters | transactions |
| `filter:save` | Save Current Filter | filter_input, transactions |
| `filter:apply` | Apply Saved Filter | filter_input, transactions, manager |

### Saved-filter CURDL/CURL UX (Phase 2 completion)

- Config contract for saved filters is strict: `id`, `name`, `expr` required.
- Legacy entries without `id` are dropped with startup warnings.
- Create/edit uses strict parsing and blocks invalid expressions.
- Save flow uses a modal (`ID`, `Name`, `Expr`) and blocks duplicate IDs.
- Apply flow uses picker search (`ctrl+l` / command), with exact `apply:<id>` typed command routing in colon mode.
- Recency ordering (recently applied/created/modified first) is shared across Settings list and apply picker.
- Mutable recency state is stored in DB app-state table(s), while filter definitions remain in config.

### Phase 2 hardening note (completed)

Keybinding materialization no longer performs silent auto-reassignment for
manager quick-tag conflicts. Startup now fails explicitly with actionable
conflict guidance, preserving user intent.

### Files changed

- **New:** `filter.go` — AST, parser, evaluator, serializer
- `app.go` — new model fields, `buildTransactionFilter()`, `buildDashboardScopeFilter()`, updated `filteredRows` signature
- `config.go` — `savedFilter` + `customPaneMode` types, load/save, strict validation at load (invalid saved filters skipped with warning; invalid custom modes rejected)
- `update_transactions.go` — new filter input mode replacing search + category filter
- `render.go` — filter pill in header, input indicator
- `commands.go` — filter commands + dynamic saved filter commands
- `keys.go` — remove `actionFilterCategory`, update `actionSearch` to `filter:open`

### Tests

- `filter_test.go` — parser: plain text, field predicates, implicit AND adjacency, parentheses grouping, AND/OR/NOT, ranges, quoted strings, error fallback to text search. Evaluator: all field types, boolean combinations, edge cases (nil category, nil account, empty tags).
- `config_test.go` — saved filter load/save round-trip; invalid saved filters skipped with warning; custom pane mode load with strict validation (invalid expr rejected)
- `app_test.go` / `update_mode_test.go` — filter input opens, parses, filters rows, Esc clears, saved filter apply
- `model_test.go` — rules/targets/saved-filter editors reject invalid expressions (strict mode)
- `filter_test.go` — strict parser never falls back to text for invalid expressions; strict mixed `AND`/`OR` without grouping is rejected with actionable hint; serializer emits canonical uppercase ops + minimal required parentheses

### Acceptance

- [x] `/` opens filter input.
- [x] Plain-text query path is fast and permissive by design; explicit field scoping is optional for simple queries.
- [x] Field predicates filter correctly: `cat:`, `tag:`, `acc:`, `amt:`, `type:`, `note:`, `date:`.
- [x] Parentheses grouping parses/evaluates correctly (including nested groups).
- [x] Adjacent terms/predicates imply `AND` (fast typing path).
- [x] `AND`, `OR`, `NOT` (uppercase) combine predicates; lowercase treated as text.
- [x] Active filter shown as pill in table header.
- [x] Saved filters persist in config and appear as commands in palette.
- [x] Save/load workflow is available post-apply and accessible in filter and transaction interaction paths (`ctrl+s`/`ctrl+l`).
- [x] Invalid saved filters in config are skipped at startup with actionable warnings (startup continues).
- [x] `/` remains permissive on parse errors with active parse feedback; rules/targets/saved-filter persistence is strict.
- [x] Strict contexts never fallback to permissive text matching; invalid expressions are blocked with actionable errors.
- [x] Strict contexts reject mixed `AND`/`OR` without explicit grouping parentheses, with actionable rewrite hints.
- [x] `f` shortcut removed; category filtering via `cat:Name` in filter input.
- [x] Account scope from Manager still works (composed into filter).
- [x] Dashboard defaults use timeframe + account scope only; transaction/saved filter state does not alter default dashboard metrics.
- [x] Custom pane modes load from `[[dashboard_view]]` config; invalid expressions rejected at load time with errors.
- [x] Persisted strict expressions round-trip through canonical serialization (uppercase ops + minimal required parentheses).
- [x] Behavior-validating regression guards cover input text safety (printable/global keys remain text while filter input is active).
- [x] Field-predicate input/editing flow is usable from filter input.
- [x] Account action modal (`del` => clear txns / nuke account) implemented.
- [x] Account chips show txn count / `Empty`.
- [x] DB bootstrap recreates missing DB path/schema.
- [x] Filter typing/apply responsiveness is release-acceptable for interactive use in v0.32.2f (no known blocking latency regressions in shipped flows).
- [x] Saved-filter CURDL/CURL redesign is fully specified and implemented (settings CRUDL, picker apply flow, strict `id` contract, typed `apply:<id>` routing).
- [x] Keybinding materialization no longer performs silent auto-reassignment for manager quick-tag conflicts; conflicts fail explicitly with actionable guidance.

### Overall acceptance gate (Phase 2)

Phase 2 is sign-off ready only when all acceptance bullets above are satisfied
and the following release checks are green for the checkpoint:

- `go test ./...`
- `go test -tags flowheavy ./...`
- `go run . -startup-check`
- No known critical regressions in filter-input text safety, command scoping, or
  account-scope composition behavior

#### Acceptance status snapshot (v0.32.2f)

Snapshot recorded on `v0.32.2f` (February 14, 2026) after completion of the
saved-filter UX overhaul and hardening pass.

- [x] Filter input text-entry safety is preserved (printable keys are literal while editing).
- [x] `ctrl+s` opens save modal; strict validation blocks invalid/duplicate saves.
- [x] New saved filters default to auto-generated IDs (`filter-1`, `filter-2`, ...) with blank name.
- [x] Saved-filter CRUDL is available in Settings → Filters (add/edit/delete/list).
- [x] Apply flow is tiered: `filter:apply` picker + hidden `filter:apply:<id>` command targets.
- [x] Colon typed routing supports exact `apply:<id>`.
- [x] Apply picker search covers both ID and name content.
- [x] Apply picker row width is viewport-safe (long metadata no border overflow).
- [x] Apply picker respects recency ordering and persists via DB-backed usage state.
- [x] `ctrl+l` works from transactions, filter input, and manager accounts scope.

---

## Phase 3: Rules Engine v2 (v0.33)

**Goal:** Replace v1 category_rules + tag_rules with a unified rules system.
**v0.32.2 implementation update:** rules reference existing saved filters by ID (instead of storing inline rule expressions), rule actions are category + add-tags only (no remove-tags), and rule editor category/tag selection uses modal-on-modal picker reuse.

### Schema changes (part of v4 → v5 migration)

```sql
-- Drop v1 rules (fresh start; users rebuild)
DROP TABLE IF EXISTS category_rules;
DROP TABLE IF EXISTS tag_rules;

CREATE TABLE rules_v2 (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    name            TEXT NOT NULL,
    saved_filter_id TEXT NOT NULL,
    set_category_id INTEGER REFERENCES categories(id) ON DELETE SET NULL,
    add_tag_ids     TEXT NOT NULL DEFAULT '[]',    -- JSON array of tag IDs
    sort_order      INTEGER NOT NULL DEFAULT 0,
    enabled         INTEGER NOT NULL DEFAULT 1,
    created_at      TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_rules_v2_sort ON rules_v2(sort_order);
```

**Design notes:**
- `saved_filter_id` references a configured saved filter (`saved_filter.id`)
- `set_category_id` is nullable: if NULL, the rule does not change category
- `add_tag_ids` is a JSON array of tag IDs (Go `[]int` serialized)
- `sort_order` determines manual ordering; lower = evaluated first
- `enabled = 0` means the rule is skipped everywhere (apply + dry-run) but shown in Settings list as dimmed
- If a rule references a missing/invalid saved filter, that rule is skipped during apply/dry-run/import and counted as a failed rule in summaries

### Go types

```go
type ruleV2 struct {
    id            int
    name          string
    savedFilterID string
    setCategoryID *int
    addTagIDs     []int
    sortOrder     int
    enabled       bool
}
```

### Rule application semantics

**All matching rules apply in list order (sort_order ascending):**

1. Iterate rules in order
2. For each enabled rule, resolve the saved filter expression and evaluate it against the transaction
3. If matched:
   - If `set_category_id != nil`, set the transaction's category (last writer wins)
   - If `add_tag_ids` is non-empty, add those tags (accumulative)
4. After all rules, write final category + tags to DB

`rules:apply` executes inside one DB transaction for the full target set. If any write/validation fails, the full apply run rolls back (no partial category/tag updates).

Tag policy:
- Rule effects are applied strictly in `sort_order`.
- Tags are add-only in rules v2 UI/engine.

**Target set and scope (explicit):**
- Rule matching semantics remain broad: rules can match categorized and uncategorized transactions.
- `rules:apply` resolves scope from `m.filterAccounts` regardless of active tab: non-empty map = scoped run; empty map = all transactions.
- `rules:dry-run` uses the same target set as `rules:apply`.
- Import-time rule application targets **newly imported rows only** for that import operation.

### Dry-run command

Command `rules:dry-run` evaluates all enabled rules against the current `rules:apply` target set (respecting current account scope) without writing. Output is a modal showing:

```
Dry-Run Results
═══════════════

Rule 1: "Grocery stores" (enabled)
  Filter: desc:countdown OR desc:woolworths OR desc:coles
  Matches: 47 transactions
  Actions: → Groceries, +tag:Weekly
  Samples:
    2025-01-15  -$42.50  COUNTDOWN METRO    (currently: Uncategorised)
    2025-01-18  -$87.20  WOOLWORTHS 1234    (currently: Uncategorised)
    2025-01-20  -$23.10  COLES EXPRESS      (currently: Food → Groceries)

Rule 2: "Ignore transfers" (enabled)
  Filter: cat:Transfers
  Matches: 12 transactions
  Actions: +tag:IGNORE
  Samples:
    2025-01-10  -$500.00  TRANSFER TO SAV   (currently: Transfers)
    ...

Summary: 59 transactions would be modified
         23 category changes, 59 tag changes, 1 failed rules
```

Sample rows capped at 3 per rule. Modal is scrollable.
Dry-run/apply surfaces must show the effective account scope label (`All Accounts` or `N selected accounts`) so scope-sensitive runs are explicit.

### Settings UI

Rules section in Settings is overhauled:

**List view:**
```
Rules
─────
  1. ✓ Grocery stores     desc:countdown OR desc:woolworths → Groceries +Weekly
  2. ✓ Ignore transfers   cat:Transfers → +IGNORE
  3. ✗ Old rent rule      desc:rent AND amt:<-1000 → Bills (disabled)
```

- Checkmark/cross shows enabled state
- Dimmed rendering for disabled rules
- Broken filter references render in red
- Rows show explicit list index for ordering clarity

**Interactions:**
- `a` — add new rule (opens rule editor)
- `Enter` — edit rule
- `Del` — delete rule (with confirm)
- `Space` — toggle enable/disable
- `K` / `J` (shift+k/j) — move rule up/down in order
- `A` — apply all rules
- `D` — dry-run

**Rule editor modal:**

Multi-step inline editor:
1. **Name** — text input
2. **Saved filter** — select from existing saved filters (modal picker); save blocked if missing/invalid
3. **Set category** — optional quick-category picker overlay (skip with "No category change")
4. **Add tags** — optional quick-tag picker overlay (add-only toggle, no remove mode)
5. **Enabled** — toggle (default: yes)

Navigation: `↑/↓`, `Ctrl+P/N`, and `Tab`/`Shift+Tab` between fields. `Enter` opens picker or saves on final step. `Esc` cancels.

Universal modal safety rule: if a modal has any text-editable field, `h/j/k/l`
must not be interpreted as navigation (even under custom keybinding overrides).
Only arrows, `Tab`/`Shift+Tab`, and `Ctrl+P/N` are valid modal-nav keys in
those contexts. This is enforced by the `modalTextContracts` entry for
`scopeRuleEditor` (see `dispatch.go`). Use
`textField` for the name and filter expression fields and `modalFormNav` for
inter-step navigation.

### Model changes

```go
// Replace old fields
rules    []ruleV2       // was: []categoryRule
// Remove:
// tagRules []tagRule    // absorbed into rules_v2

// Rule editor state
ruleEditorOpen    bool
ruleEditorStep    int      // 0=name, 1=savedFilter, 2=category, 3=addTags, 4=enabled
ruleEditorID      int      // 0 = new, >0 = editing
ruleEditorName    string
ruleEditorFilterID string
ruleEditorCatID   *int
ruleEditorAddTags []int
ruleEditorEnabled bool

// Dry-run state
dryRunOpen    bool
dryRunResults []dryRunRuleResult
dryRunSummary dryRunSummary
dryRunScroll  int
```

```go
type dryRunRuleResult struct {
    rule       ruleV2
    matchCount int
    catChanges int
    tagChanges int
    samples    []dryRunSample // max 3
}

type dryRunSample struct {
    txn         transaction
    currentCat  string
    newCat      string
    addedTags   []string
    removedTags []string
}

type dryRunSummary struct {
    totalModified  int
    totalCatChange int
    totalTagChange int
}
```

### Commands

| ID | Label | Scopes |
|---|---|---|
| `rules:apply` | Apply All Rules | settings, global |
| `rules:dry-run` | Dry-Run Rules | settings, global |

### DB functions

```go
func loadRulesV2(db *sql.DB) ([]ruleV2, error)
func insertRuleV2(db *sql.DB, r ruleV2) (int, error)
func updateRuleV2(db *sql.DB, r ruleV2) error
func deleteRuleV2(db *sql.DB, id int) error
func reorderRuleV2(db *sql.DB, id, newSortOrder int) error
func toggleRuleV2Enabled(db *sql.DB, id int, enabled bool) error
func applyRulesV2ToScope(db *sql.DB, rules []ruleV2, txnTags map[int][]tag, accountFilter map[int]bool) (catChanges, tagChanges int, err error)
func applyRulesV2ToTxnIDs(db *sql.DB, rules []ruleV2, txnTags map[int][]tag, txnIDs []int) (catChanges, tagChanges int, err error)
func dryRunRulesV2(db *sql.DB, rules []ruleV2, rows []transaction, txnTags map[int][]tag) ([]dryRunRuleResult, dryRunSummary)
```

### Import integration

`ingestCmd` now calls `applyRulesV2ToTxnIDs` instead of the old `applyCategoryRules` + `applyTagRules`. Rules are loaded fresh at import time and run only against newly imported row IDs.

### Files changed

- `db.go` — migration v4→v5 (drop old rules, create rules_v2), new CRUD functions
- `ingest.go` — replace old rule application with `applyRulesV2ToScope` / `applyRulesV2ToTxnIDs`
- `app.go` — new model fields for rules state
- `update_settings.go` — rule editor, enable/disable toggle, reorder, dry-run modal
- `render.go` — rule list rendering, rule editor modal, dry-run results modal
- `commands.go` — `rules:apply`, `rules:dry-run`
- `filter.go` — used by rules for matching (no changes, just consumed)

> **Keybinding note:** The rule editor and dry-run modal are modal scopes. Add `overlayEntry` entries for both in `overlayPrecedence()` (`dispatch.go`) at the correct priority positions. Add a `modalTextContracts` entry for `scopeRuleEditor` (name and filter fields are text-editable; `cursorAware=true`, `printableFirst=true`, `vimNavSuppressed=true`). The dry-run modal is a viewer with no text fields and needs no text contract entry. Use `textField` and `modalFormNav` helpers from `dispatch.go` for the rule editor's multi-step form fields. The rules list view extends `scopeSettingsActiveRules` with new actions (`a` add, `Enter` edit, `Del` delete, `Space` toggle, `K`/`J` reorder, `A` apply, `D` dry-run). Uppercase `K`/`J`/`A`/`D` coexist with lowercase `k`/`j`/`a`/`d` in the same scope because case is preserved for single-letter keys in the registry (see key normalization in `keys.go`). Verify these don't shadow global bindings via the shadow audit test.

### Tests

- `db_test.go` — rules_v2 CRUD, ordering, enable/disable, migration preserves other data
- `filter_test.go` — (from Phase 2, reused) filter expressions evaluate correctly against transactions
- `ingest_test.go` — import applies rules_v2 correctly, category + tag actions both fire, imported rows only are touched
- `model_test.go` — rule editor flow, dry-run modal, reorder, toggle enable
- `model_test.go` / `update_settings_test.go` — `rules:apply` and `rules:dry-run` respect current account scope

### Acceptance

- [x] Rules v1 tables dropped on migration; rules_v2 created
- [x] All other v0.3 data (transactions, categories, tags, accounts) preserved
- [x] Rule editor supports: name, saved filter reference, set category, add tags, enabled toggle
- [x] Rules apply in manual order; all matching rules fire
- [x] Last category setter wins; tags accumulate
- [x] Disabled rules skipped in apply and dry-run
- [x] `rules:apply` and `rules:dry-run` always resolve scope from `m.filterAccounts`; import applies rules only to newly imported rows
- [x] Given the same scope and rule set, `rules:dry-run` and `rules:apply` target identical transaction sets
- [x] Rules Apply and Dry-Run surfaces show effective scope (`All Accounts` or `N selected accounts`)
- [x] Dry-run shows per-rule counts + up to 3 sample rows + summary totals
- [x] `K`/`J` reorders rules in Settings and keeps cursor on the moved rule
- [x] Import applies rules_v2 (replaces old rule application)

#### Acceptance Notes (v0.32.3)

- Rule/filter coupling is now strict by design: each rule references an existing saved filter ID; missing or invalid saved filters are blocked in editor save and reported in rule health rendering.
- Rule editor and filter editor strict-parse indicators now include scoped match counts (`N txns`) for sanity checking expressions before save.
- Rule/category/tag editor modals enforce the universal text-input modal safety rule via `modalTextContracts` entries in `dispatch.go`: `h/j/k/l` are never interpreted as navigation in these contexts, even under custom keybinding overrides.
- Rule tag picker preserves quick single-`Enter` toggle+close behavior only when there are no pending changes from picker-open baseline; pending-change flows submit without unintended extra toggles.

---

## Phase 4: Import Preview Integration (v0.34)

**Goal:** Replace the minimal dupe modal with a combined preview + decision modal that shows duplicate context before the user chooses.

### Combined import preview modal

When `scanDupesCmd` completes, open a combined preview modal for **all scans** (including `dupeCount == 0`).
The old direct auto-import path for zero-duplicate files is removed.

**Compact view (default):**

```
Import Preview: ANZ-2025-01.csv
═════════════════════════════════

Summary
  Total rows in snapshot:  142
  New transactions:        128
  Duplicates found:         14
  Parse/normalize errors:    0

Duplicate Rows (14)
───────────────────
  #   Date         Amount    Description
  1   2025-01-05   -$42.50   COUNTDOWN METRO SYDNEY
  2   2025-01-05   -$12.30   UBER *EATS
  3   2025-01-08   -$87.20   WOOLWORTHS 1234
  ...
  (showing 14 of 14 duplicates)

─────────────────────────────────
  [a] Import All (142 rows)   [s] Skip Dupes (128 rows)   [f] Full View   [Esc] Cancel
```

- Preview is backed by an immutable in-memory import snapshot (rows + dupe flags + parse diagnostics + locked ruleset metadata).
- Compact view renders duplicate rows in stable file order.
- Duplicate list is scrollable and display-capped to first 100 rows with `+N more not shown`.
- Navigation uses standard list/table navigation primitives (same action surface as transactions table):
  - `up/down` actions (default keys include `j`/`k`, arrows, and `ctrl+p`/`ctrl+n`)
- Decisions:
  - `a` — import all rows from snapshot (including duplicate-flagged rows)
  - `s` — import only non-duplicate rows from snapshot
  - `Esc` — cancel import and close preview
  - ~~`f` — toggle full view~~
  - `p` — toggle compact preview mode (`dupes-only` <-> `all-rows`)
  - `r` — toggle rules ON/OFF for preview and confirm import

**~~Full view~~ (descoped on February 15, 2026):**

~~Full-screen preview mode was removed. Compact preview now serves as the single preview surface and is fully scrollable.~~

**Esc lifecycle contract (updated):**
- `Esc` in compact preview -> cancel import and close modal

Display policy:
- ~~Rendering is capped to first 100 rows in compact and full views.~~
- Compact preview is paged at 20 rows with stable cursor+window scrolling.
- Import decisions always apply to the full snapshot, not only displayed rows.

### Post-rules preview

Post-rules preview is computed against the immutable scan snapshot and a locked ruleset captured at preview-open time.

Simulation pipeline:
1. Parse CSV rows and construct snapshot rows (stable file order).
2. Detect duplicate status per row.
3. Capture parse/normalize diagnostics per row (date/amount/required fields).
4. Load and lock active rules_v2 metadata at preview-open:
   - rule IDs
   - sort order
   - enabled/disabled state
   - materialized rule definitions used for simulation/import
5. Evaluate locked enabled rules against temporary transaction representations for all snapshot rows.
6. Populate projected category + tag outcomes for display.

Behavioral contract:
- Preview simulation is read-only (no DB writes).
- ~~Simulation runs asynchronously for all rows; UI may show loading/progress while preparing post-rules projection.~~
- Simulation currently runs synchronously in scan command path (fast-path implementation).
- If any row has parse/normalization errors, import decisions are blocked (`a`/`s` disabled) and the modal shows an error summary with row references.
- While preview modal is open, rule editing/actions remain blocked by modal precedence.
- Confirm import uses the same frozen snapshot; locked ruleset parity is guaranteed when rules are enabled at confirm time.

### Model changes

```go
// Import preview overlay state
importPreviewOpen      bool
importPreviewPostRules bool   // false=raw/rules-off, true=rules-on
importPreviewShowAll   bool   // false=dupes-only compact, true=all-rows compact
importPreviewCursor    int
importPreviewScroll    int

// Frozen snapshot used by both preview and confirm import
importPreviewSnapshot *importPreviewSnapshot
```

```go
type importPreviewSnapshot struct {
    fileName     string
    createdAt    time.Time
    totalRows    int
    newCount     int
    dupeCount    int
    errorCount   int
    rows         []importPreviewRow        // stable file order
    parseErrors  []importPreviewParseError // import-blocking diagnostics
    lockedRules  importPreviewLockedRules  // exact ruleset used for simulation/import
}

type importPreviewLockedRules struct {
    ruleIDs    []int
    rules      []ruleV2 // materialized at preview-open
    lockReason string   // e.g. "preview-open"
}

type importPreviewRow struct {
    index       int
    sourceLine  int
    dateRaw     string
    dateISO     string
    amount      float64
    description string
    isDupe      bool

    // Simulated post-rules projection
    previewCat  string
    previewTags []string
}

type importPreviewParseError struct {
    rowIndex    int
    sourceLine  int
    field       string
    message     string
}
```

### Flow change

Old:
- `scanDupesCmd` -> `dupeScanMsg` -> if dupes=0 auto-import, else open dupe modal

New:
- `scanDupesCmd` -> `importPreviewMsg` (contains frozen snapshot) -> always open import preview modal
- User confirms `a` or `s` -> import executes from frozen snapshot (no CSV reparse)
- `Esc` cancels from preview

Message contract:

```go
type importPreviewMsg struct {
    snapshot *importPreviewSnapshot
    err      error
}
```

Implementation note:
- `scanDupesCmd` is responsible for producing the full snapshot (rows, dupe flags, diagnostics, locked rules metadata, and post-rules projections).
- Confirm import command consumes `importPreviewSnapshot` directly.
- The previous `dupeScanMsg` + `importDupeModal` path is removed.

### Commands

| ID | Label | Scopes |
|---|---|---|
| `import:all` | Import All | import_preview |
| `import:skip-dupes` | Import Skip Dupes | import_preview |
| ~~`import:full-view`~~ | ~~Toggle Full View~~ | ~~import_preview~~ |
| `import:preview-toggle` | Toggle Compact Preview Mode | import_preview |
| `import:raw-view` | Toggle Rules (ON/OFF) | import_preview |
| `import:cancel` | Cancel Import | import_preview (Esc only) |

Notes:
- `import:cancel` is intentionally bound to `Esc` only (no `c` binding).
- Navigation in `import_preview` uses standard up/down actions (default key aliases mirror transaction table behavior).

### Files changed

- `ingest.go`
  - `scanDupesCmd` returns a full frozen snapshot (`importPreviewSnapshot`)
  - add async post-rules simulation for all rows
  - add parse/normalize diagnostics collection
  - add import-from-snapshot command path
- `app.go`
  - new model fields for preview overlay + snapshot pointer
  - replace old dupe modal state usage
- `update.go`
  - handle `importPreviewMsg` and open preview for all scans (including zero dupes)
  - remove zero-dupe direct auto-import branch
- `update_settings.go` (or owning update file for import overlay handling)
  - add `updateImportPreview` handler
  - ~~enforce Esc step-down behavior~~
  - enforce single-step Esc cancel behavior
  - enforce blocked decisions while snapshot has parse errors
- `render.go`
  - replace `renderDupeModal` with `renderImportPreview` (compact only)
  - render category + tags using transaction-table primitive styling
  - render parse error summary and decision-disabled state
- `keys.go`
  - add `scopeImportPreview`
  - bind import preview actions (`a`, `s`, `r`, `p`, `esc`) and standard up/down navigation aliases
  - remove dupe modal scope bindings (`scopeDupeModal`) once migration completes
- `dispatch.go`
  - replace dupe overlay entry with import preview overlay entry at same precedence slot
  - ensure shared overlay table remains authoritative for update/footer/command scope resolution
- `commands.go`
  - migrate command-open gating to overlay-derived gate (single source of truth)
  - ensure import preview modal blocks command-open consistently
- `AGENTS.md`
  - update import flow summary to reflect snapshot-based preview and Esc lifecycle

> **Keybinding note:** `scopeImportPreview` is a modal scope and fully blocks non-modal handling. Add an `overlayEntry` for `importPreviewOpen` in `overlayPrecedence()` (`dispatch.go`) at the same precedence position currently used by duplicate-decision flow. This modal has no text-editable fields, so no `modalTextContracts` entry is required. Navigation should be action-based (`up`/`down`) with default aliases matching transaction/list conventions (`j`/`k`, arrows, `ctrl+p`/`ctrl+n`). Keep decision actions explicit (`import:all`, `import:skip-dupes`, `import:cancel`), with `import:cancel` bound to `Esc` only.

### Tests

- `ingest_test.go`
  - snapshot build correctness (row order, dupe flags, counts)
  - parse/normalize diagnostics surfaced with row/source-line references
  - post-rules simulation populates both category and tags
  - import-from-snapshot parity: persisted outcomes match preview projection for imported rows
  - ruleset lock parity: confirm import uses locked rules, not current mutable rules state
- `update_*_test.go` (owning update file)
  - preview opens for both `dupeCount == 0` and `dupeCount > 0`
  - ~~Esc lifecycle: full->compact, compact->cancel~~
  - Esc lifecycle: compact->cancel
  - while `importPreviewOpen`, rules editor/actions are blocked by modal precedence
  - decisions (`a`/`s`) disabled when parse errors exist
- `model_test.go`
  - compact preview toggle, rules ON/OFF toggle, scroll behavior, decision execution
- `render_test.go`
  - ~~compact/full rendering capped at 100 rows with `+N more` indicator~~
  - compact table paging behavior and transaction-table visual parity in post-rules mode
  - parse-error banner and disabled decision hints
- `flow_test.go` (required, default suite)
  - end-to-end import preview decision paths (`a`, `s`, Esc cancel) with persisted DB assertions
  - no-partial-write failure path when snapshot contains parse errors
  - command palette/mode cannot open while import preview modal is active
- `flow_heavy_test.go` (optional for scale)
  - large-file async simulation smoke and modal responsiveness
- `dispatch_test.go` / `commands_test.go`
  - overlay precedence includes `import_preview` in correct slot
  - overlay-derived command-open gate matches overlay active state

### Acceptance

- [x] Import flow opens combined preview modal for every scan result (including zero-duplicate files)
- [x] Compact view shows summary + scrollable duplicate list in stable file order
- [ ] ~~Full view shows all displayed rows with New/DUPE status; post-rules mode shows projected category **and tags**~~
- [x] `a`/`s` decisions work in preview; `Esc` cancels import and closes modal
- [x] `c` is not bound as a cancel shortcut in import preview
- [x] Navigation uses standard up/down action surface (default aliases include vim/arrows/ctrl+p/n)
- [x] Preview/import parity is guaranteed by frozen snapshot import path (no reparse-on-confirm)
- [x] Preview/import parity is guaranteed by locked ruleset captured at preview-open (when rules are enabled)
- [ ] ~~Post-rules preview runs on all rows asynchronously without DB writes~~
- [x] Any parse/normalization errors block import decisions and are shown with row-level diagnostics
- [ ] ~~Row display capped at 100 with `+N more` indicator in compact and full views~~
- [x] While preview is open, rule edits/actions are blocked by modal precedence
- [x] Command-open gating derives from overlay state and blocks command UI while preview modal is active
- [x] Update-driven flow tests and failure-path no-partial-write regressions are added
- [x] `AGENTS.md` is updated in the same commit to reflect finalized import-preview behavior

**Status note (February 15, 2026):**
- Phase 4 is functionally implemented for the revised compact-preview scope.
- Final sign-off is **pending** an additional detailed manual test pass (UAT round) before closure.

---

## Phase 5: Budgeting System (v0.35)

**Goal:** Ship the Budget tab and budgeting compute stack on schema v6, with category budgets, saved-filter spending targets, offset-aware remaining values, and a shared month/timeframe primitive between Dashboard and Budget.

### Schema Data Baseline (Runtime v6)

Budget/offset tables are runtime schema concerns (no new migration phase in v0.35):

```sql
CREATE TABLE category_budgets (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    category_id INTEGER NOT NULL UNIQUE REFERENCES categories(id) ON DELETE CASCADE,
    amount      REAL NOT NULL DEFAULT 0,
    created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE category_budget_overrides (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    budget_id   INTEGER NOT NULL REFERENCES category_budgets(id) ON DELETE CASCADE,
    month_key   TEXT NOT NULL,
    amount      REAL NOT NULL,
    UNIQUE(budget_id, month_key)
);

CREATE TABLE spending_targets (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    name            TEXT NOT NULL,
    saved_filter_id TEXT NOT NULL,
    amount          REAL NOT NULL DEFAULT 0,
    period_type     TEXT NOT NULL DEFAULT 'monthly'
                    CHECK(period_type IN ('monthly','quarterly','annual')),
    created_at      TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE spending_target_overrides (
    id         INTEGER PRIMARY KEY AUTOINCREMENT,
    target_id  INTEGER NOT NULL REFERENCES spending_targets(id) ON DELETE CASCADE,
    period_key TEXT NOT NULL,
    amount     REAL NOT NULL,
    UNIQUE(target_id, period_key)
);

CREATE TABLE credit_offsets (
    id             INTEGER PRIMARY KEY AUTOINCREMENT,
    credit_txn_id  INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    debit_txn_id   INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    amount         REAL NOT NULL CHECK(amount > 0),
    created_at     TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK(credit_txn_id != debit_txn_id),
    UNIQUE(credit_txn_id, debit_txn_id)
);

CREATE TABLE manual_offsets (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    debit_txn_id INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    amount      REAL NOT NULL CHECK(amount > 0),
    created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);
```

### Go types

Current v0.35 data model:

- `categoryBudget`, `budgetOverride`, `spendingTarget`, `targetOverride`
- `creditOffset` index type reused for both linked offsets and manual offsets (manual rows are represented with synthetic IDs / `creditTxnID=0` in load/index paths)
- `budgetLine` / `targetLine` include:
  - `spent` (gross debit spend)
  - `offsets`
  - `netSpent` (`spent - offsets`)
  - `remaining` (`budgeted - netSpent`)

### Budget calculation

Canonical compute contract in v0.35:

- Spend is always **gross debit spend** (`SUM(-amount)` for `amount < 0`).
- Offsets are aggregated from both `credit_offsets` and `manual_offsets` for scoped debit transactions.
- Remaining is always effective outflow math:
  - `remaining = budgeted - (spent - offsets)`
- There is no raw/effective mode toggle in Budget or Dashboard.

Scope/window contract:

- Budget scope month uses `YYYY-MM` with `[start, end)` date range predicates.
- Budget uses Manager account scope (`filterAccounts`) directly.
- Missing aggregates default to `0`.

Category budget row lifecycle:

- Existing categories are zero-seeded.
- Refresh path enforces/backs fills one budget row per category (`ensureCategoryBudgetRows`) to keep category-budget alignment stable after category edits/imports.

Spending targets:

- `saved_filter_id` is the source of truth.
- CRUD validates non-empty + resolvable saved filter IDs.
- Period keys:
  - monthly: `YYYY-MM`
  - quarterly: `YYYY-Qn`
  - annual: `YYYY`

### Tab structure

Budget remains tab index `1` in v0.35:

- `1` Dashboard
- `2` Budget
- `3` Manager
- `4` Settings

### Budget tab views

Two views remain:

- table (`budgetView=0`)
- planner (`budgetView=1`)

Budget table columns:

- `Category | Budgeted | Spent | Offsets | Remaining`

Top-of-tab date pane architecture (shared primitive):

- Dashboard owns timeframe state; Budget consumes the same primitive style.
- Budget only exposes month stepping semantics:
  - `[` previous month
  - `]` next month
  - `0` reset to This month
- Month changes sync with dashboard month anchor state.

### Offset flow (current)

Offset entry is initiated from Manager transactions via quick action:

- `o` (`txn:quick-offset`) from transactions pane
- amount entry modal writes `manual_offsets`
- no transaction-detail linking workflow in v0.35 (legacy detail-path command removed)

Linked `credit_offsets` data is still loaded/aggregated if present in DB and participates in net spend math.

### Offset integrity rules

`insertManualOffset` contract:

- amount must be `> 0`
- target transaction must be a debit (`amount < 0`)
- one write transaction; invalid paths perform no writes

`insertCreditOffset` remains available in DB layer with sign/account/capacity validation, but UI flow is intentionally not exposed in v0.35.

### Model changes

Relevant v0.35 model state (current architecture):

- Budget view/edit state: `budgetMonth`, `budgetYear`, `budgetView`, `budgetCursor`, `budgetPlannerCol`, `budgetEditing`, `budgetEditValue`
- Shared date primitive state: `dashTimeframe`, `dashMonthMode`, `dashAnchorMonth`, `dashTimeframeFocus`, `dashTimeframeCursor`, custom date fields
- Budget data caches: budgets/overrides/targets/targetOverrides + offset indexes + computed lines

Removed from Phase 5 draft design:

- shared spend mode toggle (`spendModeRaw`) and mode switcher UI
- detail-modal offset-link pathway (`txn:link-offset`)

### Commands

Current v0.35-relevant commands:

| ID | Label | Scopes |
|---|---|---|
| `nav:budget` | Go to Budget | global |
| `budget:prev-month` | Previous Month | budget, dashboard, dashboard_timeframe |
| `budget:next-month` | Next Month | budget, dashboard, dashboard_timeframe |
| `timeframe:this-month` | This Month | budget, dashboard, dashboard_timeframe |
| `budget:toggle-view` | Toggle Table/Planner | budget |
| `budget:edit` | Edit Budget Amount | budget |
| `budget:add-target` | Add Spending Target | budget, global |
| `budget:delete-target` | Delete Spending Target | budget |
| `budget:reset-override` | Reset Override | budget |
| `txn:quick-offset` | Quick Offset | transactions |

### DB functions

Core functions in use:

```go
func loadCategoryBudgets(db *sql.DB) ([]categoryBudget, error)
func upsertCategoryBudget(db *sql.DB, categoryID int, amount float64) error
func loadBudgetOverrides(db *sql.DB) (map[int][]budgetOverride, error)
func upsertBudgetOverride(db *sql.DB, budgetID int, monthKey string, amount float64) error
func deleteBudgetOverride(db *sql.DB, budgetID int, monthKey string) error
func loadSpendingTargets(db *sql.DB) ([]spendingTarget, error)
func insertSpendingTarget(db *sql.DB, t spendingTarget) (int, error)
func updateSpendingTarget(db *sql.DB, t spendingTarget) error
func deleteSpendingTarget(db *sql.DB, id int) error
func loadTargetOverrides(db *sql.DB) (map[int][]targetOverride, error)
func upsertTargetOverride(db *sql.DB, targetID int, periodKey string, amount float64) error
func loadCreditOffsets(db *sql.DB) ([]creditOffset, error)
func indexCreditOffsets(rows []creditOffset) (byDebit map[int][]creditOffset, byCredit map[int][]creditOffset)
func insertManualOffset(db *sql.DB, debitTxnID int, amount float64) error
func computeBudgetLines(db *sql.DB, budgets []categoryBudget, overrides map[int][]budgetOverride, offsetsByDebit map[int][]creditOffset, month string, accountFilter map[int]bool) ([]budgetLine, error)
func computeTargetLines(db *sql.DB, targets []spendingTarget, overrides map[int][]targetOverride, offsetsByDebit map[int][]creditOffset, txnTags map[int][]tag, savedFilters []savedFilter, accountFilter map[int]bool) ([]targetLine, error)
```

### Files changed

- `budget.go`
- `update_budget.go`
- `db.go`
- `app.go`
- `render.go`
- `update_transactions.go`
- `commands.go`
- `keys.go`

### Tests

Coverage targets and current suites include:

- budget compute correctness (`budget_test.go`)
- spending target saved-filter validation + persistence (`db_test.go`)
- category budget row backfill invariant (`db_test.go`)
- quick offset flow (`update_transactions`/command-level tests)
- date primitive behavior and month snapping/reset interactions (`update_mode_test.go`, dashboard timeframe tests)
- keybinding/command scope contracts (`keys_test.go`, `commands_test.go`)

### Acceptance

- [x] Budget tab accessible as tab `2`
- [x] Category budgets + month overrides supported
- [x] Spending targets are saved-filter based with monthly/quarterly/annual periods
- [x] Budget compute uses gross `Spent` and effective `Remaining` (`spent - offsets`)
- [x] Offsets from both linked and manual sources are included in budget/target math
- [x] Category budget rows are backfilled to match category set
- [x] Budget table + planner are both operational
- [x] Shared date primitive is used by Dashboard and Budget; Budget exposes month stepping/reset only
- [x] `[`/`]` month stepping and `0` reset-to-this-month are available in Dashboard and Budget top-level scopes
- [x] Quick offset action is available from transactions pane without detail modal
- [x] Legacy spend-mode switcher and detail offset-link UI pathway are removed

#### Acceptance Notes (v0.35)

- Phase 5 is accepted on current architecture, with two intentional deltas from the earlier draft:
  1. raw/effective mode toggle was removed in favor of always showing gross `Spent` + effective `Remaining`.
  2. offset entry uses transactions quick-offset (`manual_offsets`) instead of detail-modal credit-link UX.
- Dashboard focused-pane mode/drill commands remain registered stubs for later dashboard-focused phases; they are not part of Phase 5 acceptance.

---

## Phase 6: Dashboard v2 (v0.36+)

**Goal:** Ship Dashboard v2 as an additive rebuild: keep the existing top dashboard sections, add a new lower 2x2 analytics pane grid, unify timeframe behavior with the new date-range primitive, support drill-down to Manager with return context, and integrate dashboard pane focus with app-wide jump mode.

### Phase 6 refinement (post-rollout)

This phase was later simplified for usability:
- Lower analytics region is now **2 panes**: Net/Cashflow and Composition.
- Pane layout uses a **60:40** split (Net/Cashflow on the wider column) with **1-char horizontal gap**.
- In-pane vertical scrolling was removed; pane content is sized to avoid per-pane scroll interaction.
- Net/Cashflow modes retired: `burn_runway`, `savings_rate` (metrics moved to Overview strip).
- Composition mode retired: `recurring_share`.
- Compare Bars moved from Dashboard to Budget as a wide strip; `month_over_month` now renders there.
- Mode cycling remains on `<` / `>` in focused pane context.

### Dashboard visual structure

The dashboard renders top-to-bottom in two regions:

1. **Existing top region (retained)**
   - Date Range pane (focusable, jump key `d`, retained)
   - Overview strip (non-focusable)
   - Spending Tracker (non-focusable, retained)
   - Spending by Category (non-focusable, retained)
2. **New lower analytics region (Phase 6)**
   - 2x2 focusable pane grid with jump keys `n`/`c`/`b`/`h`

Only Date Range is focusable in the retained top region. The other retained sections remain visible for continuity and are not pane-focus targets.

### Widget primitive

**New file: `widget.go`**

```go
type widgetKind int
const (
    widgetNetCashflow widgetKind = iota
    widgetComposition
    widgetCompareBars
    widgetBudgetHealth
)

type widgetMode struct {
    id        string
    label     string
    viewType  string  // "line" | "area" | "bar" | "pie" | "table"
    filterExpr string // non-empty for custom modes; empty for curated defaults
    custom    bool    // true for user-defined custom slot modes
}

type widget struct {
    kind       widgetKind
    title      string
    jumpKey    string       // shown in jump overlay (e.g. "n", "c", "b", "h")
    modes      []widgetMode // curated built-in modes + optional custom slot mode
    activeMode int
    scroll     int
}

func newDashboardWidgets(customModes []customPaneMode) []widget // v0.4 returns 4 panes
```

`newDashboardWidgets` builds the 4 panes with their curated modes and attaches each pane's optional custom slot mode (when active). Custom modes inherit the pane's primary chart type if `ViewType` is empty.

Extensibility contract:
- `widgetKind` and renderer dispatch are open-ended for future pane additions.
- Domain-first ownership stays stable even if future modes use new chart primitives.

### Canonical 4-pane layout (v0.4)

1. **Net/Cashflow** (`widgetNetCashflow`, jump key: `n`)
2. **Composition** (`widgetComposition`, jump key: `c`)
3. **Compare Bars** (`widgetCompareBars`, jump key: `b`)
4. **Budget Health** (`widgetBudgetHealth`, jump key: `h`)

### Pane mode definitions (domain-first)

Each pane has curated built-in modes. Users cycle modes with `<`/`>` when a pane is focused. `[`/`]` are reserved for timeframe month stepping (dashboard top-level and budget). There is no dynamic filter input on the dashboard.

**1. Net/Cashflow**
- `net_worth` (line/area): total balance over time (all active accounts)
- `spending` (line/area): debit spend over time (evolution of v0.3 Spending Tracker)
- `burn_runway` (line): burn rate/runway trend
- `savings_rate` (line): savings-rate trend
- *(custom slot active in Phase 6)*

**2. Composition**
- `category_share` (mekko/pie style): category spending composition (evolution of v0.3 Spending by Category)
- `needs_wants_savings` (stacked composition)
- `top_merchants` (bar/pie hybrid)
- `recurring_share` (composition of recurring vs non-recurring)
- *(custom slot reserved; inactive in Phase 6)*

**3. Compare Bars**
- `budget_vs_actual` (bar/column)
- `income_vs_expense` (bar/column)
- `month_over_month` (bar)
- *(custom slot reserved; inactive in Phase 6)*

**4. Budget Health**
- `status` (progress/table): per-category budget utilization
- `variance_trend` (line/bar)
- `over_budget_hotspots` (ranked bar/list)
- *(custom slot reserved; inactive in Phase 6)*

Descriptive labels like "mekko/pie style" and "bar/pie hybrid" are UX descriptions, not new `view_type` values. Each curated mode must map to one canonical renderer type in `viewType` (`line|area|bar|pie|table`) and that mapping must be covered in widget tests.

### Custom mode slots

Phase 6 introduces in-dashboard custom mode authoring via modal (not Settings).
Authoring flow:
1. Create from a blank custom slot
2. Assign filter via picker modal (same interaction style as filter load popup)
3. Save as pane mode metadata

Architecture supports **one custom slot per pane**.
Phase 6 rollout enables the slot in **Net/Cashflow only**; other panes keep the slot contract inactive until later iteration.

Custom filters compose via AST as:
`AND(buildDashboardScopeFilter(), customModeFilter)`
(no string concatenation).

### Fixed layout

Dashboard uses additive layout:
- retained top region (Date Range + existing overview/tracker/category sections)
- lower 2x2 analytics grid

Lower grid:
- equal-width 2 columns x 2 rows
- panes: Net/Cashflow, Composition, Compare Bars, Budget Health
- narrow fallback (`termWidth < 80`): 1-column vertical stack for the lower grid

### Focus model

Dashboard jump targets in this phase:
- `d` = Date Range pane
- `n` / `c` / `b` / `h` = lower analytics panes

States:
1. **Unfocused (default)** — dashboard visible; top-level timeframe controls active
2. **Focused Date Range** — preset/custom range edits
3. **Focused Analytics Pane** — pane mode/scroll/drill available

Key behavior:
- `[` / `]` — month step for timeframe (available at dashboard top-level and in budget)
- `0` — reset timeframe to This month
- `<` / `>` — previous/next mode while focused into a pane.
- `Enter` — drill-down (if active mode exposes drill predicate)
- `Esc` — unfocus current dashboard focus context

### Model changes

```go
// Dashboard widget state (Phase 6 additions to global model)
dashWidgets       []widget

// Drill-down return context
drillReturn       *drillReturnState // nil = no return context active
```

Dashboard focus state is managed via the global `focusedSection` field (Phase 1). Dashboard-specific: `focusedSection` values 0-3 map to the 4 panes; -1 = unfocused.

```go
type drillReturnState struct {
    returnTab     int  // tab to return to (tabDashboard)
    focusedWidget int  // which pane was focused (-1 if unfocused)
    activeMode    int  // mode index within the focused pane
    scroll        int  // scroll position within the focused pane
    prevFilterInput string      // Manager filter input before drill
    prevFilterExpr  *filterNode // Manager parsed filter before drill
}
```

### Drill-down with return context

When a user presses `Enter` on a focused pane item:
1. Determine item expression (e.g. `cat:Groceries`, `tag:Recurring`)
2. Compose with active timeframe range (`date:start..end`)
3. Save current dashboard state to `drillReturn`: tab, focused widget, active mode, scroll, and prior Manager filter state (`filterInput`/`filterExpr`)
4. **Replace** `m.filterInput`/`m.filterExpr` with composed expression
5. Switch to Manager tab (transactions view)

**Return behavior:**
- While `drillReturn` is set, ESC from the Manager filter view returns to the dashboard and restores the saved state (focused pane, mode, scroll position)
- On drill-return ESC, restore prior Manager filter state exactly, then clear `drillReturn`
- The filter pill in Manager shows a visual indicator prefix (e.g. `[Dashboard >]`) to signal this is a drill-down context
- Navigating away from Manager by any other means (tab switch, `v` jump, etc.) clears `drillReturn`
- When `drillReturn` is nil (normal Manager usage), ESC from filter clears the filter and stays on Manager, as today

**Drill predicate contract:**
- Default drill uses the active mode's mode-level predicate.
- Table/list modes may drill using selected-row predicate when a row is selected.
- If a mode defines no drill predicate, `Enter` is disabled with an explicit footer reason.

### Analytics scope

Default pane data always uses:
1. Dashboard timeframe (from `buildDashboardScopeFilter()`)
2. Account scope from Manager (`filterAccounts`)

Default dashboard panes do **not** inherit transaction search input or saved-filter state.

When a mode has a filter expression (custom mode):
1. Parse expression via strict parser (already validated at config load)
2. Compose via AST as `AND(buildDashboardScopeFilter(), customModeFilter)`

The summary header strip uses the same `buildDashboardScopeFilter()` as the panes for its KPI calculations.

### Commands

| ID | Label | Scopes |
|---|---|---|
| `dash:month-prev` | Previous Month | dashboard, dashboard_focused_date, budget |
| `dash:month-next` | Next Month | dashboard, dashboard_focused_date, budget |
| `dash:month-reset-this` | Reset to This Month | dashboard, dashboard_focused_date, budget |
| `dash:mode-next` | Next Widget Mode | dashboard_focused |
| `dash:mode-prev` | Previous Widget Mode | dashboard_focused |
| `dash:drill-down` | Drill Down | dashboard_focused |
| `dash:custom-mode-edit` | Edit Custom Mode Slot | dashboard_focused |

Note: dashboard pane focus/unfocus still uses global jump commands from Phase 1.

### Files changed

- **New:** `widget.go` — 4-pane domain-first widget definitions, mode metadata, and per-pane custom slot support
- `app.go` — dashboard scope builder usage, widget state updates, `drillReturnState` type + field, summary header strip rendering
- `update_dashboard.go` — focused pane interactions (mode cycling, scroll, drill-down), drill-return context management; jump mode targets registered with Phase 1 infrastructure
- `update_transactions.go` — drill-return ESC handling (return to dashboard when `drillReturn` is set)
- `render.go` — additive dashboard layout with retained top region + lower 2x2 grid, per-domain mode renderers, narrow terminal fallback, drill-return prefix in filter pill
- `commands.go` — dashboard mode/drill commands
- `keys.go` — `scopeDashboardFocused` scope with mode cycling + drill-down bindings, dashboard top-level month-step bindings, dashboard pane jump targets registered with global jump infrastructure
- `config.go` — optional persistence schema for dashboard custom slot metadata (type defined in Phase 2)

> **Keybinding note:** `[`/`]` are timeframe month-step keys at dashboard top-level (and budget), not pane mode keys. Pane mode cycling is `<`/`>` in `scopeDashboardFocused`.

### Tests

- `widget_test.go` — pane initialization, mode bounds, custom slot activation/inactive behavior, extensibility invariants
- `widget_test.go` — custom mode with empty `ViewType` inherits pane's primary chart type
- `render_test.go` — 2x2 layout dimensions at various terminal widths; narrow fallback triggers below 80 cols; focus state rendering (accent border)
- `render_test.go` — summary header strip renders all KPIs scoped to timeframe + accounts
- `update_dashboard_test.go` — focus via jump mode, mode cycling wraps around (curated + custom), scroll within pane, ESC unfocuses
- `update_dashboard_test.go` — drill-down composes correct expression with timeframe bounds, switches to Manager, sets `drillReturn`
- `update_dashboard_test.go` — drill-return: ESC in Manager returns to dashboard with restored pane/mode/scroll; tab-switch clears `drillReturn`
- `dashboard_test.go` — default scope uses timeframe+accounts only (not transaction/saved filters)
- `dashboard_test.go` — custom mode filter composes via AST-equivalent of `dashboard_scope AND custom_expr` (no string-concat precedence bugs)
- `config_test.go` — optional persisted custom slot metadata strict-validates when present; invalid expr entries rejected

### Acceptance

- [ ] Dashboard retains existing top sections and adds lower 2x2 analytics grid
- [ ] Date Range is a jump-focusable pane (`d`); retained top non-date sections are non-focusable
- [ ] Dashboard jump targets include `d` + `n`/`c`/`b`/`h`
- [ ] `[`/`]` month-step timeframe works from dashboard top-level and budget without prior focus bootstrap
- [ ] `0` resets timeframe to This month (current calendar month)
- [ ] Focused pane mode cycling uses `<`/`>`, not `[`/`]`
- [ ] Drill-down (`Enter`) uses mode/row predicate contract and opens Manager with composed timeframe filter
- [ ] ESC from drill context returns to dashboard and restores pane/mode/scroll and prior Manager filter state
- [ ] Non-ESC Manager navigation clears drill return context
- [ ] Custom mode slot architecture exists for all panes; v1 activation is Net/Cashflow only
- [ ] Custom mode authoring occurs in-dashboard via modal picker flow
- [ ] Default pane metrics remain scoped to timeframe + accounts only

---

## Phase 7: Interaction Contract Layer (v0.39 hardening)

Phase 7 is a pre-release hardening phase that formalizes the interaction
contracts bootstrapped in v0.32.3 (shared dispatch table, modal text
contracts, form helpers) into a full contract-driven system. It runs after
all feature phases (1-6) are complete and before final v0.4 acceptance.

**Foundation already shipped (v0.32.3):**
- Shared dispatch table in `dispatch.go` (`overlayPrecedence()`,
  `dispatchOverlayKey()`, `activeOverlayScope()`)
- Modal text input contracts (`modalTextContracts` map)
- Reusable form helpers (`textField`, `modalFormNav`)
- Footer bug fixes (rule editor, detail modal, manager modal)
- Cursor-aware upgrades (manager modal, detail notes)

**Design notes:**

This phase does NOT introduce a new abstraction layer or framework. It extends
the existing dispatch table pattern to cover interaction *intents* — the
semantic meaning of what each key does in each context — so that footer hints,
handler behavior, and test assertions can all derive from the same data.

The two primary regression patterns this addresses:
1. **New modals not getting cursor-aware text input** — solved by requiring a
   `modalTextContracts` entry for every modal with text fields (already
   enforced by tests).
2. **New forms getting inconsistent save/cancel semantics** — solved by
   declaring intent semantics per context and validating handler behavior
   against declared intents.

### Interaction intent types

```go
type InteractionIntent string

const (
    IntentMovePrev   InteractionIntent = "move_prev"
    IntentMoveNext   InteractionIntent = "move_next"
    IntentSelect     InteractionIntent = "select"
    IntentToggle     InteractionIntent = "toggle"
    IntentEdit       InteractionIntent = "edit"
    IntentConfirm    InteractionIntent = "confirm"
    IntentSave       InteractionIntent = "save"
    IntentCancel     InteractionIntent = "cancel"
    IntentDelete     InteractionIntent = "delete"
    IntentApply      InteractionIntent = "apply"
)
```

### Contract type

```go
type InteractionHint struct {
    Intent InteractionIntent
    Label  string   // footer display text (e.g. "save", "toggle", "pick")
    Omit   bool     // true = intent exists but should not show in footer
}

type InteractionContract struct {
    Scope string
    Kind  ContextKind  // list, form, viewer, workflow, inline_edit
    Hints []InteractionHint
}
```

### Context kinds

Define context kinds with default intent semantics:
- `ContextList` — pickers, file lists, command palette. Default: `enter=select`,
  `esc=cancel`, arrows move.
- `ContextForm` — manager modal, rule editor, filter edit, budget target
  editor. Default: `enter=confirm step`, `esc=cancel`, tab cycles fields.
  Modal forms have explicit open/close; inline forms have in-place semantics.
- `ContextViewer` — detail view (non-editing), dry-run results. Default:
  `esc=close`, arrows scroll.
- `ContextWorkflow` — import dupe/preview, multi-step processes. Default:
  intent-specific branch keys declared explicitly.
- `ContextInlineEdit` — dashboard custom input, settings inline editors.
  Default: printable text first, `enter=apply`, `esc=cancel`.

### Contract resolver

```go
// activeInteractionContract returns the contract for the current UI state.
// Uses the existing dispatch table to determine active scope, then looks up
// the contract for that scope.
func (m model) activeInteractionContract() InteractionContract { ... }
```

### Footer rendering migration

Replace the current `footerBindings()` → `HelpBindings()` pipeline with
contract-driven rendering:

```go
func renderFooterFromContract(contract InteractionContract, keys *KeyRegistry) string {
    // For each non-omitted hint in contract:
    //   look up the key bound to the intent's action in the contract's scope
    //   render "key label" pairs
}
```

This is an incremental migration: contexts can be moved to contract-driven
footer rendering one at a time. The dispatch table and `activeOverlayScope()`
continue to work regardless.

### Confirm vs Save vs Apply semantics

Explicit rules:
- **Confirm** (`IntentConfirm`): accept current step/item without persisting.
  Used by: rule editor step advance, picker selection.
- **Save** (`IntentSave`): persist changes to database/config. Used by:
  manager modal save, settings editor save, filter edit save.
- **Apply** (`IntentApply`): execute transformation without entering edit mode.
  Used by: category picker apply, tag picker apply, rules dry-run apply.

If a context mutates persistent state, its contract must declare whether
`IntentConfirm` implies `IntentSave`. Footer hints must distinguish these.

### Model changes

```go
// New fields in global model (Phase 7 additions)
// None required for contract types — contracts are computed from existing
// state by activeInteractionContract(). Contract types and the resolver
// live in dispatch.go alongside the existing dispatch table.
```

### Files changed

- `dispatch.go` — `InteractionIntent`, `InteractionHint`, `InteractionContract`,
  `ContextKind` types; `interactionContracts` map or per-scope contract
  declarations; `activeInteractionContract()` resolver;
  `renderFooterFromContract()` helper
- `app.go` — `footerBindings()` migrated to call `renderFooterFromContract()`
  (incremental: one context at a time)
- `render.go` — footer rendering updated to accept contract-derived hints
- `keys.go` — action-to-intent mapping helpers (optional; may live in
  `dispatch.go`)

### Tests

- `dispatch_test.go` — every scope in overlay table has a registered contract
- `dispatch_test.go` — contract intent-to-key mapping: every non-omitted
  intent has a bound key in its scope
- `dispatch_test.go` — contract kind defaults: list contexts declare
  move/select/cancel; form contexts declare confirm/cancel; etc.
- `dispatch_test.go` — footer rendering from contract produces expected
  hint strings for sample contracts
- `flow_test.go` — handler behavior matches declared intents: for each
  context, simulate the key mapped to each intent and verify the handler
  produces the expected state change
- `flow_test.go` — confirm-implies-save contexts: verify that confirm action
  persists data (DB row check)

### Acceptance

- [ ] Every overlay and tab scope has a registered `InteractionContract`
- [ ] Footer hints in all contexts are generated from contract data (no more
      manual hint strings in render functions)
- [ ] Contract intents map to valid keys in `KeyRegistry` for every scope
- [ ] Test matrix validates handler behavior against declared intents for
      all reachable states
- [ ] `IntentConfirm` vs `IntentSave` distinction is explicit in all form
      contexts that persist data
- [ ] All `modalTextContracts` entries have corresponding
      `InteractionContract` entries with compatible intent declarations
- [ ] No regression in existing UI behavior (all Phase 1-6 acceptance
      criteria still pass)
- [ ] Footer rendering migration is complete for all contexts (no mixed
      manual/contract-driven footers)

---

## Phase Summary & Dependencies

```
Phase 1: Command System Overhaul + Jump Mode (v0.31)
    │
    ├── Phase 2: Filter System (v0.32)
    │       │
    │       ├── Phase 3: Rules Engine v2 (v0.33)   [needs Phase 2 filter language]
    │       │       │
    │       │       └── Phase 4: Import Preview (v0.34)  [needs Phase 3 rules for post-rules preview]
    │       │
    │       └── Phase 5: Budgeting System (v0.35)   [needs Phase 2 for target filters]
    │               │
    │               └── Phase 6: Dashboard v2 (v0.36+)  [needs Phase 1 jump mode + Phase 2 + Phase 5]
    │
    └── Phase 7: Interaction Contract Layer (v0.39)  [needs all Phases 1-6 complete]
```

**Critical path:** Phase 1 → Phase 2 → Phase 3 → Phase 4 (serial).
**Parallel after Phase 2:** Phase 3 and Phase 5 can proceed in parallel once Phase 2 lands. Checkpoint tags may interleave across these streams only when dependency gates are satisfied and each checkpoint remains user-stable.
**Phase 6 requires:** Phase 1 (jump mode infrastructure for pane focus), Phase 2 (filter infra + strict parser + custom mode types), and Phase 5 (budget data for Budget Health pane).
**Phase 7 requires:** All feature phases (1-6) complete. It is a hardening phase that formalizes interaction contracts across the full v0.4 surface area. Foundation code (dispatch table, text contracts, form helpers) was shipped in v0.32.3.
**Phase 1 ships jump mode infrastructure** with Manager + Settings targets. Dashboard and Budget targets are registered in Phase 6 and Phase 5 respectively.
**Migration timing:** schema v5 migration ships with the first checkpoint that includes Phase 3 DB changes (preferred: v0.33.x). Budget tables are already present by schema v6; Phase 5 primarily ships Budget UI/behavior and computation contracts.

---

## Release Train, Tag Granularity, and Stability Gates

v0.4 scope is intentionally ambitious and is not reduced. Delivery is decomposed into smaller stable checkpoints.

**Version model:**
- Phase labels (`v0.31`, `v0.32`, `v0.33`, `v0.34`, `v0.35`, `v0.36+`, `v0.39`) are **phase anchors**, not the only shippable tags.
- Stable checkpoint tags use patch suffixes: `v0.31.x`, `v0.32.x`, `v0.33.x`, `v0.34.x`, `v0.35.x`, `v0.36.x`, `v0.37.x`, `v0.38.x` as needed.
- `v0.39` is reserved for stringent user testing and hardening before final acceptance.
- `v0.4` is the final acceptance release.

**Checkpoint intent:**
- Checkpoints are additive and must not reduce phase ambition or remove planned v0.4 outcomes.
- Each checkpoint must be validatable and relatively bug-free for existing users, even if not feature-complete for final v0.4.
- DB-affecting checkpoints must include migration/idempotency notes in release notes.

**Suggested checkpoint allocation (guidance):**
- `v0.31.x`: command routing foundation, jump infrastructure, scope conflict tests.
- `v0.32.x`: filter parser/evaluator, strict/permissive behavior, saved filters/config validation.
- `v0.33.x`: rules_v2 schema + CRUD + dry-run/apply + editor stabilization.
- `v0.34.x`: import preview + post-rules parity.
- `v0.35.x`: budgeting compute paths, offset integrity workflows, budget views.
- `v0.36.x`–`v0.38.x`: dashboard widget/mode system, drill-return lifecycle, layout polish.
- `v0.39`: Phase 7 interaction contract layer, UAT, regression closure, performance tuning, release docs.

---

## Schema v5 Migration Plan

Migration from schema v4 to v5 in a single `migrateFromV4ToV5(db)`:

```sql
-- 1. Drop v1 rules (fresh start)
DROP TABLE IF EXISTS category_rules;
DROP TABLE IF EXISTS tag_rules;

-- 2. Create rules_v2
CREATE TABLE rules_v2 ( ... );  -- as specified in Phase 3

-- 3. Create budget tables
CREATE TABLE category_budgets ( ... );       -- Phase 5
CREATE TABLE category_budget_overrides ( ... );
CREATE TABLE spending_targets ( ... );
CREATE TABLE spending_target_overrides ( ... );
CREATE TABLE credit_offsets ( ... CHECK(amount > 0) ... CHECK(credit_txn_id != debit_txn_id) ... );

-- 4. Seed zero budgets for existing categories
INSERT INTO category_budgets (category_id, amount)
SELECT c.id, 0
FROM categories c
WHERE NOT EXISTS (
    SELECT 1 FROM category_budgets b WHERE b.category_id = c.id
);

-- 5. Create indexes
CREATE INDEX IF NOT EXISTS idx_rules_v2_sort ON rules_v2(sort_order);
CREATE INDEX IF NOT EXISTS idx_category_budgets_cat ON category_budgets(category_id);
CREATE INDEX IF NOT EXISTS idx_credit_offsets_debit ON credit_offsets(debit_txn_id);
CREATE INDEX IF NOT EXISTS idx_credit_offsets_credit ON credit_offsets(credit_txn_id);

-- 6. Update schema version
UPDATE schema_meta SET version = 5;
```

**Preserved data:** transactions, categories, tags, transaction_tags, accounts, account_selection, imports.
**Dropped data:** category_rules, tag_rules (fresh start for rules v2).
**Behavioral guarantee:** migration must be idempotent and safe if run on partially-upgraded/dev DBs.

Operational safeguards:
- Each create/drop/index statement uses defensive `IF EXISTS`/`IF NOT EXISTS` forms where possible.
- Seed steps are conflict-safe and retry-safe (missing rows inserted, existing rows preserved).
- Migration runs in a transaction; any failure rolls back all schema/data changes.
- `schema_meta.version = 5` is written only after all preceding steps succeed.
- Migration function tolerates partially-upgraded dev DBs (missing old tables, already-created new tables, partially-created indexes).

Migration test matrix:
- Fresh database bootstrap to v5.
- Existing v4 production-shaped DB migration to v5.
- Partially-upgraded DB fixture migration retry to v5 (idempotency path).

---

## File Organization

### New files

| File | Responsibility |
|---|---|
| `filter.go` | Filter expression AST, parser, evaluator, serializer |
| `budget.go` | Budget computation logic, period helpers, budget line calculation |
| `widget.go` | Dashboard widget types, mode definitions, constructors |
| `update_budget.go` | Budget tab key handlers (table view + planner view) |

### Modified files

| File | Changes |
|---|---|
| `app.go` | New model fields (filter, rules, budget, widget state); 4-tab structure; `buildTransactionFilter()` + `buildDashboardScopeFilter()` |
| `commands.go` | Expanded registry (~30+ commands); `ExecuteByID`; scope-aware lookup |
| `keys.go` | `Binding.CommandID`; new scopes for budget, import preview, dashboard focus |
| `db.go` | Schema v5; rules_v2 CRUD; budget CRUD; credit offset CRUD; migration |
| `ingest.go` | Enhanced `scanDupesCmd` (returns rows); `applyRulesV2ToScope`/`applyRulesV2ToTxnIDs`; simulated rule preview |
| `config.go` | `savedFilter` + `customPaneMode` types; load/save/validate; strict expression validation at load |
| `render.go` | Filter pill; rule list/editor/dry-run; import preview; budget views; dashboard grid |
| `update.go` | Command-based dispatch for user-visible actions; jump mode overlay dispatch |
| `update_transactions.go` | Filter input mode; remove category filter shortcut |
| `update_settings.go` | Rules v2 editor; enable/disable; reorder |
| `update_detail.go` | Credit offset linking |
| `update_dashboard.go` | Pane focus interactions; mode cycling; drill-down with return context |
| `update_manager.go` | Minor: command routing |

### Estimated scope

~4,000–5,000 new/modified lines of application code, ~2,000–3,000 lines of tests.

## Config Compatibility

Saved filters and dashboard custom modes live in `~/.config/jaskmoney/config.toml` in v0.4.

Example mixed config:

```toml
[account.ANZ]
type = "credit"
date_format = "2006-01-02"
date_col = 1
amount_col = 2
desc_col = 3

[[saved_filter]]
name = "Groceries this month"
expr = "cat:Groceries AND date:2025-01..2025-01"

[[dashboard_view]]
pane = "net_cashflow"
name = "Renovation Spend"
expr = "tag:Renovation"
```

Compatibility rules:
- Missing `saved_filter` blocks are valid and load as an empty saved-filter list.
- Missing `dashboard_view` blocks are valid and load curated default pane modes.
- Pre-v0.4 legacy config/keybinding layouts are not supported by default in this branch; invalid or legacy files are reset to current defaults.
- Invalid saved filter expressions are rejected in strict save flows and reported with actionable errors.
- Invalid `saved_filter.expr` values found at startup are skipped with warnings (app continues).
- Invalid `dashboard_view.expr` values are rejected by strict parse validation.
- Invalid `dashboard_view.pane` or `dashboard_view.view_type` values are rejected per-entry with actionable warnings (app continues with remaining valid entries).

---

## Verification

For each stable checkpoint tag (e.g. `v0.31.x`):
1. `go build .` succeeds
2. `go vet ./...` clean
3. `go test ./...` all pass
4. Phase-relevant focused tests for changed subsystem pass
5. If DB-affecting: migration idempotency/retry checks pass for that checkpoint
6. Manual smoke test of checkpoint feature set passes
7. Publish checkpoint notes including known limitations and compatibility notes

For hardening release `v0.39`:
- `go test -tags flowheavy ./...` passes
- End-to-end v0.4 flow scenario passes
- Migration matrix passes (fresh bootstrap, v4 upgrade, partial-upgrade retry)
- Performance targets pass for interactive flows (especially filter typing/render responsiveness target from Phase 2)
- UAT feedback issues triaged and release blockers closed

Final `v0.4`:
- Full end-to-end test: create filter expression → save filter → create rule using filter → dry-run → apply rules → import with preview → set budget → view budget table + analytics strip → planner view → configure custom pane mode in Settings → dashboard focus via jump mode → mode cycling through curated + custom → drill-down to Manager → ESC returns to dashboard with restored state → verify prior Manager filter state restored
- All 7 phases complete with tests passing
- Phase 7: all interaction contracts registered, footer rendering fully contract-driven, intent-handler alignment tests pass
- Transactional safety checks pass (invalid credit offsets and invalid strict expressions do not produce partial writes)
- `go run . -validate` still works (non-TUI path)
