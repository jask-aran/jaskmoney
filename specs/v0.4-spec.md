# Jaskmoney v0.4 Spec & Implementation Plan

## Table of Contents

- [Context](#context)
  - [Current State (v0.3)](#current-state-v03)
  - [Target State (v0.4)](#target-state-v04)
  - [Data Migration Policy](#data-migration-policy)
  - [Behavioral Breaking Changes from v0.3](#behavioral-breaking-changes-from-v03)
- [Phase 1: Command System Overhaul (v0.31)](#phase-1-command-system-overhaul-v031)
  - [Command struct changes](#command-struct-changes)
  - [KeyRegistry integration](#keyregistry-integration)
  - [New commands to register](#new-commands-to-register)
  - [App-wide jump mode](#app-wide-jump-mode)
  - [Refactoring approach](#refactoring-approach)
  - [Command shape constraints (v0.4)](#command-shape-constraints-v04)
  - [Files changed](#files-changed)
  - [Tests](#tests)
  - [Acceptance](#acceptance)
- [Phase 2: Filter System Overhaul (v0.32)](#phase-2-filter-system-overhaul-v032)
  - [Filter expression language](#filter-expression-language)
  - [AST representation](#ast-representation)
  - [Integration with existing filter pipeline](#integration-with-existing-filter-pipeline)
  - [Strict filter builder surfaces](#strict-filter-builder-surfaces)
  - [Parser edge-case contract](#parser-edge-case-contract-must-be-covered)
  - [Saved filters](#saved-filters)
  - [New model fields](#new-model-fields)
  - [Saved filter commands](#saved-filter-commands)
  - [UI changes](#ui-changes)
  - [Commands](#commands)
  - [Files changed](#files-changed-1)
  - [Tests](#tests-1)
  - [Acceptance](#acceptance-1)
- [Phase 3: Rules Engine v2 (v0.33)](#phase-3-rules-engine-v2-v033)
  - [Schema changes (part of v4 → v5 migration)](#schema-changes-part-of-v4--v5-migration)
  - [Go types](#go-types)
  - [Rule application semantics](#rule-application-semantics)
  - [Dry-run command](#dry-run-command)
  - [Settings UI](#settings-ui)
  - [Model changes](#model-changes)
  - [Commands](#commands-1)
  - [DB functions](#db-functions)
  - [Import integration](#import-integration)
  - [Files changed](#files-changed-2)
  - [Tests](#tests-2)
  - [Acceptance](#acceptance-2)
- [Phase 4: Import Preview Integration (v0.34)](#phase-4-import-preview-integration-v034)
  - [Combined import preview modal](#combined-import-preview-modal)
  - [Post-rules preview](#post-rules-preview)
  - [Model changes](#model-changes-1)
  - [Flow change](#flow-change)
  - [Commands](#commands-2)
  - [Files changed](#files-changed-3)
  - [Tests](#tests-3)
  - [Acceptance](#acceptance-3)
- [Phase 5: Budgeting System (v0.35)](#phase-5-budgeting-system-v035)
  - [Schema Data Baseline (Runtime v6)](#schema-data-baseline-runtime-v6)
  - [Go types](#go-types-1)
  - [Budget calculation](#budget-calculation)
  - [Tab structure](#tab-structure)
  - [Budget tab views](#budget-tab-views)
  - [Credit offset flow](#credit-offset-flow)
  - [Credit offset integrity rules](#credit-offset-integrity-rules)
  - [Model changes](#model-changes-2)
  - [Commands](#commands-3)
  - [DB functions](#db-functions-1)
  - [Files changed](#files-changed-4)
  - [Tests](#tests-4)
  - [Acceptance](#acceptance-4)
- [Phase 6: Dashboard v2 (v0.36+)](#phase-6-dashboard-v2-v036)
  - [Dashboard visual structure](#dashboard-visual-structure)
  - [Widget primitive](#widget-primitive)
  - [Canonical 4-pane layout (v0.4)](#canonical-4-pane-layout-v04)
  - [Pane mode definitions (domain-first)](#pane-mode-definitions-domain-first)
  - [Custom mode slots](#custom-mode-slots)
  - [Fixed layout](#fixed-layout)
  - [Focus model](#focus-model)
  - [Model changes](#model-changes-3)
  - [Drill-down with return context](#drill-down-with-return-context)
  - [Analytics scope](#analytics-scope)
  - [Commands](#commands-4)
  - [Files changed](#files-changed-5)
  - [Tests](#tests-5)
  - [Acceptance](#acceptance-5)
- [Phase 7: Interaction Contract Layer (v0.39 hardening)](#phase-7-interaction-contract-layer-v039-hardening)
  - [Interaction intent types](#interaction-intent-types)
  - [Contract type](#contract-type)
  - [Context kinds](#context-kinds)
  - [Contract resolver](#contract-resolver)
  - [Footer rendering migration](#footer-rendering-migration)
  - [Confirm vs Save vs Apply semantics](#confirm-vs-save-vs-apply-semantics)
  - [Model changes](#model-changes-4)
  - [Files changed](#files-changed-6)
  - [Tests](#tests-6)
  - [Acceptance](#acceptance-6)
- [Phase Summary & Dependencies](#phase-summary--dependencies)
- [Release Train, Tag Granularity, and Stability Gates](#release-train-tag-granularity-and-stability-gates)
- [Schema v5 Migration Plan](#schema-v5-migration-plan)
- [File Organization](#file-organization)
  - [New files](#new-files)
  - [Modified files](#modified-files)
  - [Estimated scope](#estimated-scope)
- [Config Compatibility](#config-compatibility)
- [Verification](#verification)

---

## Context

v0.3 delivered accounts, tags, bulk selection, fuzzy pickers, a command palette/colon system, dashboard timeframe chips, and a keybinding registry (~19,500 LOC across 35 files). v0.4 is a major release that overhauls three foundational systems — commands, filtering, and rules — and adds budgeting and a dashboard v2 with focusable widget panes. The goal is to transform jaskmoney from a categorization-focused tracker into a full budgeting and analytics platform.

### Current State (v0.3)

- 3-tab TUI: Manager (accounts + transactions), Dashboard, Settings
- Schema v4: categories, category_rules, tags, tag_rules, transaction_tags, accounts, account_selection, transactions, imports
- Command palette (Ctrl+K) + colon mode (:) with 11 commands
- Keybinding registry with scoped lookups
- Fuzzy picker powering category picker, tag picker, command palette
- Bulk selection with shift-range highlighting
- Dashboard: timeframe chips, summary cards, spending tracker (braille chart), category breakdown
- Filter: text search (`/`), category filter (`f`), account filter (Manager scope)
- Import: file picker → dupe scan → dupe modal (A/S/C) → ingest + rule application

### Target State (v0.4)

- Commands as first-class action primitives for user-visible actions; universal primitives and cursor/input plumbing remain direct handlers
- Unified filter expression language powering search, rules, and advanced budget targets
- Rules v2: ordered, enable/disable, multi-field matching via filter expressions, set category + tags
- Import preview: combined dupe summary modal with optional full-view toggle
- 4-tab TUI: Dashboard, **Budget**, Manager, Settings
- Budget system: category budgets (recurring + overrides), advanced filter-based targets, credit offset linking
- App-wide jump mode (`v`) for spatial navigation across all tabs
- Dashboard v2: summary header strip + 4 curated panes with domain-first modes, custom mode slots from config, and drill-down to Manager with return context

### Data Migration Policy

- **All v0.3 data is preserved** (transactions, categories, tags, accounts, imports)
- **Rules v1 is a fresh start**: `category_rules` and `tag_rules` tables are dropped and replaced by `rules_v2`; users rebuild rules using the new system
- Schema version advances from 4 to 5

### Behavioral Breaking Changes from v0.3

- Tab order and number-key mapping changes from `Manager/Dashboard/Settings` (`1`/`2`/`3`) to `Dashboard/Budget/Manager/Settings` (`1`/`2`/`3`/`4`).
- Default landing tab changes from Manager to Dashboard.
- Category filter shortcut (`f`) is removed in favor of unified filter input (`/` with `cat:...` predicates).
- Navigation gains app-wide jump mode (`v`) replacing direct section-focus keys (`nav:focus-accounts`, `nav:focus-transactions`).
- Rules v1 data is intentionally dropped (fresh start for rules v2).

Required regression smoke checklist after rollout:
- Existing users can still navigate to prior core workflows (transactions table, settings import) with remapped keys.
- `v` enters jump mode and shows correct targets for the active tab.
- First launch after migration opens on Dashboard and shows expected account scope label.
- Old v0.3 DB opens without data loss in transactions/categories/tags/accounts/imports.
- Rules lists are empty after migration and rule creation flow works end-to-end.

---

## Phase 1: Command System Overhaul (v0.31)

**Goal:** Make commands the single source of user-visible actions while keeping universal primitives and cursor/input plumbing as direct handlers.

### Command struct changes

```go
type Command struct {
    ID          string
    Label       string
    Description string
    Category    string          // "Navigation", "Actions", "Filter", "Budget", etc.
    Scopes      []string        // scopes where this command is available
    Enabled     func(m model) (bool, string)
    Execute     func(m model) (model, tea.Cmd, error)
}
```

New fields:
- `Scopes []string` — declares which scopes the command is valid in (replaces implicit checks in `Enabled`). Empty = global.

### KeyRegistry integration

`Binding` gains a `CommandID` field:

```go
type Binding struct {
    Action    Action
    CommandID string   // links to Command.ID; empty for legacy/internal-only actions
    Keys      []string
    Help      string
    Scopes    []string
}
```

**Key dispatch flow change:**

Currently: `keyMsg` → scope lookup → `Action` → hand-coded switch in `updateXxx`.

New: `keyMsg` → scope lookup → `Binding.CommandID` → `CommandRegistry.Execute(id, m)` → return `(model, tea.Cmd)`.

For actions that are purely UI-internal (cursor movement, text input), the `CommandID` is empty and the existing switch dispatch is preserved. The principle: **anything that would appear in the command palette is a command; cursor/input plumbing is not**.

> **Architecture alignment:** The dispatch chain, scope hierarchy, key reuse safety rules, and conflict testing contract are defined in `specs/architecture.md` §3.4. All new scopes and bindings added in v0.4 phases must comply with the scope map (§3.4.10) and pass the key conflict testing invariants (§3.4.11). The `keybindings.toml` override format remains action-level flat maps (§3.4.7) — do not introduce per-scope TOML overrides.

Universal primitives also stay direct handlers and are intentionally not command-routed:
- `confirm` (`enter`)
- `cancel` (`esc`)
- `up` / `down` / `left` / `right`
- `delete`
- `quit`

### New commands to register

All existing keybinding-triggered actions that are user-visible become commands:

| ID | Label | Scopes |
|---|---|---|
| `nav:next-tab` | Next Tab | global |
| `nav:prev-tab` | Previous Tab | global |
| `nav:dashboard` | Go to Dashboard | global |
| `nav:manager` | Go to Manager | global |
| `nav:budget` | Go to Budget | global (registered now, disabled until Phase 5) |
| `nav:settings` | Go to Settings | global |
| `jump:activate` | Jump Mode | global |
| `jump:cancel` | Cancel Jump | jump_overlay |
| `txn:sort` | Cycle Sort Column | transactions |
| `txn:sort-dir` | Toggle Sort Direction | transactions |
| `txn:select` | Toggle Selection | transactions |
| `txn:clear-selection` | Clear Selection | transactions |
| `txn:quick-category` | Quick Categorize | transactions |
| `txn:quick-tag` | Quick Tag | transactions, manager |
| `txn:detail` | Open Detail | transactions |
| `txn:jump-top` | Jump to Top | transactions |
| `txn:jump-bottom` | Jump to Bottom | transactions |
| `filter:open` | Open Filter | transactions (registered now, wired in Phase 2) |
| `filter:clear` | Clear All Filters | transactions |
| `import:start` | Import CSV | settings |
| `rules:apply` | Apply All Rules | settings, global |
| `rules:dry-run` | Dry-Run Rules | settings, global (registered now, wired in Phase 3) |
| `settings:clear-db` | Clear Database | settings |
| `settings:nuke-account` | Nuke Account | settings (**deprecated in v0.32 follow-up; replaced by Manager `del` account-action modal**) |
| `dash:timeframe` | Focus Timeframe | dashboard |
| `dash:mode-next` | Next Widget Mode | dashboard_focused (registered now, wired in Phase 6) |
| `dash:mode-prev` | Previous Widget Mode | dashboard_focused (registered now, wired in Phase 6) |
| `dash:drill-down` | Drill Down | dashboard_focused (registered now, wired in Phase 6) |
| `palette:open` | Command Palette | global |
| `cmd:open` | Command Mode | global |

`txn:search` is removed in v0.4 spec language. `filter:open` is the canonical command ID for `/` filter input.

### App-wide jump mode

**Activation:** `v` enters jump mode globally. An overlay appears with labeled badges at each focusable section in the current tab. Pressing a target key focuses and activates that section and dismisses the overlay. `Esc` cancels jump mode and restores the previously focused widget (or unfocused state).

This replaces the v0.3 `nav:focus-accounts` / `nav:focus-transactions` commands with a spatial, discoverable navigation model inspired by Bagels (`~/bagels-ref/src/bagels/components/jumper.py`).

**Per-tab jump targets and default focus:**

| Tab | Targets | Default focus (ESC returns to) |
|---|---|---|
| Dashboard | `n` Net/Cashflow, `c` Composition, `b` Compare Bars, `h` Budget Health | Unfocused (no pane selected) |
| Manager | `a` Accounts, `t` Transactions | Transactions (default section) |
| Budget | `t` Budget Table, `p` Planner | Budget Table |
| Settings | `c` Categories, `t` Tags, `r` Rules, `f` Filters, `d` Database, `w` Dashboard Views | Stay (no default reset) |

Target keys can overlap across tabs because only targets for the active tab are shown. Dashboard and Budget pane targets are registered in their respective phases (Phase 5 / Phase 6) but the infrastructure ships here.

**Focus lifecycle:**
1. `v` -> jump overlay appears with per-tab targets
2. Press target key -> focus + activation move to that section, overlay dismisses
3. Section-specific interactions available while focused (e.g. mode cycling on dashboard, inline edit on budget)
4. `Esc` -> focus returns to tab's default (or stays, for Settings)
5. `Esc` from default/unfocused state -> no-op

Jump target registration uses a two-axis landing contract (`Section` and
`Activate`) so future tabs can opt into focus-only or focus+activate behavior
per target without changing overlay dispatch.

**Jump overlay visual:**
- Each target shows a floating badge at its top-left corner: `[n]`, `[c]`, `[b]`, `[h]`
- Badges use accent background on muted foreground
- Status bar reads: "Jump: press key to focus. ESC cancel."
- Focused sections get an accent-colored border; unfocused sections use the default muted border

**Model fields:**

```go
// Jump mode (global)
jumpModeActive    bool
jumpPreviousFocus int  // restore target on ESC from jump overlay; -1 = unfocused

// Per-tab focus
focusedSection    int  // -1 = unfocused; meaning is tab-specific
```

**Commands:**

| ID | Label | Scopes |
|---|---|---|
| `jump:activate` | Jump Mode | global |
| `jump:cancel` | Cancel Jump | jump_overlay |

### Refactoring approach

1. Add `CommandID` to `Binding` struct
2. Update `NewKeyRegistry` to set `CommandID` on all action-mapped bindings
3. Add `ExecuteByID(id string, m model) (model, tea.Cmd, error)` to `CommandRegistry`
4. In each `updateXxx` handler, replace action-switch cases with command execution for user-visible actions
5. Keep cursor/input/modal plumbing as direct action switches (no command overhead)
6. Implement jump mode infrastructure: `v` key binding, overlay rendering, per-tab target registration, focus lifecycle

### Command shape constraints (v0.4)

- Commands are **parameterless** in v0.4 (no argument parser yet).
- Registry metadata and IDs should remain future-ready for argument-bearing commands and workflows in v0.5+.

### Files changed

- `keys.go` — `Binding` gains `CommandID`; new `scopeJumpOverlay` scope; `v` binding for `jump:activate`
- `commands.go` — expanded registry, `ExecuteByID`, scope-aware availability; jump commands
- `update.go` — jump mode dispatch (overlay intercept before tab-specific handlers)
- `update_dashboard.go`, `update_transactions.go`, `update_manager.go`, `update_settings.go` — dispatch via command execution for user-visible actions
- `render.go` — `renderJumpOverlay` (badge positioning + status bar)

### Tests

- `commands_test.go` — all commands registered, `ExecuteByID` dispatches correctly, scope filtering works
- `keys_test.go` — every binding with a `CommandID` resolves to a registered command
- `keys_test.go` — global shadow audit, scope reachability, tab/jump key non-shadow (per `architecture.md` §3.4.11)
- `update_mode_test.go` — verify key presses still produce correct state changes (regression)
- `update_mode_test.go` — jump mode: `v` activates overlay, target key focuses section, ESC cancels and restores previous focus
- `update_mode_test.go` — per-tab default focus: ESC from focused section returns to tab default (Manager -> transactions, Dashboard -> unfocused, Settings -> stays)

### Acceptance

- [x] All user-visible keybinding actions route through command registry
- [x] Command palette shows all available commands for current scope
- [x] Universal primitives (`confirm`, `cancel`, arrows/`hjkl`, delete, quit) remain direct handlers
- [x] Cursor movement, text input, and modal plumbing remain as direct action handlers
- [x] `v` activates jump mode; per-tab target keys shown as floating badges
- [x] Jump target selection focuses and activates the correct section; ESC cancels and restores previous focus
- [x] Per-tab ESC behavior: Dashboard unfocuses, Manager returns to transactions, Settings stays
- [x] Jump mode infrastructure supports deferred target registration (Dashboard/Budget targets added in later phases)
- [x] Key conflict tests pass: global shadow audit, scope reachability, action-command consistency (`architecture.md` §3.4.11)
- [x] `footerBindings()` correctly reflects active scope for all model states including jump mode and focused sections
- [x] All existing tests pass; no behavior change for end users

#### Acceptance Notes
- **Accepted in `v0.31.1` on February 12, 2026.**
- Command system overhaul is considered complete for v0.31 scope: command routing, scope-aware registry execution, jump mode infrastructure, and command UI (palette + command mode) behavior are validated in tests.
- Post-Phase-1 polish included command UI rendering hardening:
  - command palette modal width expansion and per-command visual spacing
  - colon popup width unbound to viewport-safe available width
  - wrapped command descriptions rendered with explicit continuation lines
- Text-input safety was tightened for command/picker text fields so printable keys (including `j`/`k`) are literal-first while non-printable navigation remains available.
- Transaction table row-state styling regression was fixed before acceptance; cursor, selected, and highlighted states are now visually distinct again, with regression tests covering state-color separation.

---

## Phase 2: Filter System Overhaul (v0.32)

**Goal:** Replace the ad-hoc search + category filter + account filter with a unified filter expression language. The same language powers interactive search, rules (Phase 3), and advanced budget targets (Phase 5).
The v0.4 language is intentionally a Lucene-inspired subset: compact field predicates + boolean composition now, with a clear syntax-compatible path to add more Lucene-style capabilities in later versions.

### Filter expression language

**Principles:**
- Plain text typed after `/` prioritizes typing speed and low-friction querying; explicit field scoping is optional for simple queries
- Power users can add field predicates and boolean operators
- Uppercase `AND`, `OR`, `NOT` are operators; lowercase versions are search text
- Must be fast to type in a single line
- Syntax is a deliberate subset baseline (not full Lucene), chosen to keep v0.4 approachable while preserving forward compatibility for future expansion

**Grammar:**

```
expr     = or_expr
or_expr  = and_expr ( 'OR' and_expr )*
and_expr = unary ( ('AND' unary) | unary )*  // adjacent unary terms imply AND
unary    = 'NOT' unary | term
term     = '(' expr ')' | field_pred | text_search

field_pred  = field ':' value
text_search = word+                      // implicit desc:contains

field = 'desc' | 'cat' | 'tag' | 'acc'
      | 'amt'  | 'type' | 'note' | 'date'

value = comparison | number_range | date_range | date_value | quoted_string | word+
comparison  = ('<' | '>' | '<=' | '>=' | '=') number
number_range = number '..' number
number      = [+-]? ( [0-9]+ ('.' [0-9]+)? | '.' [0-9]+ )
date_range  = date_value '..' date_value
date_value  = iso_day | iso_month | yy_month
iso_day     = YYYY '-' MM '-' DD
iso_month   = YYYY '-' MM
yy_month    = YY '-' MM              // maps to 20YY-MM (e.g. 26-03 => 2026-03)
quoted_string = '"' ( '\\"' | '\\\\' | [^"] )* '"'
```

**Operator precedence:** `(` `)` > `NOT` > `AND` > `OR` (standard).

**Lexical rules:**
- `word` = run of non-whitespace characters excluding reserved delimiters/operators (`(`, `)`, `:`, `"`)
- Whitespace delimits tokens; one or more spaces are equivalent
- Adjacent terms/predicates imply `AND` (e.g. `cat:Food amt:>50`)
- Uppercase `AND`/`OR`/`NOT` are operators; lowercase forms are plain text
- `number` supports signed integer/decimal forms (e.g. `-10`, `25`, `25.50`, `0.5`, `.5`)

**Field predicates:**

| Field | Shorthand | Match behavior | Examples |
|---|---|---|---|
| `desc` | (default) | Contains, case-insensitive | `coffee`, `desc:"coffee shop"` |
| `cat` | `cat:` | Exact category name, case-insensitive | `cat:Food`, `cat:"Dining & Drinks"` |
| `tag` | `tag:` | Has tag with name, case-insensitive | `tag:Groceries`, `tag:IGNORE` |
| `acc` | `acc:` | Account name, case-insensitive | `acc:"ANZ Savings"` |
| `amt` | `amt:` | Inclusive signed comparison/range | `amt:>50`, `amt:-100..-10`, `amt:=25.50` |
| `type` | `type:` | Transaction type | `type:debit`, `type:credit` |
| `note` | `note:` | Notes contains, case-insensitive | `note:refund` |
| `date` | `date:` | Exact day (`YYYY-MM-DD`), whole-month shorthand (`YYYY-MM` or `YY-MM`), or inclusive range | `date:2025-03-15`, `date:2025-03`, `date:26-03`, `date:2025-01..2025-06` |

**Type inference for `type:` field:** `type:debit` matches `amount < 0`; `type:credit` matches `amount > 0`.

**Examples:**

```
coffee                              → desc contains "coffee"
coffee AND tea                      → desc contains "coffee" AND desc contains "tea"
coffee tea                          → desc contains "coffee" AND desc contains "tea" (implicit AND)
cat:Food                            → category is "Food"
cat:Food AND amt:>50                → category Food AND amount > 50
cat:Food amt:>50                    → category Food AND amount > 50 (implicit AND)
NOT cat:Food                        → category is NOT Food
cat:Food OR cat:Transport           → category is Food or Transport
(cat:Food OR cat:Transport) AND amt:>50  → grouped OR branch, then amount constraint
tag:Groceries AND type:debit        → has tag Groceries AND is a debit
desc:"coffee shop" AND cat:Food     → description contains "coffee shop" AND category Food
```

### AST representation

**New file: `filter.go`**

```go
type filterNodeKind int
const (
    filterNodeText filterNodeKind = iota
    filterNodeField
    filterNodeAnd
    filterNodeOr
    filterNodeNot
)

type filterNode struct {
    kind     filterNodeKind
    // Text/Field
    field    string      // "" for text search, "desc"/"cat"/etc. for field
    op       string      // "contains", "=", ">", "<", ">=", "<=", ".."
    value    string      // the raw value string
    valueLo  string      // for range: low bound
    valueHi  string      // for range: high bound
    // Boolean
    children []*filterNode // And/Or: 2+ children; Not: 1 child
}

func parseFilter(input string) (*filterNode, error)
func evalFilter(node *filterNode, t transaction, tags []tag) bool
func filterExprString(node *filterNode) string  // serialize back to text
```

`parseFilter` returns `nil` for empty input (matches everything).

Date parse semantics:
- `date:YYYY-MM-DD` is exact-day match
- `date:YYYY-MM` is full-month match (first day through last day of month)
- `date:YY-MM` is allowed and maps to `20YY-MM` with the same full-month behavior
- `date:start..end` is inclusive on both ends; each endpoint may be day or month shorthand

Parse policy is caller-owned:
- `parseFilterStrict(input)` is strict and returns errors for invalid token/shape or strict mixed-precedence ambiguity.
- `parseFilter(input)` parses the same grammar and may return parse errors; it does not perform fallback internally.
- Interactive `/` input remains **permissive** because the transaction filter input path catches parse errors and falls back to plain-text metadata search while keeping live parse feedback visible (green/red indicator).
- Persisted and mutation-driving contexts are **strict**: no fallback. Invalid expressions are blocked with actionable errors.

```go
func parseFilter(input string) (*filterNode, error)         // permissive caller policy
func parseFilterStrict(input string) (*filterNode, error)   // error on invalid token/shape or strict mixed-precedence ambiguity
```

Strict contexts in v0.4:
- Rules v2 editor (Phase 3)
- Spending target editor (Phase 5)
- Saved filter creation/update (only valid filters can be persisted)
- Dashboard custom view creation/update + config load validation (Phase 6)

**Strict complexity policy (v0.4):**
- Parentheses are optional in permissive `/` input.
- In strict contexts, expressions that mix `AND` and `OR` at the same precedence layer must include explicit grouping parentheses.
- Example strict-invalid: `cat:Food OR cat:Transport AND amt:>50`
- Example strict-valid: `(cat:Food OR cat:Transport) AND amt:>50`
- Strict parse errors include an actionable fix hint (grouped rewrite suggestion).

**Extension path (post-v0.4):**
- Treat this grammar as the stable core and extend with additional Lucene-like features only as needed (e.g. wildcard/prefix terms, fuzzy matching, proximity, boosts, unary `+`/`-` required/prohibited terms).
- Maintain backward compatibility for existing saved/rule/target expressions; new features must be additive and strict-parse validated.

### Integration with existing filter pipeline

Replace `filteredRows` signature:

```go
func filteredRows(rows []transaction, filter *filterNode, txnTags map[int][]tag, sortCol int, sortAsc bool) []transaction
```

The old `searchQuery string`, `filterCats map[int]bool`, `filterAccounts map[int]bool` parameters are replaced by a single `*filterNode`.

```go
// Transactions table: user input + account scope
func (m model) buildTransactionFilter() *filterNode

// Dashboard defaults: timeframe + account scope only (no transaction/saved filter state)
func (m model) buildDashboardScopeFilter() *filterNode

// Custom mode filter: returns the strict-parsed filter for a custom pane mode (nil for curated modes with no expression)
func (m model) buildCustomModeFilter(paneID, modeName string) *filterNode
```

`buildTransactionFilter()` composes:
1. User search/filter input (parsed from the `/` input line)
2. Account scope from `m.filterAccounts` (if set, injected as quoted/escaped account predicates: `acc:"Name 1" OR acc:"Name 2"`)

`buildDashboardScopeFilter()` composes:
1. Dashboard timeframe range
2. Account scope from `m.filterAccounts`

Dashboard default widgets **must not** inherit transaction filter input or active saved-filter state.

Composition contract:
- Internal filter composition is AST-first (`filterNodeAnd` / `filterNodeOr`), never raw string concatenation.
- Any persisted expression text is produced from AST serialization and must round-trip through strict parse.

### Strict filter builder surfaces

Rules, spending targets, and dashboard custom views use a strict builder surface. The builder supports grouped logic via structured ALL/ANY rules and emits precedence-safe expressions in the same v0.4 filter language (including parentheses when needed). Builder output is validated with `parseFilterStrict`, and save is blocked on invalid input.

Strict contexts must never fallback to plain-text matching. They always show parse errors inline and block persistence until resolved.
Persisted strict expressions are canonicalized on save/load round-trip: uppercase boolean operators plus minimal parentheses needed to preserve AST semantics.

### Parser edge-case contract (must be covered)

| Case | Input | Expected |
|---|---|---|
| Operator case-sensitivity | `coffee and tea` | Treated as plain text search terms (no boolean op) |
| Implicit AND (text) | `coffee tea` | Parsed as `coffee AND tea` |
| Implicit AND (predicates) | `cat:Food amt:>50` | Parsed as `cat:Food AND amt:>50` |
| Unary precedence | `NOT cat:Food AND tag:Work` | Parsed as `(NOT cat:Food) AND tag:Work` |
| Parenthesized grouping | `(cat:Food OR cat:Transport) AND amt:>50` | OR branch grouped before AND |
| Missing grouping in strict mode | `cat:Food OR cat:Transport AND amt:>50` | Strict parse error with grouped rewrite suggestion |
| Quoted values | `desc:"coffee shop"` | Phrase match on exact token string (case-insensitive) |
| Quoted account injection | `acc:"ANZ Savings"` | Exact account-name match after unescape |
| Single day date | `date:2025-03-15` | Matches only transactions on 2025-03-15 |
| Month shorthand date | `date:2025-03` | Expands to full month (2025-03-01..2025-03-31) |
| Two-digit month shorthand | `date:26-03` | Expands to full month (2026-03-01..2026-03-31) |
| Date range month endpoints | `date:2025-01..2025-03` | Inclusive range 2025-01-01..2025-03-31 |
| Invalid token (strict) | `cat:` | Parse error; save blocked in strict contexts |
| Invalid token (permissive `/`) | `cat:` | Fallback to permissive plain-text metadata search for `cat:` with parse feedback indicator |

### Saved filters

**Config file: `~/.config/jaskmoney/config.toml`**

```toml
[[saved_filter]]
id = "groceries_this_month"
name = "Groceries this month"
expr = "cat:Groceries AND date:2025-01..2025-01"

[[saved_filter]]
id = "large_debits"
name = "Large debits"
expr = "type:debit AND amt:<-100"
```

Saved filters are loaded alongside CSV formats in `config.go`.
At load time, each `saved_filter.expr` is strict-parsed. Invalid entries are skipped with an actionable warning while app startup continues.

```go
type savedFilter struct {
    ID   string `toml:"id"`   // stable slug key, used by apply commands
    Name string `toml:"name"`
    Expr string `toml:"expr"`
}
```

```go
// Custom dashboard mode: appears as an additional mode slot in the pane's
// mode cycle list (after all curated built-in modes). Inherits the chart
// primitive from the pane but filters data through `expr`.
type customPaneMode struct {
    Pane     string `toml:"pane"`      // pane ID, e.g. "net_cashflow"
    Name     string `toml:"name"`      // display label, e.g. "Renovation Spend"
    Expr     string `toml:"expr"`      // strict filter expression
    ViewType string `toml:"view_type"` // optional: "line"|"area"|"bar"|"pie"|"table"; defaults to pane's primary chart type
}
```

Custom pane modes are stored in `[[dashboard_view]]` blocks in `config.toml` and appear alongside built-in modes in the `[`/`]` cycle. They are validated at load time:
- `expr` must strict-parse with `parseFilterStrict`
- `pane` must match a known pane ID
- `view_type` (if provided) must be one of `line|area|bar|pie|table`

Invalid entries are rejected individually with actionable startup warnings; startup continues and other valid entries still load.

### New model fields

```go
// Filter state
filterInput      string            // raw text in the / input line
filterExpr       *filterNode       // parsed filter (nil = show all)
savedFilters     []savedFilter
customPaneModes  []customPaneMode  // loaded from config; appended to pane mode lists in Phase 6
```

Remove: `filterCategories map[int]bool` (now expressed as filter predicates). Keep `filterAccounts` on the model for Manager scope (composed into filter at build time).

### Saved filter commands

Command exposure is tiered to avoid palette flooding:

| ID | Label | Category |
|---|---|---|
| `filter:apply` | Apply Saved Filter | Filter |
| `filter:apply:<id>` | (hidden dynamic command target) | Filter |

`filter:apply` opens a searchable picker. Hidden `filter:apply:<id>` targets are executable (for command routing / future keybinding extensions) but are not shown in palette search results.

### UI changes

- `/` opens filter input (same key as current search)
- Input line shows in footer with live-parsed indicator: green dot = valid, red dot = parse error
- Active filter shown as a compact pill in the transaction table header: `[cat:Food AND amt:>50]`
- `Esc` clears filter input and resets to no filter
- `f` shortcut removed (was category filter); replaced by typing `cat:Name` in filter input
- `ctrl+l` opens the Apply Saved Filter picker (no implicit “load most recent” behavior)
- Saved-filter CRUDL is available in **Settings → Filters** with add/edit/delete list management

### Commands

| ID | Label | Scopes |
|---|---|---|
| `filter:open` | Open Filter | transactions, manager |
| `filter:clear` | Clear All Filters | transactions |
| `filter:save` | Save Current Filter | filter_input, transactions |
| `filter:apply` | Apply Saved Filter | filter_input, transactions, manager |

### Saved-filter CURDL/CURL UX (Phase 2 completion)

- Config contract for saved filters is strict: `id`, `name`, `expr` required.
- Legacy entries without `id` are dropped with startup warnings.
- Create/edit uses strict parsing and blocks invalid expressions.
- Save flow uses a modal (`ID`, `Name`, `Expr`) and blocks duplicate IDs.
- Apply flow uses picker search (`ctrl+l` / command), with exact `apply:<id>` typed command routing in colon mode.
- Recency ordering (recently applied/created/modified first) is shared across Settings list and apply picker.
- Mutable recency state is stored in DB app-state table(s), while filter definitions remain in config.

### Phase 2 hardening note (completed)

Keybinding materialization no longer performs silent auto-reassignment for
manager quick-tag conflicts. Startup now fails explicitly with actionable
conflict guidance, preserving user intent.

### Files changed

- **New:** `filter.go` — AST, parser, evaluator, serializer
- `app.go` — new model fields, `buildTransactionFilter()`, `buildDashboardScopeFilter()`, updated `filteredRows` signature
- `config.go` — `savedFilter` + `customPaneMode` types, load/save, strict validation at load (invalid saved filters skipped with warning; invalid custom modes rejected)
- `update_transactions.go` — new filter input mode replacing search + category filter
- `render.go` — filter pill in header, input indicator
- `commands.go` — filter commands + dynamic saved filter commands
- `keys.go` — remove `actionFilterCategory`, update `actionSearch` to `filter:open`

### Tests

- `filter_test.go` — parser: plain text, field predicates, implicit AND adjacency, parentheses grouping, AND/OR/NOT, ranges, quoted strings, error fallback to text search. Evaluator: all field types, boolean combinations, edge cases (nil category, nil account, empty tags).
- `config_test.go` — saved filter load/save round-trip; invalid saved filters skipped with warning; custom pane mode load with strict validation (invalid expr rejected)
- `app_test.go` / `update_mode_test.go` — filter input opens, parses, filters rows, Esc clears, saved filter apply
- `model_test.go` — rules/targets/saved-filter editors reject invalid expressions (strict mode)
- `filter_test.go` — strict parser never falls back to text for invalid expressions; strict mixed `AND`/`OR` without grouping is rejected with actionable hint; serializer emits canonical uppercase ops + minimal required parentheses

### Acceptance

- [x] `/` opens filter input.
- [x] Plain-text query path is fast and permissive by design; explicit field scoping is optional for simple queries.
- [x] Field predicates filter correctly: `cat:`, `tag:`, `acc:`, `amt:`, `type:`, `note:`, `date:`.
- [x] Parentheses grouping parses/evaluates correctly (including nested groups).
- [x] Adjacent terms/predicates imply `AND` (fast typing path).
- [x] `AND`, `OR`, `NOT` (uppercase) combine predicates; lowercase treated as text.
- [x] Active filter shown as pill in table header.
- [x] Saved filters persist in config and appear as commands in palette.
- [x] Save/load workflow is available post-apply and accessible in filter and transaction interaction paths (`ctrl+s`/`ctrl+l`).
- [x] Invalid saved filters in config are skipped at startup with actionable warnings (startup continues).
- [x] `/` remains permissive on parse errors with active parse feedback; rules/targets/saved-filter persistence is strict.
- [x] Strict contexts never fallback to permissive text matching; invalid expressions are blocked with actionable errors.
- [x] Strict contexts reject mixed `AND`/`OR` without explicit grouping parentheses, with actionable rewrite hints.
- [x] `f` shortcut removed; category filtering via `cat:Name` in filter input.
- [x] Account scope from Manager still works (composed into filter).
- [x] Dashboard defaults use timeframe + account scope only; transaction/saved filter state does not alter default dashboard metrics.
- [x] Custom pane modes load from `[[dashboard_view]]` config; invalid expressions rejected at load time with errors.
- [x] Persisted strict expressions round-trip through canonical serialization (uppercase ops + minimal required parentheses).
- [x] Behavior-validating regression guards cover input text safety (printable/global keys remain text while filter input is active).
- [x] Field-predicate input/editing flow is usable from filter input.
- [x] Account action modal (`del` => clear txns / nuke account) implemented.
- [x] Account chips show txn count / `Empty`.
- [x] DB bootstrap recreates missing DB path/schema.
- [x] Filter typing/apply responsiveness is release-acceptable for interactive use in v0.32.2f (no known blocking latency regressions in shipped flows).
- [x] Saved-filter CURDL/CURL redesign is fully specified and implemented (settings CRUDL, picker apply flow, strict `id` contract, typed `apply:<id>` routing).
- [x] Keybinding materialization no longer performs silent auto-reassignment for manager quick-tag conflicts; conflicts fail explicitly with actionable guidance.

### Overall acceptance gate (Phase 2)

Phase 2 is sign-off ready only when all acceptance bullets above are satisfied
and the following release checks are green for the checkpoint:

- `go test ./...`
- `go test -tags flowheavy ./...`
- `go run . -startup-check`
- No known critical regressions in filter-input text safety, command scoping, or
  account-scope composition behavior

#### Acceptance status snapshot (v0.32.2f)

Snapshot recorded on `v0.32.2f` (February 14, 2026) after completion of the
saved-filter UX overhaul and hardening pass.

- [x] Filter input text-entry safety is preserved (printable keys are literal while editing).
- [x] `ctrl+s` opens save modal; strict validation blocks invalid/duplicate saves.
- [x] New saved filters default to auto-generated IDs (`filter-1`, `filter-2`, ...) with blank name.
- [x] Saved-filter CRUDL is available in Settings → Filters (add/edit/delete/list).
- [x] Apply flow is tiered: `filter:apply` picker + hidden `filter:apply:<id>` command targets.
- [x] Colon typed routing supports exact `apply:<id>`.
- [x] Apply picker search covers both ID and name content.
- [x] Apply picker row width is viewport-safe (long metadata no border overflow).
- [x] Apply picker respects recency ordering and persists via DB-backed usage state.
- [x] `ctrl+l` works from transactions, filter input, and manager accounts scope.

---

## Phase 3: Rules Engine v2 (v0.33)

**Goal:** Replace v1 category_rules + tag_rules with a unified rules system.
**v0.32.2 implementation update:** rules reference existing saved filters by ID (instead of storing inline rule expressions), rule actions are category + add-tags only (no remove-tags), and rule editor category/tag selection uses modal-on-modal picker reuse.

### Schema changes (part of v4 → v5 migration)

```sql
-- Drop v1 rules (fresh start; users rebuild)
DROP TABLE IF EXISTS category_rules;
DROP TABLE IF EXISTS tag_rules;

CREATE TABLE rules_v2 (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    name            TEXT NOT NULL,
    saved_filter_id TEXT NOT NULL,
    set_category_id INTEGER REFERENCES categories(id) ON DELETE SET NULL,
    add_tag_ids     TEXT NOT NULL DEFAULT '[]',    -- JSON array of tag IDs
    sort_order      INTEGER NOT NULL DEFAULT 0,
    enabled         INTEGER NOT NULL DEFAULT 1,
    created_at      TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_rules_v2_sort ON rules_v2(sort_order);
```

**Design notes:**
- `saved_filter_id` references a configured saved filter (`saved_filter.id`)
- `set_category_id` is nullable: if NULL, the rule does not change category
- `add_tag_ids` is a JSON array of tag IDs (Go `[]int` serialized)
- `sort_order` determines manual ordering; lower = evaluated first
- `enabled = 0` means the rule is skipped everywhere (apply + dry-run) but shown in Settings list as dimmed
- If a rule references a missing/invalid saved filter, that rule is skipped during apply/dry-run/import and counted as a failed rule in summaries

### Go types

```go
type ruleV2 struct {
    id            int
    name          string
    savedFilterID string
    setCategoryID *int
    addTagIDs     []int
    sortOrder     int
    enabled       bool
}
```

### Rule application semantics

**All matching rules apply in list order (sort_order ascending):**

1. Iterate rules in order
2. For each enabled rule, resolve the saved filter expression and evaluate it against the transaction
3. If matched:
   - If `set_category_id != nil`, set the transaction's category (last writer wins)
   - If `add_tag_ids` is non-empty, add those tags (accumulative)
4. After all rules, write final category + tags to DB

`rules:apply` executes inside one DB transaction for the full target set. If any write/validation fails, the full apply run rolls back (no partial category/tag updates).

Tag policy:
- Rule effects are applied strictly in `sort_order`.
- Tags are add-only in rules v2 UI/engine.

**Target set and scope (explicit):**
- Rule matching semantics remain broad: rules can match categorized and uncategorized transactions.
- `rules:apply` resolves scope from `m.filterAccounts` regardless of active tab: non-empty map = scoped run; empty map = all transactions.
- `rules:dry-run` uses the same target set as `rules:apply`.
- Import-time rule application targets **newly imported rows only** for that import operation.

### Dry-run command

Command `rules:dry-run` evaluates all enabled rules against the current `rules:apply` target set (respecting current account scope) without writing. Output is a modal showing:

```
Dry-Run Results
═══════════════

Rule 1: "Grocery stores" (enabled)
  Filter: desc:countdown OR desc:woolworths OR desc:coles
  Matches: 47 transactions
  Actions: → Groceries, +tag:Weekly
  Samples:
    2025-01-15  -$42.50  COUNTDOWN METRO    (currently: Uncategorised)
    2025-01-18  -$87.20  WOOLWORTHS 1234    (currently: Uncategorised)
    2025-01-20  -$23.10  COLES EXPRESS      (currently: Food → Groceries)

Rule 2: "Ignore transfers" (enabled)
  Filter: cat:Transfers
  Matches: 12 transactions
  Actions: +tag:IGNORE
  Samples:
    2025-01-10  -$500.00  TRANSFER TO SAV   (currently: Transfers)
    ...

Summary: 59 transactions would be modified
         23 category changes, 59 tag changes, 1 failed rules
```

Sample rows capped at 3 per rule. Modal is scrollable.
Dry-run/apply surfaces must show the effective account scope label (`All Accounts` or `N selected accounts`) so scope-sensitive runs are explicit.

### Settings UI

Rules section in Settings is overhauled:

**List view:**
```
Rules
─────
  1. ✓ Grocery stores     desc:countdown OR desc:woolworths → Groceries +Weekly
  2. ✓ Ignore transfers   cat:Transfers → +IGNORE
  3. ✗ Old rent rule      desc:rent AND amt:<-1000 → Bills (disabled)
```

- Checkmark/cross shows enabled state
- Dimmed rendering for disabled rules
- Broken filter references render in red
- Rows show explicit list index for ordering clarity

**Interactions:**
- `a` — add new rule (opens rule editor)
- `Enter` — edit rule
- `Del` — delete rule (with confirm)
- `Space` — toggle enable/disable
- `K` / `J` (shift+k/j) — move rule up/down in order
- `A` — apply all rules
- `D` — dry-run

**Rule editor modal:**

Multi-step inline editor:
1. **Name** — text input
2. **Saved filter** — select from existing saved filters (modal picker); save blocked if missing/invalid
3. **Set category** — optional quick-category picker overlay (skip with "No category change")
4. **Add tags** — optional quick-tag picker overlay (add-only toggle, no remove mode)
5. **Enabled** — toggle (default: yes)

Navigation: `↑/↓`, `Ctrl+P/N`, and `Tab`/`Shift+Tab` between fields. `Enter` opens picker or saves on final step. `Esc` cancels.

Universal modal safety rule: if a modal has any text-editable field, `h/j/k/l`
must not be interpreted as navigation (even under custom keybinding overrides).
Only arrows, `Tab`/`Shift+Tab`, and `Ctrl+P/N` are valid modal-nav keys in
those contexts. This is enforced by the `modalTextContracts` entry for
`scopeRuleEditor` (see `dispatch.go` and `architecture.md` §3.3). Use
`textField` for the name and filter expression fields and `modalFormNav` for
inter-step navigation.

### Model changes

```go
// Replace old fields
rules    []ruleV2       // was: []categoryRule
// Remove:
// tagRules []tagRule    // absorbed into rules_v2

// Rule editor state
ruleEditorOpen    bool
ruleEditorStep    int      // 0=name, 1=savedFilter, 2=category, 3=addTags, 4=enabled
ruleEditorID      int      // 0 = new, >0 = editing
ruleEditorName    string
ruleEditorFilterID string
ruleEditorCatID   *int
ruleEditorAddTags []int
ruleEditorEnabled bool

// Dry-run state
dryRunOpen    bool
dryRunResults []dryRunRuleResult
dryRunSummary dryRunSummary
dryRunScroll  int
```

```go
type dryRunRuleResult struct {
    rule       ruleV2
    matchCount int
    catChanges int
    tagChanges int
    samples    []dryRunSample // max 3
}

type dryRunSample struct {
    txn         transaction
    currentCat  string
    newCat      string
    addedTags   []string
    removedTags []string
}

type dryRunSummary struct {
    totalModified  int
    totalCatChange int
    totalTagChange int
}
```

### Commands

| ID | Label | Scopes |
|---|---|---|
| `rules:apply` | Apply All Rules | settings, global |
| `rules:dry-run` | Dry-Run Rules | settings, global |

### DB functions

```go
func loadRulesV2(db *sql.DB) ([]ruleV2, error)
func insertRuleV2(db *sql.DB, r ruleV2) (int, error)
func updateRuleV2(db *sql.DB, r ruleV2) error
func deleteRuleV2(db *sql.DB, id int) error
func reorderRuleV2(db *sql.DB, id, newSortOrder int) error
func toggleRuleV2Enabled(db *sql.DB, id int, enabled bool) error
func applyRulesV2ToScope(db *sql.DB, rules []ruleV2, txnTags map[int][]tag, accountFilter map[int]bool) (catChanges, tagChanges int, err error)
func applyRulesV2ToTxnIDs(db *sql.DB, rules []ruleV2, txnTags map[int][]tag, txnIDs []int) (catChanges, tagChanges int, err error)
func dryRunRulesV2(db *sql.DB, rules []ruleV2, rows []transaction, txnTags map[int][]tag) ([]dryRunRuleResult, dryRunSummary)
```

### Import integration

`ingestCmd` now calls `applyRulesV2ToTxnIDs` instead of the old `applyCategoryRules` + `applyTagRules`. Rules are loaded fresh at import time and run only against newly imported row IDs.

### Files changed

- `db.go` — migration v4→v5 (drop old rules, create rules_v2), new CRUD functions
- `ingest.go` — replace old rule application with `applyRulesV2ToScope` / `applyRulesV2ToTxnIDs`
- `app.go` — new model fields for rules state
- `update_settings.go` — rule editor, enable/disable toggle, reorder, dry-run modal
- `render.go` — rule list rendering, rule editor modal, dry-run results modal
- `commands.go` — `rules:apply`, `rules:dry-run`
- `filter.go` — used by rules for matching (no changes, just consumed)

> **Keybinding note:** The rule editor and dry-run modal are modal scopes (`architecture.md` §3.4.2). Add `overlayEntry` entries for both in `overlayPrecedence()` (`dispatch.go`) at the correct priority positions — see `architecture.md` §3.2 for the authoritative table. Add a `modalTextContracts` entry for `scopeRuleEditor` (name and filter fields are text-editable; `cursorAware=true`, `printableFirst=true`, `vimNavSuppressed=true`). The dry-run modal is a viewer with no text fields and needs no text contract entry. Use `textField` and `modalFormNav` helpers from `dispatch.go` for the rule editor's multi-step form fields. The rules list view extends `scopeSettingsActiveRules` with new actions (`a` add, `Enter` edit, `Del` delete, `Space` toggle, `K`/`J` reorder, `A` apply, `D` dry-run). Uppercase `K`/`J`/`A`/`D` coexist with lowercase `k`/`j`/`a`/`d` in the same scope because case is preserved for single-letter keys in the registry (see key normalization in `keys.go`). Verify these don't shadow global bindings via the shadow audit test.

### Tests

- `db_test.go` — rules_v2 CRUD, ordering, enable/disable, migration preserves other data
- `filter_test.go` — (from Phase 2, reused) filter expressions evaluate correctly against transactions
- `ingest_test.go` — import applies rules_v2 correctly, category + tag actions both fire, imported rows only are touched
- `model_test.go` — rule editor flow, dry-run modal, reorder, toggle enable
- `model_test.go` / `update_settings_test.go` — `rules:apply` and `rules:dry-run` respect current account scope

### Acceptance

- [x] Rules v1 tables dropped on migration; rules_v2 created
- [x] All other v0.3 data (transactions, categories, tags, accounts) preserved
- [x] Rule editor supports: name, saved filter reference, set category, add tags, enabled toggle
- [x] Rules apply in manual order; all matching rules fire
- [x] Last category setter wins; tags accumulate
- [x] Disabled rules skipped in apply and dry-run
- [x] `rules:apply` and `rules:dry-run` always resolve scope from `m.filterAccounts`; import applies rules only to newly imported rows
- [x] Given the same scope and rule set, `rules:dry-run` and `rules:apply` target identical transaction sets
- [x] Rules Apply and Dry-Run surfaces show effective scope (`All Accounts` or `N selected accounts`)
- [x] Dry-run shows per-rule counts + up to 3 sample rows + summary totals
- [x] `K`/`J` reorders rules in Settings and keeps cursor on the moved rule
- [x] Import applies rules_v2 (replaces old rule application)

#### Acceptance Notes (v0.32.3)

- Rule/filter coupling is now strict by design: each rule references an existing saved filter ID; missing or invalid saved filters are blocked in editor save and reported in rule health rendering.
- Rule editor and filter editor strict-parse indicators now include scoped match counts (`N txns`) for sanity checking expressions before save.
- Rule/category/tag editor modals enforce the universal text-input modal safety rule via `modalTextContracts` entries in `dispatch.go`: `h/j/k/l` are never interpreted as navigation in these contexts, even under custom keybinding overrides.
- Rule tag picker preserves quick single-`Enter` toggle+close behavior only when there are no pending changes from picker-open baseline; pending-change flows submit without unintended extra toggles.

---

## Phase 4: Import Preview Integration (v0.34)

**Goal:** Replace the minimal dupe modal with a combined preview + decision modal that shows duplicate context before the user chooses.

### Combined import preview modal

When `scanDupesCmd` completes, open a combined preview modal for **all scans** (including `dupeCount == 0`).
The old direct auto-import path for zero-duplicate files is removed.

**Compact view (default):**

```
Import Preview: ANZ-2025-01.csv
═════════════════════════════════

Summary
  Total rows in snapshot:  142
  New transactions:        128
  Duplicates found:         14
  Parse/normalize errors:    0

Duplicate Rows (14)
───────────────────
  #   Date         Amount    Description
  1   2025-01-05   -$42.50   COUNTDOWN METRO SYDNEY
  2   2025-01-05   -$12.30   UBER *EATS
  3   2025-01-08   -$87.20   WOOLWORTHS 1234
  ...
  (showing 14 of 14 duplicates)

─────────────────────────────────
  [a] Import All (142 rows)   [s] Skip Dupes (128 rows)   [f] Full View   [Esc] Cancel
```

- Preview is backed by an immutable in-memory import snapshot (rows + dupe flags + parse diagnostics + locked ruleset metadata).
- Compact view renders duplicate rows in stable file order.
- Duplicate list is scrollable and display-capped to first 100 rows with `+N more not shown`.
- Navigation uses standard list/table navigation primitives (same action surface as transactions table):
  - `up/down` actions (default keys include `j`/`k`, arrows, and `ctrl+p`/`ctrl+n`)
- Decisions:
  - `a` — import all rows from snapshot (including duplicate-flagged rows)
  - `s` — import only non-duplicate rows from snapshot
  - `Esc` — cancel import and close preview
  - ~~`f` — toggle full view~~
  - `p` — toggle compact preview mode (`dupes-only` <-> `all-rows`)
  - `r` — toggle rules ON/OFF for preview and confirm import

**~~Full view~~ (descoped on February 15, 2026):**

~~Full-screen preview mode was removed. Compact preview now serves as the single preview surface and is fully scrollable.~~

**Esc lifecycle contract (updated):**
- `Esc` in compact preview -> cancel import and close modal

Display policy:
- ~~Rendering is capped to first 100 rows in compact and full views.~~
- Compact preview is paged at 20 rows with stable cursor+window scrolling.
- Import decisions always apply to the full snapshot, not only displayed rows.

### Post-rules preview

Post-rules preview is computed against the immutable scan snapshot and a locked ruleset captured at preview-open time.

Simulation pipeline:
1. Parse CSV rows and construct snapshot rows (stable file order).
2. Detect duplicate status per row.
3. Capture parse/normalize diagnostics per row (date/amount/required fields).
4. Load and lock active rules_v2 metadata at preview-open:
   - rule IDs
   - sort order
   - enabled/disabled state
   - materialized rule definitions used for simulation/import
5. Evaluate locked enabled rules against temporary transaction representations for all snapshot rows.
6. Populate projected category + tag outcomes for display.

Behavioral contract:
- Preview simulation is read-only (no DB writes).
- ~~Simulation runs asynchronously for all rows; UI may show loading/progress while preparing post-rules projection.~~
- Simulation currently runs synchronously in scan command path (fast-path implementation).
- If any row has parse/normalization errors, import decisions are blocked (`a`/`s` disabled) and the modal shows an error summary with row references.
- While preview modal is open, rule editing/actions remain blocked by modal precedence.
- Confirm import uses the same frozen snapshot; locked ruleset parity is guaranteed when rules are enabled at confirm time.

### Model changes

```go
// Import preview overlay state
importPreviewOpen      bool
importPreviewPostRules bool   // false=raw/rules-off, true=rules-on
importPreviewShowAll   bool   // false=dupes-only compact, true=all-rows compact
importPreviewCursor    int
importPreviewScroll    int

// Frozen snapshot used by both preview and confirm import
importPreviewSnapshot *importPreviewSnapshot
```

```go
type importPreviewSnapshot struct {
    fileName     string
    createdAt    time.Time
    totalRows    int
    newCount     int
    dupeCount    int
    errorCount   int
    rows         []importPreviewRow        // stable file order
    parseErrors  []importPreviewParseError // import-blocking diagnostics
    lockedRules  importPreviewLockedRules  // exact ruleset used for simulation/import
}

type importPreviewLockedRules struct {
    ruleIDs    []int
    rules      []ruleV2 // materialized at preview-open
    lockReason string   // e.g. "preview-open"
}

type importPreviewRow struct {
    index       int
    sourceLine  int
    dateRaw     string
    dateISO     string
    amount      float64
    description string
    isDupe      bool

    // Simulated post-rules projection
    previewCat  string
    previewTags []string
}

type importPreviewParseError struct {
    rowIndex    int
    sourceLine  int
    field       string
    message     string
}
```

### Flow change

Old:
- `scanDupesCmd` -> `dupeScanMsg` -> if dupes=0 auto-import, else open dupe modal

New:
- `scanDupesCmd` -> `importPreviewMsg` (contains frozen snapshot) -> always open import preview modal
- User confirms `a` or `s` -> import executes from frozen snapshot (no CSV reparse)
- `Esc` cancels from preview

Message contract:

```go
type importPreviewMsg struct {
    snapshot *importPreviewSnapshot
    err      error
}
```

Implementation note:
- `scanDupesCmd` is responsible for producing the full snapshot (rows, dupe flags, diagnostics, locked rules metadata, and post-rules projections).
- Confirm import command consumes `importPreviewSnapshot` directly.
- The previous `dupeScanMsg` + `importDupeModal` path is removed.

### Commands

| ID | Label | Scopes |
|---|---|---|
| `import:all` | Import All | import_preview |
| `import:skip-dupes` | Import Skip Dupes | import_preview |
| ~~`import:full-view`~~ | ~~Toggle Full View~~ | ~~import_preview~~ |
| `import:preview-toggle` | Toggle Compact Preview Mode | import_preview |
| `import:raw-view` | Toggle Rules (ON/OFF) | import_preview |
| `import:cancel` | Cancel Import | import_preview (Esc only) |

Notes:
- `import:cancel` is intentionally bound to `Esc` only (no `c` binding).
- Navigation in `import_preview` uses standard up/down actions (default key aliases mirror transaction table behavior).

### Files changed

- `ingest.go`
  - `scanDupesCmd` returns a full frozen snapshot (`importPreviewSnapshot`)
  - add async post-rules simulation for all rows
  - add parse/normalize diagnostics collection
  - add import-from-snapshot command path
- `app.go`
  - new model fields for preview overlay + snapshot pointer
  - replace old dupe modal state usage
- `update.go`
  - handle `importPreviewMsg` and open preview for all scans (including zero dupes)
  - remove zero-dupe direct auto-import branch
- `update_settings.go` (or owning update file for import overlay handling)
  - add `updateImportPreview` handler
  - ~~enforce Esc step-down behavior~~
  - enforce single-step Esc cancel behavior
  - enforce blocked decisions while snapshot has parse errors
- `render.go`
  - replace `renderDupeModal` with `renderImportPreview` (compact only)
  - render category + tags using transaction-table primitive styling
  - render parse error summary and decision-disabled state
- `keys.go`
  - add `scopeImportPreview`
  - bind import preview actions (`a`, `s`, `r`, `p`, `esc`) and standard up/down navigation aliases
  - remove dupe modal scope bindings (`scopeDupeModal`) once migration completes
- `dispatch.go`
  - replace dupe overlay entry with import preview overlay entry at same precedence slot
  - ensure shared overlay table remains authoritative for update/footer/command scope resolution
- `commands.go`
  - migrate command-open gating to overlay-derived gate (single source of truth)
  - ensure import preview modal blocks command-open consistently
- `specs/architecture.md`
  - update import flow, overlay precedence naming, and testing guidance references to import preview
- `AGENTS.md`
  - update import flow summary to reflect snapshot-based preview and Esc lifecycle

> **Keybinding note:** `scopeImportPreview` is a modal scope (`architecture.md` §3.4.2) and fully blocks non-modal handling. Add an `overlayEntry` for `importPreviewOpen` in `overlayPrecedence()` (`dispatch.go`) at the same precedence position currently used by duplicate-decision flow. This modal has no text-editable fields, so no `modalTextContracts` entry is required. Navigation should be action-based (`up`/`down`) with default aliases matching transaction/list conventions (`j`/`k`, arrows, `ctrl+p`/`ctrl+n`). Keep decision actions explicit (`import:all`, `import:skip-dupes`, `import:cancel`), with `import:cancel` bound to `Esc` only.

### Tests

- `ingest_test.go`
  - snapshot build correctness (row order, dupe flags, counts)
  - parse/normalize diagnostics surfaced with row/source-line references
  - post-rules simulation populates both category and tags
  - import-from-snapshot parity: persisted outcomes match preview projection for imported rows
  - ruleset lock parity: confirm import uses locked rules, not current mutable rules state
- `update_*_test.go` (owning update file)
  - preview opens for both `dupeCount == 0` and `dupeCount > 0`
  - ~~Esc lifecycle: full->compact, compact->cancel~~
  - Esc lifecycle: compact->cancel
  - while `importPreviewOpen`, rules editor/actions are blocked by modal precedence
  - decisions (`a`/`s`) disabled when parse errors exist
- `model_test.go`
  - compact preview toggle, rules ON/OFF toggle, scroll behavior, decision execution
- `render_test.go`
  - ~~compact/full rendering capped at 100 rows with `+N more` indicator~~
  - compact table paging behavior and transaction-table visual parity in post-rules mode
  - parse-error banner and disabled decision hints
- `flow_test.go` (required, default suite)
  - end-to-end import preview decision paths (`a`, `s`, Esc cancel) with persisted DB assertions
  - no-partial-write failure path when snapshot contains parse errors
  - command palette/mode cannot open while import preview modal is active
- `flow_heavy_test.go` (optional for scale)
  - large-file async simulation smoke and modal responsiveness
- `dispatch_test.go` / `commands_test.go`
  - overlay precedence includes `import_preview` in correct slot
  - overlay-derived command-open gate matches overlay active state

### Acceptance

- [x] Import flow opens combined preview modal for every scan result (including zero-duplicate files)
- [x] Compact view shows summary + scrollable duplicate list in stable file order
- [ ] ~~Full view shows all displayed rows with New/DUPE status; post-rules mode shows projected category **and tags**~~
- [x] `a`/`s` decisions work in preview; `Esc` cancels import and closes modal
- [x] `c` is not bound as a cancel shortcut in import preview
- [x] Navigation uses standard up/down action surface (default aliases include vim/arrows/ctrl+p/n)
- [x] Preview/import parity is guaranteed by frozen snapshot import path (no reparse-on-confirm)
- [x] Preview/import parity is guaranteed by locked ruleset captured at preview-open (when rules are enabled)
- [ ] ~~Post-rules preview runs on all rows asynchronously without DB writes~~
- [x] Any parse/normalization errors block import decisions and are shown with row-level diagnostics
- [ ] ~~Row display capped at 100 with `+N more` indicator in compact and full views~~
- [x] While preview is open, rule edits/actions are blocked by modal precedence
- [x] Command-open gating derives from overlay state and blocks command UI while preview modal is active
- [x] Update-driven flow tests and failure-path no-partial-write regressions are added per architecture §8
- [x] `specs/architecture.md` and `AGENTS.md` are updated in the same commit to reflect finalized import-preview behavior

**Status note (February 15, 2026):**
- Phase 4 is functionally implemented for the revised compact-preview scope.
- Final sign-off is **pending** an additional detailed manual test pass (UAT round) before closure.

---

## Phase 5: Budgeting System (v0.35)

**Goal:** Enable the Budget tab and associated budgeting behavior on top of the existing schema-v6 data layer, with monthly category budgets, saved-filter-based spending targets, quarterly/annual periods, and credit-offset-aware spend calculations.

### Schema Data Baseline (Runtime v6)

Budget tables are already present in the runtime schema (`db.go`, schema v6). Phase 5 is a behavior/UI/computation phase, not a new migration phase.

```sql
-- Primary category budgets (recurring monthly with per-month overrides)
CREATE TABLE category_budgets (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    category_id INTEGER NOT NULL UNIQUE REFERENCES categories(id) ON DELETE CASCADE,
    amount      REAL NOT NULL DEFAULT 0,
    created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE category_budget_overrides (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    budget_id   INTEGER NOT NULL REFERENCES category_budgets(id) ON DELETE CASCADE,
    month_key   TEXT NOT NULL,          -- 'YYYY-MM' e.g. '2025-03'
    amount      REAL NOT NULL,
    UNIQUE(budget_id, month_key)
);

-- Advanced spending targets (saved-filter based, any period)
CREATE TABLE spending_targets (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    name        TEXT NOT NULL,
    saved_filter_id TEXT NOT NULL,       -- references saved_filters.id (strict-validated)
    amount      REAL NOT NULL DEFAULT 0,
    period_type TEXT NOT NULL DEFAULT 'monthly'
                CHECK(period_type IN ('monthly','quarterly','annual')),
    created_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE spending_target_overrides (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    target_id   INTEGER NOT NULL REFERENCES spending_targets(id) ON DELETE CASCADE,
    period_key  TEXT NOT NULL,           -- 'YYYY-MM', 'YYYY-Q1', 'YYYY'
    amount      REAL NOT NULL,
    UNIQUE(target_id, period_key)
);

-- Credit offset linking (refund tracking)
CREATE TABLE credit_offsets (
    id             INTEGER PRIMARY KEY AUTOINCREMENT,
    credit_txn_id  INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    debit_txn_id   INTEGER NOT NULL REFERENCES transactions(id) ON DELETE CASCADE,
    amount         REAL NOT NULL CHECK(amount > 0),  -- positive: how much of the credit offsets the debit
    created_at     TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK(credit_txn_id != debit_txn_id),
    UNIQUE(credit_txn_id, debit_txn_id)
);
```

### Go types

```go
type categoryBudget struct {
    id         int
    categoryID int
    amount     float64 // recurring monthly default
}

type budgetOverride struct {
    id       int
    budgetID int
    monthKey string  // "2025-03"
    amount   float64
}

type spendingTarget struct {
    id          int
    name        string
    savedFilterID string
    amount      float64
    periodType  string // "monthly", "quarterly", "annual"
}

type targetOverride struct {
    id        int
    targetID  int
    periodKey string // "2025-03", "2025-Q1", "2025"
    amount    float64
}

type creditOffset struct {
    id          int
    creditTxnID int
    debitTxnID  int
    amount      float64
}

// Computed for display
type budgetLine struct {
    categoryID   int
    categoryName string
    categoryColor string
    budgeted     float64
    spent        float64  // absolute value of debits (positive)
    offsets      float64  // credit offsets reducing spent
    netSpent     float64  // spent - offsets
    remaining    float64  // budgeted - netSpent
    overBudget   bool     // remaining < 0
}

type targetLine struct {
    targetID   int
    name       string
    budgeted   float64
    spent      float64
    offsets    float64
    netSpent   float64
    remaining  float64
    overBudget bool
    periodType string
    periodKey  string
}
```

### Budget calculation

This section defines the canonical compute contract for Phase 5. The intent is to
make `budget.go` and `db.go` implementations deterministic, testable, and free
of hidden query-shape assumptions.

**Definitional terms (`Phase 5 canonical`):**
- `scope-month`: month currently rendered in Budget table (`YYYY-MM`).
- `scope-window`: normalized date window with inclusive start and exclusive end.
- `scope-accounts`: account filter sourced from Manager selection (`m.filterAccounts`).
- `debit-spend`: positive magnitude of scoped debit transactions (`SUM(-amount)` for `amount < 0`).
- `offset-sum`: sum of linked `credit_offsets.amount` for scoped debit transactions.
- `effective-spend`: `debit-spend - offset-sum`.
- `raw-spend`: `debit-spend` (ignores offsets).
- `display-spend(mode)`: `effective-spend` by default, `raw-spend` when `spendModeRaw=true`.

**Date-window normalization contract:**
- For month `YYYY-MM`, compute:
  - `month_start = YYYY-MM-01`
  - `month_end = first day of next month`
- Query date predicate must be:
  - `t.date_iso >= month_start AND t.date_iso < month_end`
- Do not use `LIKE 'YYYY-MM%'` as the canonical contract; range predicates are required.

**Category budget amount resolution:**
- For each category row, effective budget amount is:
  - `COALESCE(override.amount for (budget_id, month_key), category_budgets.amount)`
- `month_key` uses exact `YYYY-MM` string match.

**Category spend aggregation (`query-shape contract`):**
- Aggregate debits by category for scoped month/accounts:

```sql
SELECT
  t.category_id,
  SUM(-t.amount) AS debit_spend
FROM transactions t
WHERE t.amount < 0
  AND t.date_iso >= :month_start
  AND t.date_iso <  :month_end
  AND (:all_accounts = 1 OR t.account_id IN (:account_ids))
GROUP BY t.category_id;
```

- Aggregate offsets by debit category for the same scoped debit set:

```sql
SELECT
  d.category_id,
  SUM(co.amount) AS offset_sum
FROM credit_offsets co
JOIN transactions d ON d.id = co.debit_txn_id
WHERE d.amount < 0
  AND d.date_iso >= :month_start
  AND d.date_iso <  :month_end
  AND (:all_accounts = 1 OR d.account_id IN (:account_ids))
GROUP BY d.category_id;
```

**Category line equation contract:**
- `spent = debit_spend`
- `offsets = offset_sum`
- `netSpent = spent - offsets`
- `displaySpent = if useRaw then spent else netSpent`
- `remaining = budgeted - displaySpent`
- `overBudget = remaining < 0`

All missing aggregate rows default to `0`.

**Account scope source of truth:**
- Budget always uses Manager account scope (`m.filterAccounts`)
- Shared semantics: `len(m.filterAccounts) == 0` means `All Accounts`
- Budget has no local scope override/toggle state

**Category budget row lifecycle:**
- Migration seeds zero rows for existing categories.
- Creating a new category in-app must auto-create `category_budgets(category_id, amount=0)` to preserve the "one budget row per category" invariant.

**Spending targets (`saved_filter_id` model):**

For each target row:
1. Resolve `periodKey` + `periodType` to `period_start` and `period_end` (exclusive end).
2. Resolve target amount via override fallback:
  - `COALESCE(spending_target_overrides.amount for (target_id, period_key), spending_targets.amount)`
3. Resolve `saved_filter_id` to loaded saved filter expression.
4. Strict-parse expression (`parseFilterStrict`) and compose with period + account scope using AST `AND` composition (no raw string concatenation).
5. Evaluate matched transactions, restricting spend to debit rows (`amount < 0`), then apply offset aggregation by matched debit txn IDs.

`periodKey` normalization:
- `monthly`: `YYYY-MM`
- `quarterly`: `YYYY-Q1|Q2|Q3|Q4`
- `annual`: `YYYY`

Quarter mapping:
- `Q1` -> Jan 1 to Apr 1
- `Q2` -> Apr 1 to Jul 1
- `Q3` -> Jul 1 to Oct 1
- `Q4` -> Oct 1 to Jan 1 of next year

Target evaluation strategy (`normative`):
1. Fetch candidate transactions constrained by `period` + `account scope`.
2. Evaluate target expression via `evalFilter` on candidates.
3. Keep matched debit rows only (`amount < 0`) for spend aggregation.
4. Fold offsets using `offsetsByDebit[txnID]` map (sum `co.amount`).

Candidate fetch shape:

```sql
SELECT t.id, t.account_id, t.category_id, t.date_iso, t.amount, t.description, t.note
FROM transactions t
WHERE t.date_iso >= :period_start
  AND t.date_iso <  :period_end
  AND (:all_accounts = 1 OR t.account_id IN (:account_ids));
```

Target saved-filter references are validated strictly (same strict policy as rules editor). Invalid/missing references cannot be saved.

**Shared spend-mode contract (Budget + Dashboard):**
- Default mode is `effective` (debits reduced by linked offsets)
- A shared command toggles `effective` vs `raw` debit spending for both tabs
- Mode is session-only (resets to `effective` on restart)
- In `raw` mode, surfaces should indicate summed offsets in scope where feasible
- Canonical mode equations:
  - `effective_mode`: `displaySpent = debit_spend - offset_sum`
  - `raw_mode`: `displaySpent = debit_spend`
  - `offset_delta = debit_spend - effective_spend` (shown as contextual indicator in raw mode where available)

### Tab structure

Add Budget tab. Current order is Manager=0, Dashboard=1, Settings=2. New order inserts Budget and reorders to put Dashboard first:

```go
const (
    tabDashboard = 0
    tabBudget    = 1
    tabManager   = 2
    tabSettings  = 3
    tabCount     = 4
)

var tabNames = []string{"Dashboard", "Budget", "Manager", "Settings"}
```

Number keys updated: `1` = Dashboard, `2` = Budget, `3` = Manager, `4` = Settings.

**Migration note:** This reorders tabs from the v0.3 layout (Manager, Dashboard, Settings). Dashboard moves to position 0 as the default landing tab. The `activeTab` default changes from `tabManager` to `tabDashboard`. Global keybindings `1`/`2`/`3` are remapped and `4` is added.

### Budget tab views

The Budget tab has two views toggled with `w` (switch view):

**Table view (default):**

```
Budget - January 2025                           [All Accounts]  [< Jan >]
═══════════════════════════════════════════════════════════════════

Category Budgets
─────────────────────────────────────────────────────────────────
  Category          Budgeted    Spent    Offsets   Remaining
  ────────          ────────    ─────    ───────   ─────────
  ● Groceries        $500.00   $423.50    $30.00    $106.50
  ● Dining            $200.00   $245.80     $0.00    -$45.80  OVER
  ● Transport         $150.00    $98.20     $0.00     $51.80
  ● Bills             $400.00   $387.00     $0.00     $13.00
  ● Entertainment     $100.00    $67.50     $0.00     $32.50
  ● Shopping          $200.00   $312.40    $50.00    -$62.40  OVER
  ● Health             $50.00    $25.00     $0.00     $25.00
  ────────          ────────    ─────    ───────   ─────────
  Total             $1600.00  $1559.40    $80.00    $120.60

Spending Targets
─────────────────────────────────────────────────────────────────
  Target                  Period      Budgeted    Spent    Remaining
  ──────                  ──────      ────────    ─────    ─────────
  Coffee habit            Monthly      $60.00    $48.50      $11.50
  Annual subscriptions    Annual     $1200.00   $450.00     $750.00
```

Compact analytics strip (always visible at bottom of Budget tab):
1. **Budget adherence %** — percent of categories currently not over budget
2. **Over-budget count** — number of categories with `remaining < 0`
3. **Variance sparkline** — month-by-month aggregate budget variance trend

**Interactions (table view):**
- `j`/`k` — navigate rows
- `Enter` — edit budget amount for focused row (inline edit)
- `o` — add month override for focused row
- `a` — add new spending target
- `Del` — delete focused spending target (category budgets can't be deleted, only zeroed); uses two-key confirm (press `Del` again to confirm) with the same timer/arming behavior used by existing Settings deletion flows
- `h`/`l` or `<`/`>` — previous/next month
- `w` — switch to planner view

Inline edit contract (`table view`):
- Entering edit seeds `budgetEditValue` from currently displayed effective amount.
- `Enter` in edit mode commits parsed decimal value via upsert path.
- `Esc` cancels edit and restores non-edit row state without writes.
- Invalid numeric input keeps editor open and sets error status; no DB writes.

**Planner view:**

```
Budget Planner - 2025                           [All Accounts]
═══════════════════════════════════════════════════════════════════

Category        Jan     Feb     Mar     Apr     May     Jun
────────        ───     ───     ───     ───     ───     ───
Groceries       500     500     500     500     500     500
  spent        (423)   (510)   (390)
  remaining      77     -10     110
Dining          200     200     250*    200     200     200
  spent        (245)   (180)   (210)
  remaining     -45      20      40

* = override (differs from recurring default)
```

**Interactions (planner view):**
- `j`/`k` — navigate categories
- `h`/`l` — navigate months
- `Enter` — edit cell (override amount for that month)
- `r` — reset override (revert to recurring default)
- `w` — switch to table view

Planner cell-edit contract:
- Editing a cell writes a row in `category_budget_overrides` for that (`budget_id`, `month_key`) pair.
- Reset (`r`) deletes override row for that exact pair.
- Planner non-override cells read recurring amount from `category_budgets.amount`.
- Override marker `*` appears iff an override row exists for displayed cell key.

### Credit offset flow

Accessed from the Manager transaction detail modal (`txn:link-offset`):

1. Open detail on a **credit** transaction (amount > 0)
2. Press `o` — "Link Offset"
3. Open debit picker seeded from same account and a relevance window around credit date (`±30 days`, newest-first secondary sort by absolute magnitude)
4. Select a debit transaction candidate (`amount < 0`)
5. Open amount entry step with default:
   - `min(remaining_credit_capacity, remaining_debit_capacity)`
6. Confirm -> execute `insertCreditOffset` transactional validation + insert
7. Refresh offset indexes (`byDebit`, `byCredit`) and detail modal render state

**Picker query-shape contract (`candidate debits`):**

```sql
SELECT t.id, t.date_iso, t.description, t.amount
FROM transactions t
WHERE t.amount < 0
  AND t.account_id = :credit_account_id
  AND t.date_iso >= :credit_date_minus_30
  AND t.date_iso <  :credit_date_plus_31
ORDER BY ABS(julianday(t.date_iso) - julianday(:credit_date)) ASC,
         t.date_iso DESC,
         ABS(t.amount) DESC;
```

**Capacity definitions used in step 5:**
- `credit_total = credit.amount` (credit txn is positive)
- `credit_linked = SUM(co.amount WHERE co.credit_txn_id = credit.id)`
- `remaining_credit_capacity = credit_total - credit_linked`
- `debit_total = ABS(debit.amount)` (debit txn is negative)
- `debit_linked = SUM(co.amount WHERE co.debit_txn_id = debit.id)`
- `remaining_debit_capacity = debit_total - debit_linked`

Both capacities must be `> 0` before allowing final confirm.

### Credit offset integrity rules

`insertCreditOffset` must validate inside one DB transaction:
1. `credit_txn_id` points to a credit transaction (`amount > 0`)
2. `debit_txn_id` points to a debit transaction (`amount < 0`)
3. Both transactions are on the same account
4. New total linked for credit transaction does not exceed available credit amount
5. New total linked for debit transaction does not exceed `ABS(debit amount)`

If any check fails, no writes occur and a descriptive error is returned.

**Transactional validation order (`implementation contract`):**
1. `BEGIN`
2. Load credit txn row `FOR` validation (id, account_id, amount, date_iso)
3. Load debit txn row `FOR` validation
4. Validate sign polarity (`credit > 0`, `debit < 0`)
5. Validate account equality
6. Load current linked sums:
   - `SUM(amount) WHERE credit_txn_id = ?`
   - `SUM(amount) WHERE debit_txn_id = ?`
7. Validate proposed amount against both remaining capacities
8. `INSERT credit_offsets (...)`
9. `COMMIT`

On any failure path: `ROLLBACK` and return actionable error text.

**Validation query snippets:**

```sql
SELECT COALESCE(SUM(amount), 0) FROM credit_offsets WHERE credit_txn_id = :credit_id;
SELECT COALESCE(SUM(amount), 0) FROM credit_offsets WHERE debit_txn_id  = :debit_id;
```

**Error contract (`examples`):**
- `selected source transaction is not a credit`
- `selected target transaction is not a debit`
- `credit and debit must belong to the same account`
- `offset exceeds remaining credit capacity`
- `offset exceeds remaining debit capacity`

Offset indicator shown in transaction detail:
```
Amount: +$30.00
  └─ Offsets: $30.00 → COUNTDOWN METRO (2025-01-15, -$42.50)
```

### Model changes

```go
// Budget tab state
budgetMonth        string   // "YYYY-MM" currently viewed
budgetYear         int      // for planner view
budgetView         int      // 0 = table, 1 = planner
budgetCursor       int      // row cursor
budgetPlannerCol   int      // month column cursor in planner
budgetEditing      bool     // inline edit active
budgetEditValue    string   // edit buffer
budgetTargetEditing bool
budgetTargetStep   int      // 0=name, 1=saved filter, 2=amount, 3=period
spendModeRaw       bool     // false=effective(default), true=raw; session-only shared mode

// Budget data
categoryBudgets    []categoryBudget
budgetOverrides    map[int][]budgetOverride  // budget_id -> overrides
spendingTargets    []spendingTarget
targetOverrides    map[int][]targetOverride   // target_id -> overrides
creditOffsetsByDebit  map[int][]creditOffset  // debit_txn_id -> offsets (budget math)
creditOffsetsByCredit map[int][]creditOffset  // credit_txn_id -> offsets (linking flow)
budgetLines        []budgetLine              // computed for display
targetLines        []targetLine              // computed for display
budgetAdherencePct float64                   // computed KPI for analytics strip
budgetOverCount    int                       // computed KPI for analytics strip
budgetVarSparkline []float64                 // monthly variance series for sparkline

// Credit offset flow
offsetLinking      bool
offsetCreditTxnID  int
offsetDebitPicker  *pickerState
offsetAmount       string
```

### Commands

| ID | Label | Scopes |
|---|---|---|
| `nav:budget` | Go to Budget | global |
| `spend:toggle-mode` | Toggle Effective/Raw Spend Mode | global |
| `budget:prev-month` | Previous Month | budget |
| `budget:next-month` | Next Month | budget |
| `budget:toggle-view` | Toggle Table/Planner | budget |
| `budget:edit` | Edit Budget Amount | budget |
| `budget:add-target` | Add Spending Target | budget, global |
| `budget:delete-target` | Delete Spending Target | budget |
| `txn:link-offset` | Link Credit Offset | detail_modal |

Command exposure policy for Budget:
- All user-visible Budget actions are command-routed.
- Context-micro commands (row/cell/edit-step specifics) are `Hidden=true` in command palette.
- Out-of-scope commands are omitted from palette search.
- In-scope but temporarily unavailable commands remain visible with disabled reason text.

Command discovery semantics (`definition contract`):
- `hidden`: command is executable by ID/routing but never listed in palette search results.
- `out-of-scope`: command omitted from palette because current `Scopes` check fails.
- `disabled`: command remains listed in palette with reason text when `Enabled(m)` returns `(false, reason)`.

Local keybinding contract for `spend:toggle-mode`:
- Bind local key `m` to `spend:toggle-mode` in `scopeBudget` (applies to both table and planner non-modal states).
- Bind local key `m` to `spend:toggle-mode` in `scopeDashboard` and `scopeDashboardFocused`.
- Do not bind `m` in modal/text-entry scopes (including dashboard timeframe/custom-input, detail modal, pickers, and form editors) to preserve modal precedence and text-input safety.
- Command remains globally callable from command palette / command mode regardless of local keybinding availability.

### DB functions

```go
func loadCategoryBudgets(db *sql.DB) ([]categoryBudget, error)
func upsertCategoryBudget(db *sql.DB, categoryID int, amount float64) error
func loadBudgetOverrides(db *sql.DB) (map[int][]budgetOverride, error)
func upsertBudgetOverride(db *sql.DB, budgetID int, monthKey string, amount float64) error
func deleteBudgetOverride(db *sql.DB, budgetID int, monthKey string) error
func loadSpendingTargets(db *sql.DB) ([]spendingTarget, error) // includes saved_filter_id
func insertSpendingTarget(db *sql.DB, t spendingTarget) (int, error)
func updateSpendingTarget(db *sql.DB, t spendingTarget) error
func deleteSpendingTarget(db *sql.DB, id int) error
func loadTargetOverrides(db *sql.DB) (map[int][]targetOverride, error)
func upsertTargetOverride(db *sql.DB, targetID int, periodKey string, amount float64) error
func loadCreditOffsets(db *sql.DB) ([]creditOffset, error)
func indexCreditOffsets(rows []creditOffset) (byDebit map[int][]creditOffset, byCredit map[int][]creditOffset)
func insertCreditOffset(db *sql.DB, creditTxnID, debitTxnID int, amount float64) error // validated + transactional
func deleteCreditOffset(db *sql.DB, id int) error
func computeBudgetLines(db *sql.DB, budgets []categoryBudget, overrides map[int][]budgetOverride, offsetsByDebit map[int][]creditOffset, month string, accountFilter map[int]bool, useRaw bool) ([]budgetLine, error)
func computeTargetLines(db *sql.DB, targets []spendingTarget, overrides map[int][]targetOverride, offsetsByDebit map[int][]creditOffset, txnTags map[int][]tag, savedFilters []savedFilter, accountFilter map[int]bool, useRaw bool) ([]targetLine, error)
```

Function-level behavior contracts:
- `loadCategoryBudgets`:
  - Returns one row per category budget table entry.
  - Must not synthesize missing categories at read time; creation path owns row guarantees.
- `upsertCategoryBudget`:
  - Upsert by `category_id` uniqueness.
  - Must preserve existing row ID when updating amount.
- `loadBudgetOverrides` / `loadTargetOverrides`:
  - Return map keyed by owning ID.
  - Value slices should be deterministic (`month_key`/`period_key` ascending) for stable rendering/tests.
- `upsertBudgetOverride` / `upsertTargetOverride`:
  - Single-row upsert by unique key.
  - No-op only when incoming value equals stored value.
- `loadSpendingTargets`:
  - Returns `saved_filter_id` as persisted.
  - Save/update paths must reject empty `saved_filter_id`.
- `insertSpendingTarget` / `updateSpendingTarget`:
  - Validate `period_type` in `{monthly, quarterly, annual}`.
  - Validate referenced `saved_filter_id` exists in loaded saved filter registry before DB write.
- `loadCreditOffsets`:
  - Returns raw rows only; no derived capacity fields.
- `indexCreditOffsets`:
  - Must return both indexes in one pass over input rows.
  - Duplicate map entries are invalid unless input rows are duplicate (which DB uniqueness prevents).
- `insertCreditOffset`:
  - Owns all sign/account/allocation checks and executes in one transaction.
- `computeBudgetLines`:
  - Must execute aggregate queries (not per-category point queries).
  - Emits one `budgetLine` per category budget row, including zero-spend categories.
- `computeTargetLines`:
  - Resolves strict-valid `saved_filter_id` expressions, composes period/account scope via AST `AND`, and computes debit/offset aggregates per target.

`computeBudgetLines` aggregation pipeline (`required order`):
1. Build budget amount map from defaults + month overrides.
2. Fetch scoped debit aggregates by category.
3. Fetch scoped offset aggregates by debit category.
4. Merge into deterministic category line order (category display order or stable name sort).
5. Apply mode equation (`useRaw` vs effective) to compute `remaining` and `overBudget`.

`computeTargetLines` aggregation pipeline (`required order`):
1. Resolve effective target amount using override/default.
2. Resolve + strict-validate target saved filter.
3. Compose `target_filter AND period_scope AND account_scope` as AST.
4. Evaluate matching txn IDs and accumulate `debit_spend`.
5. Accumulate offsets for matched debit txn IDs.
6. Apply mode equation and emit `targetLine`.

Performance contract:
- Use aggregated, indexed refresh queries and in-memory maps; avoid per-row DB lookups during render/update cycles.
- Keep a follow-up gate for very large datasets; if profiling shows sustained regressions, evaluate denormalized persisted offset totals as a future optimization.

### Files changed

- **New:** `budget.go` — budget computation logic, period helpers
- **New:** `update_budget.go` — Budget tab key handlers (table view, planner view, inline edit)
- `db.go` — schema v6 budget/offset CRUD and integrity paths
- `app.go` — new model fields, tab restructure (4 tabs), `Init` loads budget data
- `render.go` — `renderBudgetTable`, `renderBudgetPlanner`, budget tab footer
- `update_detail.go` — credit offset linking flow (Manager detail modal)
- `commands.go` — budget commands
- `keys.go` — Budget scopes/bindings and Budget jump targets (`t` table, `p` planner)

> **Keybinding note:** Keep scope growth minimal and aligned with `architecture.md` §3.4.8. Prefer composition of existing primitives over bespoke scope trees. Add `overlayEntry` entries only for true modal overlays (target editor and/or offset amount entry if implemented as overlay). Any modal with text-editable fields must register `modalTextContracts` (`cursorAware=true`, `printableFirst=true`, `vimNavSuppressed=true`) and should use `textField` + `modalFormNav` helpers. Keep `v` unbound in non-modal Budget scopes and verify shadow/reachability contracts (`architecture.md` §3.4.11).

### Tests

- `db_test.go` — budget CRUD, override upsert/delete, credit offset CRUD, migration from v4
- `budget_test.go` — `computeBudgetLines` correctness (debits only, offset reduction, override priority, multi-month), `computeTargetLines` with saved-filter references, quarterly/annual period key resolution
- `model_test.go` — budget tab navigation, inline edit, view toggle, month navigation
- `render_test.go` — budget analytics strip renders adherence card, over-budget count, and variance sparkline
- `update_detail_test.go` — credit offset linking flow
- `db_test.go` / `update_detail_test.go` — credit offset validation failures (wrong sign, cross-account, over-allocation) roll back with no partial writes
- `commands_test.go` — Budget command exposure (hidden vs disabled vs out-of-scope), global `budget:add-target`, global `spend:toggle-mode`
- `keys_test.go` — `m` binds to `spend:toggle-mode` in `scopeBudget`, `scopeDashboard`, and `scopeDashboardFocused`, and is absent from modal/text-entry scopes
- `update_budget_test.go` — spending target deletion uses app-standard two-key confirm on `Del` (first press arms, second press within confirm window deletes, expiry cancels)
- `flow_test.go` — Manager scope reflected in Budget (no Budget-local scope toggle), offset link updates effective spending, raw/effective mode toggles both Budget and Dashboard

### Acceptance

- [ ] Budget tab accessible as 2nd tab (keyboard `2`)
- [ ] Category budgets: one per category, recurring monthly amount with per-month overrides
- [ ] Spending targets: saved-filter-based, supports monthly/quarterly/annual periods
- [ ] Spending target saved-filter references are strict-valid before save
- [ ] Budget calculation: debits only, credit offsets reduce net spent
- [ ] Variance: Remaining = Budgeted - Net Spent; negative = over budget
- [ ] Table view: inline editing, month navigation, spending target CRUD
- [ ] Planner view: multi-month grid with override markers
- [ ] Budget tab shows compact analytics strip: adherence %, over-budget count, variance sparkline
- [ ] Budget uses Manager account scope directly; no Budget-local scope toggle
- [ ] Budget header shows effective scope (`All Accounts` or `N selected accounts`)
- [ ] Credit offset linking from transaction detail modal
- [ ] Credit offsets enforce sign/account/allocation constraints; invalid attempts perform no writes
- [ ] Zero-seeded defaults for all categories
- [ ] New category creation auto-creates zeroed `category_budgets` row
- [ ] Budget tab registers jump targets (`t` table, `p` planner) with app-wide jump mode; ESC returns to budget table (default)
- [ ] Shared spend mode defaults to effective debit and can be toggled to raw via `spend:toggle-mode` for the current session
- [ ] Global Budget commands are limited to `nav:budget`, `budget:add-target`, and `spend:toggle-mode`; context-micro Budget commands remain hidden from palette
- [ ] Local key `m` toggles spend mode in Budget and Dashboard non-modal scopes; modal/text-entry scopes keep `m` unbound

---

## Phase 6: Dashboard v2 (v0.36+)

**Goal:** Ship a curated 4-pane analytics dashboard with a summary header strip, domain-first pane modes with custom mode slots, drill-down to Manager with return context, and integration with the app-wide jump mode from Phase 1.

### Dashboard visual structure

The dashboard renders top-to-bottom:

1. **Timeframe controls** — chip selector + date range label (carried forward from v0.3)
2. **Summary header strip** — non-focusable KPI row (carried forward from v0.3 Overview)
3. **4-pane analytics grid** — focusable widget panes

The summary header strip is not a widget pane. It is always visible, scoped to dashboard timeframe + account selection, and renders using the same `buildDashboardScopeFilter()` from Phase 2. It preserves the v0.3 KPIs: Balance, Debits, Credits, Transaction count, Uncategorised count + amount.

### Widget primitive

**New file: `widget.go`**

```go
type widgetKind int
const (
    widgetNetCashflow widgetKind = iota
    widgetComposition
    widgetCompareBars
    widgetBudgetHealth
)

type widgetMode struct {
    id        string
    label     string
    viewType  string  // "line" | "area" | "bar" | "pie" | "table"
    filterExpr string // non-empty for custom modes; empty for curated defaults
    custom    bool    // true if loaded from config (custom slot)
}

type widget struct {
    kind       widgetKind
    title      string
    jumpKey    string       // shown in jump overlay (e.g. "n", "c", "b", "h")
    modes      []widgetMode // curated built-in modes + custom modes appended
    activeMode int
    scroll     int
}

func newDashboardWidgets(customModes []customPaneMode) []widget // v0.4 returns 4 panes
```

`newDashboardWidgets` builds the 4 panes with their curated modes, then appends any matching `customPaneMode` entries from config as additional mode slots. Custom modes inherit the pane's primary chart type if `ViewType` is empty.

Extensibility contract:
- `widgetKind` and renderer dispatch are open-ended for future pane additions.
- Domain-first ownership stays stable even if future modes use new chart primitives.

### Canonical 4-pane layout (v0.4)

1. **Net/Cashflow** (`widgetNetCashflow`, jump key: `n`)
2. **Composition** (`widgetComposition`, jump key: `c`)
3. **Compare Bars** (`widgetCompareBars`, jump key: `b`)
4. **Budget Health** (`widgetBudgetHealth`, jump key: `h`)

### Pane mode definitions (domain-first)

Each pane has curated built-in modes. Users cycle through all modes (curated + custom) with `[`/`]`. Timeframe selection is the primary dashboard control; mode cycling is the secondary control for switching analytical perspectives within a pane. There is no dynamic filter input on the dashboard.

**1. Net/Cashflow**
- `net_worth` (line/area): total balance over time (all active accounts)
- `spending` (line/area): debit spend over time (evolution of v0.3 Spending Tracker)
- `burn_runway` (line): burn rate/runway trend
- `savings_rate` (line): savings-rate trend
- *(custom modes appended from config)*

**2. Composition**
- `category_share` (mekko/pie style): category spending composition (evolution of v0.3 Spending by Category)
- `needs_wants_savings` (stacked composition)
- `top_merchants` (bar/pie hybrid)
- `recurring_share` (composition of recurring vs non-recurring)
- *(custom modes appended from config)*

**3. Compare Bars**
- `budget_vs_actual` (bar/column)
- `income_vs_expense` (bar/column)
- `month_over_month` (bar)
- *(custom modes appended from config)*

**4. Budget Health**
- `status` (progress/table): per-category budget utilization
- `variance_trend` (line/bar)
- `over_budget_hotspots` (ranked bar/list)
- *(custom modes appended from config)*

Descriptive labels like "mekko/pie style" and "bar/pie hybrid" are UX descriptions, not new `view_type` values. Each curated mode must map to one canonical renderer type in `viewType` (`line|area|bar|pie|table`) and that mapping must be covered in widget tests.

### Custom mode slots

Custom pane modes (from `[[dashboard_view]]` in `config.toml`, defined in Phase 2) appear as additional entries in the pane's mode cycle list after all curated built-in modes. They filter data through AST composition of scope and custom expression (`AND` node combining `buildDashboardScopeFilter()` + `buildCustomModeFilter(pane, mode)`), not by string concatenation.

Custom modes show their configured `name` in the mode label (e.g. "Renovation Spend"). Built-in modes show their canonical label (e.g. "Net Worth", "Spending").

Config surface for creating/editing custom modes: `Settings > Dashboard Views` (strict builder UI, same strict validation as rules and spending targets).

### Fixed layout

```
┌─────────────────────────────────────────────────────────────────┐
│  [This Month] [Last Month] [1M] ...    Jan 2025 - Jan 2025     │  timeframe
├─────────────────────────────────────────────────────────────────┤
│  Balance  $616.12   Debits  $87.80   Credits  $703.92   ...    │  summary strip
├───────────────────────────┬─────────────────────────────────────┤
│  Net/Cashflow [n]         │  Composition [c]                    │
│  ▸ Spending               │  ▸ Category Share                   │
│  (braille line chart)     │  (horizontal bar chart)             │
├───────────────────────────┼─────────────────────────────────────┤
│  Compare Bars [b]         │  Budget Health [h]                  │
│  ▸ Income vs Expense      │  ▸ Status                           │
│  (grouped bar chart)      │  (progress bars/table)              │
└───────────────────────────┴─────────────────────────────────────┘
```

2-column, 2-row grid with equal 50:50 column widths. Each pane renders at half the available terminal width. Pane renderers handle their own internal layout within the allocated width.

**Narrow terminal fallback:** When `termWidth < 80`, the 2x2 grid degrades to a 1-column, 4-row vertical stack. Panes render at full width. The dashboard becomes vertically scrollable. Jump mode keys remain the same.

### Focus model

Dashboard focus is a specialization of the app-wide jump mode (Phase 1). The dashboard registers its 4 pane jump targets (`n`/`c`/`b`/`h`) with the global jump infrastructure.

**Dashboard-specific states:**
1. **Unfocused** (default) — all 4 panes visible, none focused, summary strip and timeframe interactive
2. **Focused** — one pane has accent border, mode cycling + scroll + drill-down available

**Focused interactions:**
- `[` / `]` — previous/next mode (cycles through curated + custom modes)
- `j` / `k` — scroll within pane content
- `Enter` — drill-down to Manager
- `Esc` — unfocus (returns to unfocused state per Phase 1 dashboard default)

Entering focus via jump mode (`v` then pane key) or re-entering via `v` again. There is no dashboard-specific focus key; the global `v` is the only entry point.

### Model changes

```go
// Dashboard widget state (Phase 6 additions to global model)
dashWidgets       []widget

// Drill-down return context
drillReturn       *drillReturnState // nil = no return context active
```

Dashboard focus state is managed via the global `focusedSection` field (Phase 1). Dashboard-specific: `focusedSection` values 0-3 map to the 4 panes; -1 = unfocused.

```go
type drillReturnState struct {
    returnTab     int  // tab to return to (tabDashboard)
    focusedWidget int  // which pane was focused (-1 if unfocused)
    activeMode    int  // mode index within the focused pane
    scroll        int  // scroll position within the focused pane
    prevFilterInput string      // Manager filter input before drill
    prevFilterExpr  *filterNode // Manager parsed filter before drill
}
```

### Drill-down with return context

When a user presses `Enter` on a focused pane item:
1. Determine item expression (e.g. `cat:Groceries`, `tag:Recurring`)
2. Compose with active timeframe range (`date:start..end`)
3. Save current dashboard state to `drillReturn`: tab, focused widget, active mode, scroll, and prior Manager filter state (`filterInput`/`filterExpr`)
4. **Replace** `m.filterInput`/`m.filterExpr` with composed expression
5. Switch to Manager tab (transactions view)

**Return behavior:**
- While `drillReturn` is set, ESC from the Manager filter view returns to the dashboard and restores the saved state (focused pane, mode, scroll position)
- On drill-return ESC, restore prior Manager filter state exactly, then clear `drillReturn`
- The filter pill in Manager shows a visual indicator prefix (e.g. `[Dashboard >]`) to signal this is a drill-down context
- Navigating away from Manager by any other means (tab switch, `v` jump, etc.) clears `drillReturn`
- When `drillReturn` is nil (normal Manager usage), ESC from filter clears the filter and stays on Manager, as today

### Analytics scope

Default pane data always uses:
1. Dashboard timeframe (from `buildDashboardScopeFilter()`)
2. Account scope from Manager (`filterAccounts`)

Default dashboard panes do **not** inherit transaction search input or saved-filter state.

When a mode has a filter expression (custom mode):
1. Parse expression via strict parser (already validated at config load)
2. Compose via AST as `AND(buildDashboardScopeFilter(), customModeFilter)`

The summary header strip uses the same `buildDashboardScopeFilter()` as the panes for its KPI calculations.

### Commands

Dashboard focus commands are registered in Phase 6, complementing the Phase 1 jump mode infrastructure:

| ID | Label | Scopes |
|---|---|---|
| `dash:mode-next` | Next Widget Mode | dashboard_focused |
| `dash:mode-prev` | Previous Widget Mode | dashboard_focused |
| `dash:drill-down` | Drill Down | dashboard_focused |

Note: `dash:focus-mode` and `dash:unfocus` are replaced by the global `jump:activate` and `jump:cancel` from Phase 1. Dashboard pane targets are registered with the jump infrastructure in this phase.

### Files changed

- **New:** `widget.go` — 4-pane domain-first widget definitions, mode metadata, custom mode appending from config
- `app.go` — dashboard scope builder usage, widget state updates, `drillReturnState` type + field, summary header strip rendering
- `update_dashboard.go` — focused pane interactions (mode cycling, scroll, drill-down), drill-return context management; jump mode targets registered with Phase 1 infrastructure
- `update_transactions.go` — drill-return ESC handling (return to dashboard when `drillReturn` is set)
- `update_settings.go` — Dashboard Views config editor (strict builder for custom pane modes)
- `render.go` — 2x2 dashboard grid renderer, per-domain mode renderers, summary header strip, narrow terminal fallback, drill-return prefix in filter pill
- `commands.go` — dashboard mode/drill commands
- `keys.go` — `scopeDashboardFocused` scope with mode cycling + drill-down bindings; dashboard pane jump targets registered with global jump infrastructure
- `config.go` — `customPaneMode` load/save + validation (type defined in Phase 2; dashboard-specific loading logic here)

> **Keybinding note:** `scopeDashboardFocused` is a new tab sub-state (see `architecture.md` §3.4.10), resolved by `tabScope()` in `dispatch.go`. It is mutually exclusive with `scopeDashboard` (unfocused), `scopeDashboardTimeframe`, and `scopeDashboardCustomInput`. Keys `[`/`]`/`j`/`k`/`Enter`/`Esc` are bound here. `[`/`]` are unique to this scope (mode cycling); `j`/`k` shadow the global `down`/`up` — this is intentional per the shadow policy (§3.4.4) since they mean "scroll within pane" which is semantically compatible with cursor movement. Footer hints automatically derive from the correct scope via `activeOverlayScope()` / `tabScope()` in `dispatch.go`. The dashboard custom date editor's `modalTextContracts` entry (already present for `scopeDashboardCustomInput`) continues to enforce `printableFirst=true`. The Dashboard Views config editor in Settings (strict builder for custom pane modes) should use `textField` for name and filter expression fields and add a `modalTextContracts` entry if it introduces a new text-editing scope.

### Tests

- `widget_test.go` — pane initialization, mode bounds, custom mode appending, extensibility invariants
- `widget_test.go` — custom mode with empty `ViewType` inherits pane's primary chart type
- `render_test.go` — 2x2 layout dimensions at various terminal widths; narrow fallback triggers below 80 cols; focus state rendering (accent border)
- `render_test.go` — summary header strip renders all KPIs scoped to timeframe + accounts
- `update_dashboard_test.go` — focus via jump mode, mode cycling wraps around (curated + custom), scroll within pane, ESC unfocuses
- `update_dashboard_test.go` — drill-down composes correct expression with timeframe bounds, switches to Manager, sets `drillReturn`
- `update_dashboard_test.go` — drill-return: ESC in Manager returns to dashboard with restored pane/mode/scroll; tab-switch clears `drillReturn`
- `dashboard_test.go` — default scope uses timeframe+accounts only (not transaction/saved filters)
- `dashboard_test.go` — custom mode filter composes via AST-equivalent of `dashboard_scope AND custom_expr` (no string-concat precedence bugs)
- `config_test.go` — custom pane mode entries strict-validate and load from config.toml; invalid expr entries rejected

### Acceptance

- [ ] Dashboard renders summary header strip (non-focusable) + 4 curated panes in a 2x2 grid
- [ ] Summary header strip shows Balance, Debits, Credits, Txn count, Uncat count scoped to timeframe + accounts
- [ ] Timeframe chips and Manager account selection scope all default pane metrics and summary strip
- [ ] Default pane metrics are unaffected by transaction filter input/saved filter state
- [ ] `v` (global jump mode) with keys `n`/`c`/`b`/`h` focuses dashboard panes
- [ ] Focused pane supports `[`/`]` mode cycling (curated + custom modes) and `j`/`k` scrolling
- [ ] Custom modes from config appear after curated modes in the cycle; their labels show the configured name
- [ ] Drill-down (`Enter`) composes filter expression with timeframe, switches to Manager, sets return context
- [ ] ESC from drill-down Manager view returns to dashboard with restored pane/mode/scroll state
- [ ] Tab-switch or other navigation away from Manager clears drill-return context
- [ ] Manager filter pill shows `[Dashboard >]` prefix during drill-down context
- [ ] Custom mode filters compose via AST-equivalent `dashboard_scope AND custom_expr` semantics
- [ ] Narrow terminal (< 80 cols): panes stack vertically in 1-column layout
- [ ] Architecture supports adding panes/modes without redesigning renderer dispatch

---

## Phase 7: Interaction Contract Layer (v0.39 hardening)

Phase 7 is a pre-release hardening phase that formalizes the interaction
contracts bootstrapped in v0.32.3 (shared dispatch table, modal text
contracts, form helpers) into a full contract-driven system. It runs after
all feature phases (1-6) are complete and before final v0.4 acceptance.

**Foundation already shipped (v0.32.3):**
- Shared dispatch table in `dispatch.go` (`overlayPrecedence()`,
  `dispatchOverlayKey()`, `activeOverlayScope()`)
- Modal text input contracts (`modalTextContracts` map)
- Reusable form helpers (`textField`, `modalFormNav`)
- Footer bug fixes (rule editor, detail modal, manager modal)
- Cursor-aware upgrades (manager modal, detail notes)

**Design notes:**

This phase does NOT introduce a new abstraction layer or framework. It extends
the existing dispatch table pattern to cover interaction *intents* — the
semantic meaning of what each key does in each context — so that footer hints,
handler behavior, and test assertions can all derive from the same data.

The two primary regression patterns this addresses:
1. **New modals not getting cursor-aware text input** — solved by requiring a
   `modalTextContracts` entry for every modal with text fields (already
   enforced by tests).
2. **New forms getting inconsistent save/cancel semantics** — solved by
   declaring intent semantics per context and validating handler behavior
   against declared intents.

### Interaction intent types

```go
type InteractionIntent string

const (
    IntentMovePrev   InteractionIntent = "move_prev"
    IntentMoveNext   InteractionIntent = "move_next"
    IntentSelect     InteractionIntent = "select"
    IntentToggle     InteractionIntent = "toggle"
    IntentEdit       InteractionIntent = "edit"
    IntentConfirm    InteractionIntent = "confirm"
    IntentSave       InteractionIntent = "save"
    IntentCancel     InteractionIntent = "cancel"
    IntentDelete     InteractionIntent = "delete"
    IntentApply      InteractionIntent = "apply"
)
```

### Contract type

```go
type InteractionHint struct {
    Intent InteractionIntent
    Label  string   // footer display text (e.g. "save", "toggle", "pick")
    Omit   bool     // true = intent exists but should not show in footer
}

type InteractionContract struct {
    Scope string
    Kind  ContextKind  // list, form, viewer, workflow, inline_edit
    Hints []InteractionHint
}
```

### Context kinds

Define context kinds with default intent semantics:
- `ContextList` — pickers, file lists, command palette. Default: `enter=select`,
  `esc=cancel`, arrows move.
- `ContextForm` — manager modal, rule editor, filter edit, budget target
  editor. Default: `enter=confirm step`, `esc=cancel`, tab cycles fields.
  Modal forms have explicit open/close; inline forms have in-place semantics.
- `ContextViewer` — detail view (non-editing), dry-run results. Default:
  `esc=close`, arrows scroll.
- `ContextWorkflow` — import dupe/preview, multi-step processes. Default:
  intent-specific branch keys declared explicitly.
- `ContextInlineEdit` — dashboard custom input, settings inline editors.
  Default: printable text first, `enter=apply`, `esc=cancel`.

### Contract resolver

```go
// activeInteractionContract returns the contract for the current UI state.
// Uses the existing dispatch table to determine active scope, then looks up
// the contract for that scope.
func (m model) activeInteractionContract() InteractionContract { ... }
```

### Footer rendering migration

Replace the current `footerBindings()` → `HelpBindings()` pipeline with
contract-driven rendering:

```go
func renderFooterFromContract(contract InteractionContract, keys *KeyRegistry) string {
    // For each non-omitted hint in contract:
    //   look up the key bound to the intent's action in the contract's scope
    //   render "key label" pairs
}
```

This is an incremental migration: contexts can be moved to contract-driven
footer rendering one at a time. The dispatch table and `activeOverlayScope()`
continue to work regardless.

### Confirm vs Save vs Apply semantics

Explicit rules:
- **Confirm** (`IntentConfirm`): accept current step/item without persisting.
  Used by: rule editor step advance, picker selection.
- **Save** (`IntentSave`): persist changes to database/config. Used by:
  manager modal save, settings editor save, filter edit save.
- **Apply** (`IntentApply`): execute transformation without entering edit mode.
  Used by: category picker apply, tag picker apply, rules dry-run apply.

If a context mutates persistent state, its contract must declare whether
`IntentConfirm` implies `IntentSave`. Footer hints must distinguish these.

### Model changes

```go
// New fields in global model (Phase 7 additions)
// None required for contract types — contracts are computed from existing
// state by activeInteractionContract(). Contract types and the resolver
// live in dispatch.go alongside the existing dispatch table.
```

### Files changed

- `dispatch.go` — `InteractionIntent`, `InteractionHint`, `InteractionContract`,
  `ContextKind` types; `interactionContracts` map or per-scope contract
  declarations; `activeInteractionContract()` resolver;
  `renderFooterFromContract()` helper
- `app.go` — `footerBindings()` migrated to call `renderFooterFromContract()`
  (incremental: one context at a time)
- `render.go` — footer rendering updated to accept contract-derived hints
- `keys.go` — action-to-intent mapping helpers (optional; may live in
  `dispatch.go`)

### Tests

- `dispatch_test.go` — every scope in overlay table has a registered contract
- `dispatch_test.go` — contract intent-to-key mapping: every non-omitted
  intent has a bound key in its scope
- `dispatch_test.go` — contract kind defaults: list contexts declare
  move/select/cancel; form contexts declare confirm/cancel; etc.
- `dispatch_test.go` — footer rendering from contract produces expected
  hint strings for sample contracts
- `flow_test.go` — handler behavior matches declared intents: for each
  context, simulate the key mapped to each intent and verify the handler
  produces the expected state change
- `flow_test.go` — confirm-implies-save contexts: verify that confirm action
  persists data (DB row check)

### Acceptance

- [ ] Every overlay and tab scope has a registered `InteractionContract`
- [ ] Footer hints in all contexts are generated from contract data (no more
      manual hint strings in render functions)
- [ ] Contract intents map to valid keys in `KeyRegistry` for every scope
- [ ] Test matrix validates handler behavior against declared intents for
      all reachable states
- [ ] `IntentConfirm` vs `IntentSave` distinction is explicit in all form
      contexts that persist data
- [ ] All `modalTextContracts` entries have corresponding
      `InteractionContract` entries with compatible intent declarations
- [ ] No regression in existing UI behavior (all Phase 1-6 acceptance
      criteria still pass)
- [ ] Footer rendering migration is complete for all contexts (no mixed
      manual/contract-driven footers)

---

## Phase Summary & Dependencies

```
Phase 1: Command System Overhaul + Jump Mode (v0.31)
    │
    ├── Phase 2: Filter System (v0.32)
    │       │
    │       ├── Phase 3: Rules Engine v2 (v0.33)   [needs Phase 2 filter language]
    │       │       │
    │       │       └── Phase 4: Import Preview (v0.34)  [needs Phase 3 rules for post-rules preview]
    │       │
    │       └── Phase 5: Budgeting System (v0.35)   [needs Phase 2 for target filters]
    │               │
    │               └── Phase 6: Dashboard v2 (v0.36+)  [needs Phase 1 jump mode + Phase 2 + Phase 5]
    │
    └── Phase 7: Interaction Contract Layer (v0.39)  [needs all Phases 1-6 complete]
```

**Critical path:** Phase 1 → Phase 2 → Phase 3 → Phase 4 (serial).
**Parallel after Phase 2:** Phase 3 and Phase 5 can proceed in parallel once Phase 2 lands. Checkpoint tags may interleave across these streams only when dependency gates are satisfied and each checkpoint remains user-stable.
**Phase 6 requires:** Phase 1 (jump mode infrastructure for pane focus), Phase 2 (filter infra + strict parser + custom mode types), and Phase 5 (budget data for Budget Health pane).
**Phase 7 requires:** All feature phases (1-6) complete. It is a hardening phase that formalizes interaction contracts across the full v0.4 surface area. Foundation code (dispatch table, text contracts, form helpers) was shipped in v0.32.3.
**Phase 1 ships jump mode infrastructure** with Manager + Settings targets. Dashboard and Budget targets are registered in Phase 6 and Phase 5 respectively.
**Migration timing:** schema v5 migration ships with the first checkpoint that includes Phase 3 DB changes (preferred: v0.33.x). Budget tables are already present by schema v6; Phase 5 primarily ships Budget UI/behavior and computation contracts.

---

## Release Train, Tag Granularity, and Stability Gates

v0.4 scope is intentionally ambitious and is not reduced. Delivery is decomposed into smaller stable checkpoints.

**Version model:**
- Phase labels (`v0.31`, `v0.32`, `v0.33`, `v0.34`, `v0.35`, `v0.36+`, `v0.39`) are **phase anchors**, not the only shippable tags.
- Stable checkpoint tags use patch suffixes: `v0.31.x`, `v0.32.x`, `v0.33.x`, `v0.34.x`, `v0.35.x`, `v0.36.x`, `v0.37.x`, `v0.38.x` as needed.
- `v0.39` is reserved for stringent user testing and hardening before final acceptance.
- `v0.4` is the final acceptance release.

**Checkpoint intent:**
- Checkpoints are additive and must not reduce phase ambition or remove planned v0.4 outcomes.
- Each checkpoint must be validatable and relatively bug-free for existing users, even if not feature-complete for final v0.4.
- DB-affecting checkpoints must include migration/idempotency notes in release notes.

**Suggested checkpoint allocation (guidance):**
- `v0.31.x`: command routing foundation, jump infrastructure, scope conflict tests.
- `v0.32.x`: filter parser/evaluator, strict/permissive behavior, saved filters/config validation.
- `v0.33.x`: rules_v2 schema + CRUD + dry-run/apply + editor stabilization.
- `v0.34.x`: import preview + post-rules parity.
- `v0.35.x`: budgeting compute paths, offset integrity workflows, budget views.
- `v0.36.x`–`v0.38.x`: dashboard widget/mode system, drill-return lifecycle, layout polish.
- `v0.39`: Phase 7 interaction contract layer, UAT, regression closure, performance tuning, release docs.

---

## Schema v5 Migration Plan

Migration from schema v4 to v5 in a single `migrateFromV4ToV5(db)`:

```sql
-- 1. Drop v1 rules (fresh start)
DROP TABLE IF EXISTS category_rules;
DROP TABLE IF EXISTS tag_rules;

-- 2. Create rules_v2
CREATE TABLE rules_v2 ( ... );  -- as specified in Phase 3

-- 3. Create budget tables
CREATE TABLE category_budgets ( ... );       -- Phase 5
CREATE TABLE category_budget_overrides ( ... );
CREATE TABLE spending_targets ( ... );
CREATE TABLE spending_target_overrides ( ... );
CREATE TABLE credit_offsets ( ... CHECK(amount > 0) ... CHECK(credit_txn_id != debit_txn_id) ... );

-- 4. Seed zero budgets for existing categories
INSERT INTO category_budgets (category_id, amount)
SELECT c.id, 0
FROM categories c
WHERE NOT EXISTS (
    SELECT 1 FROM category_budgets b WHERE b.category_id = c.id
);

-- 5. Create indexes
CREATE INDEX IF NOT EXISTS idx_rules_v2_sort ON rules_v2(sort_order);
CREATE INDEX IF NOT EXISTS idx_category_budgets_cat ON category_budgets(category_id);
CREATE INDEX IF NOT EXISTS idx_credit_offsets_debit ON credit_offsets(debit_txn_id);
CREATE INDEX IF NOT EXISTS idx_credit_offsets_credit ON credit_offsets(credit_txn_id);

-- 6. Update schema version
UPDATE schema_meta SET version = 5;
```

**Preserved data:** transactions, categories, tags, transaction_tags, accounts, account_selection, imports.
**Dropped data:** category_rules, tag_rules (fresh start for rules v2).
**Behavioral guarantee:** migration must be idempotent and safe if run on partially-upgraded/dev DBs.

Operational safeguards:
- Each create/drop/index statement uses defensive `IF EXISTS`/`IF NOT EXISTS` forms where possible.
- Seed steps are conflict-safe and retry-safe (missing rows inserted, existing rows preserved).
- Migration runs in a transaction; any failure rolls back all schema/data changes.
- `schema_meta.version = 5` is written only after all preceding steps succeed.
- Migration function tolerates partially-upgraded dev DBs (missing old tables, already-created new tables, partially-created indexes).

Migration test matrix:
- Fresh database bootstrap to v5.
- Existing v4 production-shaped DB migration to v5.
- Partially-upgraded DB fixture migration retry to v5 (idempotency path).

---

## File Organization

### New files

| File | Responsibility |
|---|---|
| `filter.go` | Filter expression AST, parser, evaluator, serializer |
| `budget.go` | Budget computation logic, period helpers, budget line calculation |
| `widget.go` | Dashboard widget types, mode definitions, constructors |
| `update_budget.go` | Budget tab key handlers (table view + planner view) |

### Modified files

| File | Changes |
|---|---|
| `app.go` | New model fields (filter, rules, budget, widget state); 4-tab structure; `buildTransactionFilter()` + `buildDashboardScopeFilter()` |
| `commands.go` | Expanded registry (~30+ commands); `ExecuteByID`; scope-aware lookup |
| `keys.go` | `Binding.CommandID`; new scopes for budget, import preview, dashboard focus |
| `db.go` | Schema v5; rules_v2 CRUD; budget CRUD; credit offset CRUD; migration |
| `ingest.go` | Enhanced `scanDupesCmd` (returns rows); `applyRulesV2ToScope`/`applyRulesV2ToTxnIDs`; simulated rule preview |
| `config.go` | `savedFilter` + `customPaneMode` types; load/save/validate; strict expression validation at load |
| `render.go` | Filter pill; rule list/editor/dry-run; import preview; budget views; dashboard grid |
| `update.go` | Command-based dispatch for user-visible actions; jump mode overlay dispatch |
| `update_transactions.go` | Filter input mode; remove category filter shortcut |
| `update_settings.go` | Rules v2 editor; enable/disable; reorder |
| `update_detail.go` | Credit offset linking |
| `update_dashboard.go` | Pane focus interactions; mode cycling; drill-down with return context |
| `update_manager.go` | Minor: command routing |

### Estimated scope

~4,000–5,000 new/modified lines of application code, ~2,000–3,000 lines of tests.

## Config Compatibility

Saved filters and dashboard custom modes live in `~/.config/jaskmoney/config.toml` in v0.4.

Example mixed config:

```toml
[account.ANZ]
type = "credit"
date_format = "2006-01-02"
date_col = 1
amount_col = 2
desc_col = 3

[[saved_filter]]
name = "Groceries this month"
expr = "cat:Groceries AND date:2025-01..2025-01"

[[dashboard_view]]
pane = "net_cashflow"
name = "Renovation Spend"
expr = "tag:Renovation"
```

Compatibility rules:
- Missing `saved_filter` blocks are valid and load as an empty saved-filter list.
- Missing `dashboard_view` blocks are valid and load curated default pane modes.
- Pre-v0.4 legacy config/keybinding layouts are not supported by default in this branch; invalid or legacy files are reset to current defaults.
- Invalid saved filter expressions are rejected in strict save flows and reported with actionable errors.
- Invalid `saved_filter.expr` values found at startup are skipped with warnings (app continues).
- Invalid `dashboard_view.expr` values are rejected by strict parse validation.
- Invalid `dashboard_view.pane` or `dashboard_view.view_type` values are rejected per-entry with actionable warnings (app continues with remaining valid entries).

---

## Verification

For each stable checkpoint tag (e.g. `v0.31.x`):
1. `go build .` succeeds
2. `go vet ./...` clean
3. `go test ./...` all pass
4. Phase-relevant focused tests for changed subsystem pass
5. If DB-affecting: migration idempotency/retry checks pass for that checkpoint
6. Manual smoke test of checkpoint feature set passes
7. Publish checkpoint notes including known limitations and compatibility notes

For hardening release `v0.39`:
- `go test -tags flowheavy ./...` passes
- End-to-end v0.4 flow scenario passes
- Migration matrix passes (fresh bootstrap, v4 upgrade, partial-upgrade retry)
- Performance targets pass for interactive flows (especially filter typing/render responsiveness target from Phase 2)
- UAT feedback issues triaged and release blockers closed

Final `v0.4`:
- Full end-to-end test: create filter expression → save filter → create rule using filter → dry-run → apply rules → import with preview → set budget → view budget table + analytics strip → planner view → configure custom pane mode in Settings → dashboard focus via jump mode → mode cycling through curated + custom → drill-down to Manager → ESC returns to dashboard with restored state → verify prior Manager filter state restored
- All 7 phases complete with tests passing
- Phase 7: all interaction contracts registered, footer rendering fully contract-driven, intent-handler alignment tests pass
- Transactional safety checks pass (invalid credit offsets and invalid strict expressions do not produce partial writes)
- `go run . -validate` still works (non-TUI path)
